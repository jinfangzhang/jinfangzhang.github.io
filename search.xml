<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[ C语言剖析——X86汇编程序基础(一）]]></title>
      <url>http://yoursite.com/2017/05/31/C%E8%AF%AD%E8%A8%80%E5%89%96%E6%9E%90%E2%80%94%E2%80%94X86%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80-%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>要搞清楚 C语言 的原理,就必须深入到指令层去理解. 你编写一行代码会生成什么样的指令,要做到心中有数,所以这里只会说明一些必要的汇编语言信息</p>
<hr>
<p>##最简单的汇编程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#PURPOSE: Simple program that exits and returns a</div><div class="line">#status code back to the Linux kernel</div><div class="line">#</div><div class="line">#INPUT:none</div><div class="line">#</div><div class="line">#OUTPUT: returns a status code. This can be viewed</div><div class="line">#        by typing</div><div class="line">#</div><div class="line">#        echo $?</div><div class="line">#</div><div class="line">#        after running the program</div><div class="line">#</div><div class="line">#VARIABLES:</div><div class="line">#        %eax holds the system call number</div><div class="line">#        %ebx holds the return status</div><div class="line">#</div><div class="line">.section .data</div><div class="line">.section .text</div><div class="line">.globl _start</div><div class="line">_start:</div><div class="line">movl $1, %eax</div><div class="line">movl $4,%ebx</div><div class="line">int $0x80</div></pre></td></tr></table></figure>
<p>将这个文件保存为 hello.s (汇编程序通常以 .s 作为文件后缀),用汇编器 as 把汇编程序中的助记符翻译成机器指令,生成<strong>目标文件</strong> hello.o</p>
<blockquote>
<p>$ as hello.s -o hello.o</p>
</blockquote>
<p>然后用链接器(Linker) ld 把目标文件 hello.o<strong>链接</strong>成可执行文件 hello:</p>
<blockquote>
<p>$ ld hello.o -o hello</p>
</blockquote>
<p>有人可能会问,为什么汇编语言翻译成机器指令还需要使用有一个链接的步骤?<br>链接主要有两个作用:<br>    1) 修改「目标文件」中的信息,对地址进行重定位<br>    2) 把「多个目标文件」合并成一个执行文件</p>
<p>现在这个程序只执行一件事情 —— 退出，退出状态是 4 </p>
<pre><code>$ ./hello
</code></pre><p>$ echo  $?<br>    4</p>
<p>##分析程序</p>
<p>首先， #表示单行注释，类似于 C语言 当中 //</p>
<pre><code>.section .data
</code></pre><p>汇编语言中以「 . 」开头的名称并不是指令的 助记符，不会被翻译成 机器指令， 而是给汇编一些提醒，叫做 汇编指示 或 伪操作.<br>「 .section指示 」把代码划分成若干个「 Section 」，程序被操作系统 加载 执行时，每一段被加载到不同地址，<strong>操作系统对不同的页面设置不同的读、写、执行权限.</strong> .data段 保存程序的数据，是可读可写的，相当于 C 程序 的全局变量，对于本程序来说没有定义数据，所以 .data段 是空的</p>
<pre><code>.section .text
</code></pre><p>.text段 保存代码，是<strong>只读和可执行的</strong>，后面那些指令都属于 .text段</p>
<pre><code>.globl _start
</code></pre><p>_start 是一个符号，符号在汇编程序中代表一个地址，可以用在指令中，汇编程序经过汇编器的处理之后，所有的符号都被替换成它所代表的地址值。在 C语言 中我们通过变量名访问一个变量，其实就是访问从某个地址开始的内存单元，通过函数名调用一个函数，其实就是跳转到该函数第一条指令所在的地址，所以变量名和函数名都是符号，本质上是代表内存地址的.</p>
<p>.globl 告诉汇编器，_start 这个符号要被链接器用到，所以要在目标文件的符号表中标记它是一个全局符号. _start 就像 C程序 的main函数一样特殊，是整个函数的入口，链接器在链接时会查找目标文件中的 _start 符号代表的地址，把它设置为整个程序的入口地址，所以每个汇编器 都要提供一个 _start 符号并且用 .globl 声明。如果一个符号没有 .globl 声明，就表示这个符号没有用 .globl 声明，就表示这个符号不会被链接器用到</p>
<pre><code>_start:
</code></pre><p>这里定义了 _start 符号，汇编器在 翻译 汇编程序会计算每个 数据对象 和 每条指令 的地址，当看到这样一个这样一个符号定义时，就把它后面一条指令的地址作为这个符号代表的地址。而 _start 这个符号比较特殊，它所代表的地址是整个程序的入口地址，所以下一条指令 movl $1, %eax 就成了程序第一条被执行的指令了</p>
<pre><code>movl $1, %eax
</code></pre><p>这是一条数据传送指令，这条指令要求 CPU 内部产生一个数字 1 并 保存到 eax 寄存器中。mov 的后缀 l 表示 long， 说明是 32 位的传送指令。这条指令不要求 CPU 读内存，1 这个数字是从 CPU 内部产生的，叫做立即数。在汇编程序中，<strong>立即数前面要加 $ </strong>,寄存器名前面要加 % ，以便和 符号名 区分开来。 </p>
<pre><code>movl $4, %ebx
</code></pre><p>与上一条指令基本格式相同，生成一个立即数，然后存放到 ebx 寄存器当中</p>
<pre><code>int $0x80
</code></pre><p>前两条指令都是为这条指令做准备的，执行这条时发生一下动作：</p>
<ol>
<li>int 指令称为 软中断指令，可以用这条指令故意产生一个异常，CPU 从用户模式切换到特权模式，然后跳转到内核代码中执行异常处理程序</li>
<li>int 指令中的立即数 \$0x80 是一个参数，在异常处理中要根据这个参数决定如何处理，在 Linux内核中 int $0x80 这种异常称为 「系统调用」。内核提供了很多系统服务供用户程序使用，但这些系统服务不能像库函数（比如 print 一样调用），因为在执行用户程序时 CPU 处于用户模式，不能直接调用，所以需要通过系统调用 切换 CPU 模式，经由异常处理程序进入内核，<strong>用户程序只能通过寄存器传入几个参数</strong>，之后就要按内核设计好的线路走了，而不能任由用户程序随心所欲的调用</li>
<li>eax 和 ebx 是传递给「系统调用」的两个参数。eax 的值是系统调用号，Linux 的各种系统调用都是由 int $0x80 指令引发的，内核需要通过 eax 判断用户需要哪个系统调用，_exit 的系统调用号是 1 . ebx 的值是传给 _exit 的参数，表示退出状态. 大多数系统调用完成之后，会返回用户空间继续执行后面的指令，而 <strong>_ext 系统比较特殊，它会终止当前而不是反回用户空间继续执行</strong>， 这个大概解释了「 echo $?」打印出来的为什么是 4（明明我们没有进行输入怎么就打印了？）</li>
</ol>
<hr>
<p>本节重点：</p>
<ol>
<li>「 .section指示 」把代码划分成若干个「 Section 」，程序被操作系统 加载 执行时，每一段被加载到不同地址，操作系统对不同的页面设置不同的读、写、执行权限.</li>
<li>.data段 保存程序的数据，是可读可写的，相当于 C 程序 的全局变量</li>
<li>.text段 只读用于保存代码</li>
<li>.globl _start 相当于 main，.globl 的作用</li>
<li>符号 地址的由来</li>
<li>系统调用的基本知识</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 2017-5 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[529]]></title>
      <url>http://yoursite.com/2017/04/04/529/</url>
      <content type="html"><![CDATA[<p>JianRan<br>2017/4/4</p>
]]></content>
      
        <categories>
            
            <category> 2017-4 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 阶段一 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Bitmap—— Android 高效加载图片]]></title>
      <url>http://yoursite.com/2017/04/04/Bitmap%E2%80%94%E2%80%94-Android-%E9%AB%98%E6%95%88%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87/</url>
      <content type="html"><![CDATA[<p>自从装完 Linux 好久都没有写文章，主要自己发现在某块内容方面严重欠缺，正在狠补当中。</p>
<p>对于 Google 文档的进度到了 “Android图片与动画”，这一块在 <a href="https://developer.android.google.cn/training/index.html?hl=zh-cn" target="_blank" rel="external">Google Training</a>上面已经找不到了，具体还是去看 胡凯翻译的<a href="http://hukai.me/android-training-course-in-chinese/basics/index.html" target="_blank" rel="external"> Google 文档</a>。哪怕只是 Training 里面依然有很多干货。</p>
<hr>
<p>本文会讲关于 Android 加载图片的一些知识。我们在通过 ImageView 来加载一张图片的时候，如果不加任何处理的话经常会出现 OOM(Out Of Memory) 的情况，哪怕只是加载一张只有几十KB的图片，通过 Android Studio 所提供 Monitor 会发现，一张如此小的图片竟然消耗了十几兆的内存，简直不要太可怕！</p>
<p>这里我们引出了一个问题，Android系统图片加载机制到底是怎么样的？ 是什么导致了一张几十KB的图片，摇身一变成内存大魔王了？</p>
<p>###Android系统加载图片机制</p>
<p> Android 色彩模式说明：</p>
<ul>
<li>ALPHA_8：每个像素占用1byte内存。</li>
<li>ARGB_4444:每个像素占用2byte内存</li>
<li>ARGB_8888:每个像素占用4byte内存</li>
<li>RGB_565:每个像素占用2byte内存</li>
</ul>
<p>Android默认的色彩模式为 ARGB_8888 ，这个色彩模式色彩最细腻，显示质量最高。但同样的，占用的内存也最大，而且不管你的图片格式是 PNG 还是 JPG 格式 Android 系统都采用 Bitmap 这个加载形式来加载。<br>假设一张1024<em>1024，模式为ARGB_8888的图片，那么它占有的内存就是：1024</em>1024*4 = 4MB</p>
<p>注：无论是怎样格式的图片，Android 都会看成是由一个一个像素组成的，然后一个一个像素加载</p>
<p>###解决问题</p>
<p>BitmapFactory 这个类提供了多个解析方法(decodeByteArray, decodeFile, decodeResource 等)用于创建 Bitmap对象，我们应该根据图片的来源选择合适的方法。比如 SD 卡中的图片可以使用 decodeFile 方法，网络上的图片可以使用 decodeStream 方法，资源文件中的图片可以使用 decodeResource 方法。这些方法会尝试为已经构建的 bitmap 分配内存，这时就会很容易导致 OOM 出现。为此每种解析方法都提供了一个可选的 BitmapFactory.Options 参数，在里面有一个 inJustDecodeBounds 的参数， 我们将他设置为 true， 就可以禁止给 Bitmap 分配内存，但是我们依然可以获得这个图片的长宽这个信息，我们可以通过这个来缩放我们图片达到适当的大小。</p>
<p>我们这里为什么要进行图片的缩放了？<br>举一个例子，某情景下我们要给用户设置一个 128 × 128 头像，但是我们如果采用直接不加处理的显示一个 1920 × 1080 的一个图片，尽管我们最终只能在 128 × 128 这个面积下看到图像，但是 Android系统 会给它分配 1920 × 1080 × 4KB大小的内存。<br>所以我们要将图片缩放到适当大小，我们完全没有必要为了一个 “头像” 而是用如此大的内存消耗</p>
<p>我们可以通过如下方法获取图片的长宽：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</div><div class="line">options.inJustDecodeBounds = <span class="keyword">true</span>;</div><div class="line">BitmapFactory.decodeResource(getResources(), R.id.image, options);</div><div class="line"><span class="keyword">int</span> imageHeight = options.outHeight;</div><div class="line"><span class="keyword">int</span> imageWidth = options.outWidth;</div></pre></td></tr></table></figure></p>
<p>我们知道图片原本的长宽，下来我们要根据我们要使用的的具体的长宽进行缩放，使用的是在 BitmapFactory.Options 中的 inSampleSize 的属性，这个属性的意思大概是缩放比例的意思，例如, 一个分辨率为2048x1536的图片，如果设置 inSampleSize 为4，那么会产出一个大约512x384大小的Bitmap。加载这张缩小的图片仅仅使用大概0.75MB的内存，如果是加载完整尺寸的图片，那么大概需要花费12MB（前提都是Bitmap的配置是 ARGB_8888）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateInSampleSize</span><span class="params">(</span></span></div><div class="line">            BitmapFactory.Options options, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight) &#123;</div><div class="line">    <span class="comment">// Raw height and width of image</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> height = options.outHeight;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = options.outWidth;</div><div class="line">    <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (height &gt; reqHeight || width &gt; reqWidth) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfHeight = height / <span class="number">2</span>;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfWidth = width / <span class="number">2</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Calculate the largest inSampleSize value that is a power of 2 and keeps both</span></div><div class="line">        <span class="comment">// height and width larger than the requested height and width.</span></div><div class="line">        <span class="keyword">while</span> ((halfHeight / inSampleSize) &gt; reqHeight</div><div class="line">                &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) &#123;</div><div class="line">            inSampleSize *= <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> inSampleSize;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>以上是 Google 文档的内容，有人会问，为什么我们要用2的倍数？
设置inSampleSize为2的幂是因为解码器最终还是会对非2的幂的数进行向下处理，获取到最靠近2的幂的数。详情参考inSampleSize的文档。
</code></pre><p>缩放比例已经确定，现在只剩下最后的生成图片了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeSampledBitmapFromResource</span><span class="params">(Resources res, <span class="keyword">int</span> resId,</span></span></div><div class="line">        <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// First decode with inJustDecodeBounds=true to check dimensions</span></div><div class="line">    <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</div><div class="line">    options.inJustDecodeBounds = <span class="keyword">true</span>;</div><div class="line">    BitmapFactory.decodeResource(res, resId, options);</div><div class="line"></div><div class="line">    <span class="comment">// Calculate inSampleSize</span></div><div class="line">    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</div><div class="line"></div><div class="line">    <span class="comment">// Decode bitmap with inSampleSize set</span></div><div class="line">    options.inJustDecodeBounds = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">return</span> BitmapFactory.decodeResource(res, resId, options);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们要把 inJustDecodeBounds 设置成 false 这样通过 decodeResource 最后返回的才是会是真正的 Bitmap 图片 </p>
]]></content>
      
        <categories>
            
            <category> 2017-4 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[起泡算法和插入算法]]></title>
      <url>http://yoursite.com/2017/03/20/%E8%B5%B7%E6%B3%A1%E7%AE%97%E6%B3%95%E5%92%8C%E6%8F%92%E5%85%A5%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="起泡算法"><a href="#起泡算法" class="headerlink" title="起泡算法"></a>起泡算法</h2><ol>
<li><p>什么是顺序？什么是逆序？<br>在由一组整数组成的序列A[0, n - 1]中，满足A[i - 1] &lt; A[i]的相邻元素称作顺序的；否则是逆序的</p>
</li>
<li><p>算法思路<br>已知有一组无序元素集合，最终我们的目的是让他们成为有序集合（这个的有序是升幂次序）。我们对这个数组进行扫描，在扫描的过程中，依次比较 A[i - 1] 和 A[i] ,如果发现他们中有逆序对的存在就相互交换，并且认为这个序列是无序的，不断的执行扫描，直到没有发现任何逆序对，我们就认为这个序列是有序的。</p>
<blockquote>
<p>注：算法思路已经做了优化，在最坏的情况下，我们的算法复杂度依然保持着$n^2$的复杂度，但是我们对于最好的情况已经成为$O(n)$的复杂度。对于起泡算法有了解同学应该清楚，我就不多说了</p>
</blockquote>
</li>
<li><p>算法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">sort(<span class="keyword">int</span>[] a)&#123;</div><div class="line">	<span class="keyword">boolean</span> sort = <span class="keyword">false</span>;<span class="comment">//默认是无序的</span></div><div class="line">	<span class="keyword">if</span>(！sort)&#123;<span class="comment">//如果是无序的就进行扫描</span></div><div class="line">	    sort = <span class="keyword">true</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;a.seiz();i++)&#123;</div><div class="line">			<span class="keyword">if</span>(a[i-<span class="number">1</span>]&gt;a[i])&#123;</div><div class="line">				<span class="comment">//交换位置</span></div><div class="line">				<span class="keyword">int</span> temp = a[i-<span class="number">1</span>];</div><div class="line">				a[i-<span class="number">1</span>] = a[i];</div><div class="line">				a[i] = tmp;</div><div class="line">				sort = <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>图示如下：<br><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdqt264nvsj30je07ltbz.jpg" alt=""></p>
</li>
<li><p>思考<br>我们的算法依然有改进的趋势，比如，在我们排序的过程当中，我们原先的机制是，只要判断这个序列是无序的，我们就从头开始遍历。如果我们在长度为 n 的序列当中，前n - k 都已是排好顺序的了，但是我们依然是从头开始。</p>
</li>
</ol>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ol>
<li><p>算法思路<br>插入排序的工作方式像许多人排序一手扑克牌。开始的时候我们左手里，一张扑克牌也没有，右手的功能是每一次拿一张扑克牌，并且从左向右依次比较左手里面的扑克牌，找到排放位置插入该位置。我们总保证左手里面的扑克牌是有序的。依照这样的方式排序整个序列。</p>
</li>
<li><p>算法实现 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">insert_sort(<span class="keyword">int</span>[] a)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; a.size(); i++)&#123;</div><div class="line">   			key = a[i];</div><div class="line">   			<span class="keyword">int</span> j = i;</div><div class="line">   			<span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; a[j-<span class="number">1</span>] &gt; key)</div><div class="line">   				a[j] = key;</div><div class="line">   				j = j - <span class="number">1</span>;</div><div class="line">   			&#125;</div><div class="line">   			a[j] = key; </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注释：算法导论的算法很棒，我简单做了一下修改就直接弄上去了</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 2017-3 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fragment（Training）]]></title>
      <url>http://yoursite.com/2017/03/20/Fragment%EF%BC%88Training%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><em>这回我要踏踏实实的跟着官网走</em></p>
<hr>
<p>对于Fragment来说，使用它可以降低和Activity的耦合，让Activity的代码块更加的简洁。</p>
<h2 id="创建一个Fragment"><a href="#创建一个Fragment" class="headerlink" title="创建一个Fragment"></a>创建一个Fragment</h2><p>如果要创建一个fragment类， 你需要必须复写的方法是 $onCreateView()$,这个方法的返回值是View，这个View就是与当前Fragment类绑定的View。 是不是很像ACtivity的 「setContentView( )」方法。</p>
<p>fragment_item_1.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:background</span>=<span class="string">"@color/colorPrimary"</span>&gt;</div><div class="line"></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>布局很简单，就是纯的一个LinearLayout</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment_First</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        View view = inflater.inflate(R.layout.fragment_item_1,container,<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">return</span> view;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建一个继承于Fragment的类然后绑定相关的View。</p>
<p>到目前为止，我们的Fragment就创建完了，接下来如何使用就要看使用者的事情了，大家已经发现了，对于fragment来说，他不像其他控件一样，如Button， TextView<br>他可以更假自由的拥有自己的逻辑。</p>
<p>我们使用「静态」的方式绑定到fragment这个控件上面</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">fragment</span></span></div><div class="line">        <span class="attr">android:name</span> = <span class="string">"io.github.jianran.workespace.fragment.Fragment_First"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</div></pre></td></tr></table></figure>
<p>解释：android:name 这个属性后面接着的是 我们之前创建那个fragment类的全称。<br>（第一部分告一段落）</p>
<h2 id="动态的处理Fragment"><a href="#动态的处理Fragment" class="headerlink" title="动态的处理Fragment"></a>动态的处理Fragment</h2><p>我们要在运行时为Activity处理（添加、 替换）Fragment。为此，我们需要一个可以放置fragment的一个空容器——FragmentLayout<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">FrameLayout</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/fragmentLayout_1"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>我们仅仅是把之前的 fragment 换成了FragmentLayout。并加了id属性，这个是为了之后更好的获取。我们通过「FragmentTransaction」事务 的方式对Activity进行管理（添加， 替换， 移除），通过<strong>getSupportFragmentManager()</strong>获取FragmentManager， 然后调用<strong>beginTransaction()</strong>来开启一个事务，进而我们就可以对其进行相关管理操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    Fragment_First f_1;</div><div class="line">    <span class="keyword">private</span> FragmentTransaction fragmentTransaction;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        f_1 = <span class="keyword">new</span> Fragment_First();</div><div class="line">        getSupportFragmentManager().beginTransaction().add(R.id.fragmentLayout_1,f_1).commit();</div><div class="line">        fragmentTransaction = getSupportFragmentManager().beginTransaction();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此我们就基本完成了fragment的添加，但是我们我们的代码出现了很大的问题。对于上述代码切实不会出现太大的问题，主要是因为他们太过于简单了。接下来我们尝试着加入一些东西，暴露一些问题出来</p>
<h2 id="Fragment的一些问题"><a href="#Fragment的一些问题" class="headerlink" title="Fragment的一些问题"></a>Fragment的一些问题</h2><p>###重复创建fragment</p>
<p>首先我们让屏幕翻转两次， 发现每翻转一次就会就会再执行一次「事务」的 add 操作。 </p>
<p><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdt97jrnslj30kt058js4.jpg" alt=""></p>
<p>这是为什么呢？因为当屏幕发生旋转，Activity将会发生重新启动，原来Activity中的fragment也会跟着Activity重新创建；这样就造成了当旋转的时候，本身存在的fragment会重新启动，然后会重新执行$onCreate（）$方法，又再次实例化了一个fragment<br>其实通过检查onCreate的参数Bundle savedInstanceState就可以判断，当前是否发生Activity的重新创建<br>接下来我们的代码进行了如下修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    Log.i(TAG,<span class="string">"onCreate"</span>);</div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(savedInstanceState == <span class="keyword">null</span>)&#123;</div><div class="line">        f_1 = <span class="keyword">new</span> Fragment_First();</div><div class="line">        fragmentTransaction = getSupportFragmentManager().beginTransaction();</div><div class="line">        fragmentTransaction.add(R.id.fragmentLayout_1,f_1).commit();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就不会发生多次重建 fragment 了</p>
<p>###Fragment.setArguments(Bundle bundle)</p>
<p>大家看官方文档的时候会发现，他们不是构造函数的方式进行传入参数，非要使用<strong>Fragment.setArguments(Bundle bundle)</strong>这个方式来，我们在上一层代码的前提下，我们进行一下修改。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment_First</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String mArg = <span class="string">"没有参数"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String TAG = <span class="string">"Fragment_First"</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fragment_First</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.i(<span class="string">"INFO"</span>, <span class="string">"TestFragment non-parameter constructor"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fragment_First</span><span class="params">(String mArg)</span> </span>&#123;</div><div class="line">        Log.i(<span class="string">"INFO"</span>, <span class="string">"TestFragment construct with parameter"</span>);</div><div class="line">        <span class="keyword">this</span>.mArg = mArg;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        Log.i(TAG,<span class="string">"onCreateView"</span>);</div><div class="line">        View view = inflater.inflate(R.layout.fragment_item_1,container,<span class="keyword">false</span>);</div><div class="line">        TextView textView = (TextView) view.findViewById(R.id.textView);</div><div class="line">        textView.setText(mArg);</div><div class="line">        <span class="keyword">return</span> view;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdta5801rfj30a00gf74f.jpg" alt=""><br>当我们翻转屏幕之后<br><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdta6cc5ndj30gk0a474e.jpg" alt=""></p>
<p>先别谈我们的明明传入的参数去哪里了， 我们来看看setArguments(Bundle bundle)的情况<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment_First</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARG = <span class="string">"arg"</span>;</div><div class="line">    <span class="keyword">private</span> String mArg = <span class="string">"没有参数"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String TAG = <span class="string">"Fragment_First"</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fragment_First</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.i(<span class="string">"INFO"</span>, <span class="string">"TestFragment non-parameter constructor"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fragment <span class="title">newInstance</span><span class="params">(String arg)</span></span>&#123;</div><div class="line">        Fragment_First fragment = <span class="keyword">new</span> Fragment_First();</div><div class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</div><div class="line">        bundle.putString( ARG, arg);</div><div class="line">        fragment.setArguments(bundle);</div><div class="line">        <span class="keyword">return</span> fragment;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        Log.i(TAG,<span class="string">"onCreateView"</span>);</div><div class="line">        View view = inflater.inflate(R.layout.fragment_item_1,container,<span class="keyword">false</span>);</div><div class="line">        TextView textView = (TextView) view.findViewById(R.id.textView);</div><div class="line">        textView.setText(getArguments().getString( ARG));</div><div class="line">        <span class="keyword">return</span> view;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样的话，就没有出现刚才数据丢失的情况，我们的数据很好的被保留了下来。那么这到底是怎么回事呢，我们知道设备横竖屏切换的话，当前展示给用户的 Activity 默认情况下会重新创建并展现给用户，那依附于 Activity 的 Fragment 会进行如何处理呢，我们可以通过源码来查看<br>先来看看Activity的$onCreate(Bundle saveInstance)$方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (DEBUG_LIFECYCLE) Slog.v(TAG, <span class="string">"onCreate "</span> + <span class="keyword">this</span> + <span class="string">": "</span> + savedInstanceState);</div><div class="line">        <span class="keyword">if</span> (mLastNonConfigurationInstances != <span class="keyword">null</span>) &#123;</div><div class="line">            mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mActivityInfo.parentActivityName != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mActionBar == <span class="keyword">null</span>) &#123;</div><div class="line">                mEnableDefaultActionBarUp = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mActionBar.setDefaultDisplayHomeAsUpEnabled(<span class="keyword">true</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</div><div class="line">            Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);</div><div class="line">            mFragments.restoreAllState(p, mLastNonConfigurationInstances != <span class="keyword">null</span></div><div class="line">                    ? mLastNonConfigurationInstances.fragments : <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">        mFragments.dispatchCreate();</div><div class="line">        getApplication().dispatchActivityCreated(<span class="keyword">this</span>, savedInstanceState);</div><div class="line">        <span class="keyword">if</span> (mVoiceInteractor != <span class="keyword">null</span>) &#123;</div><div class="line">            mVoiceInteractor.attachActivity(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">        mCalled = <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在代码第13行，如果 <strong>savedInstanceState</strong> 不为空，那么就调用 $mFragments.restoreAllState();$<br>                    这个方法中 mFragments 是 FragmentController，从名字就可以看出一些东西，我们深入进去。同时在这个类的注释中，我们知道，这个类管理fragment的生命周期。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Restores the saved state for all Fragments. The given FragmentManagerNonConfig are Fragment</div><div class="line">     * instances retained across configuration changes, including nested fragments</div><div class="line">     *</div><div class="line">     * <span class="doctag">@see</span> #retainNestedNonConfig()</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreAllState</span><span class="params">(Parcelable state, FragmentManagerNonConfig nonConfig)</span> </span>&#123;</div><div class="line">        mHost.mFragmentManager.restoreAllState(state, nonConfig);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>恢复所有fragment被保存的状态。我们在 restoreAllState（）方法中找到如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;fms.mActive.length; i++) &#123;</div><div class="line">            FragmentState fs = fms.mActive[i];</div><div class="line">            <span class="keyword">if</span> (fs != <span class="keyword">null</span>) &#123;</div><div class="line">                FragmentManagerNonConfig childNonConfig = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (childNonConfigs != <span class="keyword">null</span> &amp;&amp; i &lt; childNonConfigs.size()) &#123;</div><div class="line">                    childNonConfig = childNonConfigs.get(i);</div><div class="line">                &#125;</div><div class="line">                Fragment f = fs.instantiate(mHost, mParent, childNonConfig);</div><div class="line">                <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"restoreAllState: active #"</span> + i + <span class="string">": "</span> + f);</div><div class="line">                mActive.add(f);</div><div class="line">                <span class="comment">// Now that the fragment is instantiated (or came from being</span></div><div class="line">                <span class="comment">// retained above), clear mInstance in case we end up re-restoring</span></div><div class="line">                <span class="comment">// from this FragmentState again.</span></div><div class="line">                fs.mInstance = <span class="keyword">null</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mActive.add(<span class="keyword">null</span>);</div><div class="line">                <span class="keyword">if</span> (mAvailIndices == <span class="keyword">null</span>) &#123;</div><div class="line">                    mAvailIndices = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"restoreAllState: avail #"</span> + i);</div><div class="line">                mAvailIndices.add(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>我们跟进第八行，调用的$instantiate()$，并且我们一直深入，我们找到了最终的代码，同时，根据注释和相应代码的理解，我们终于明白了为什么fragment必须要有默认构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Create a new instance of a Fragment with the given class name.  This is</div><div class="line">     * the same as calling its empty constructor.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> context The calling context being used to instantiate the fragment.</div><div class="line">     * This is currently just used to get its ClassLoader.</div><div class="line">     * <span class="doctag">@param</span> fname The class name of the fragment to instantiate.</div><div class="line">     * <span class="doctag">@param</span> args Bundle of arguments to supply to the fragment, which it</div><div class="line">     * can retrieve with &#123;<span class="doctag">@link</span> #getArguments()&#125;.  May be null.</div><div class="line">     * <span class="doctag">@return</span> Returns a new fragment instance.</div><div class="line">     * <span class="doctag">@throws</span> InstantiationException If there is a failure in instantiating</div><div class="line">     * the given fragment class.  This is a runtime exception; it is not</div><div class="line">     * normally expected to happen.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fragment <span class="title">instantiate</span><span class="params">(Context context, String fname, @Nullable Bundle args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class&lt;?&gt; clazz = sClassMap.get(fname);</div><div class="line">            <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Class not found in the cache, see if it's real, and try to add it</span></div><div class="line">                clazz = context.getClassLoader().loadClass(fname);</div><div class="line">                <span class="keyword">if</span> (!Fragment.class.isAssignableFrom(clazz)) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InstantiationException(<span class="string">"Trying to instantiate a class "</span> + fname</div><div class="line">                            + <span class="string">" that is not a Fragment"</span>, <span class="keyword">new</span> ClassCastException());</div><div class="line">                &#125;</div><div class="line">                sClassMap.put(fname, clazz);</div><div class="line">            &#125;</div><div class="line">            Fragment f = (Fragment)clazz.newInstance();</div><div class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</div><div class="line">                args.setClassLoader(f.getClass().getClassLoader());</div><div class="line">                f.mArguments = args;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> f;</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InstantiationException(<span class="string">"Unable to instantiate fragment "</span> + fname</div><div class="line">                    + <span class="string">": make sure class name exists, is public, and has an"</span></div><div class="line">                    + <span class="string">" empty constructor that is public"</span>, e);</div><div class="line">        &#125; <span class="keyword">catch</span> (java.lang.InstantiationException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InstantiationException(<span class="string">"Unable to instantiate fragment "</span> + fname</div><div class="line">                    + <span class="string">": make sure class name exists, is public, and has an"</span></div><div class="line">                    + <span class="string">" empty constructor that is public"</span>, e);</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InstantiationException(<span class="string">"Unable to instantiate fragment "</span> + fname</div><div class="line">                    + <span class="string">": make sure class name exists, is public, and has an"</span></div><div class="line">                    + <span class="string">" empty constructor that is public"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>最终会通过反射无参构造实例化一个新的Fragment，并且会调用的使我们的默认构造函数。我们最终在30行的时候发现了$f.mArguments = args$, 好吧，到目前为止我们的问题大致都清楚了。</p>
]]></content>
      
        <categories>
            
            <category> 2017-3 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[汇编语言基础之寄存器（二）]]></title>
      <url>http://yoursite.com/2017/03/17/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>我们这里承接上文「<a href="https://jinfangzhang.github.io/2017/03/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">汇编语言基础之寄存器（一）</a>」</p>
<p>上回说到了在8086CPU中有20根地址线，然而寄存器却只有16位，结果我们将用组合段地址和偏移量的方式，最终我们来拼接出一个20位的地址。这里需要关注的是「段地址」在8086CPU的段寄存器中存放的位置。8086CPU有 4 个寄存器：CS、DS、SS、 ES，当8086CPU访问内存时由这4个段寄存器提供内存单元的段地址，不过目前我们只说「CS」<br>「CS」和「IP」是8086CPU中两个最关键的寄存器，他们指示了CPU当前要读取指令的地址。「CS」为代码段寄存器，「IP」为指令指针寄存器。光从名字看，大致就清楚了，这个两个的作用，之前我们知道「物理地址 = 段地址 <em> 16 + 偏移地址」，这里段地址是CS寄存器里面的内容，IP寄存器里面的内容自然是偏移地址。<br>我们用图解的方式来更好地理解<br><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdq9bzkmezj30k9097n0p.jpg" alt=""><br>初始状态下，我们在内存的20000H~2000AH有如图指令，此刻我们CPU中CS存储的是2000，IP存储的是0000，所以指向的指令是20000H = 2000H </em> 16 + 0000.<br><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdq9i0721bj30k509177s.jpg" alt=""><br>   接下来我们将「CS」和「IP」这两个寄存器里面的值送往地址加法器，得出相应的结论。<br>   <img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdq9iic7m7j30lp096tc2.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdq9iyk6uhj30ku09gwhv.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdq9jg6usrj30kk08ujux.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdq9jq3t0tj30ke097adj.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdq9k716e7j30k80ap78d.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdq9kk3vflj30l30950w0.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdq9l3kjxdj30jp096gp1.jpg" alt=""></p>
<p>到目前为止一条指令的执行流程完毕，估计对于「CS」和「IP」的工作方式有一个更全面的了解，不过总的来说8086CPU的工作过程可以简要描述如下：<br>（1）从CS：IP指令的内存单元读取命令，读取的指令进入指令缓存器；<br>（2）IP = IP + 所读取指令的长度，从而指向下一条指令<br>（3）执行指令，转到步骤（1）。</p>
<p>我们已经给出了「CS」和「IP」的作用，那么我们有时候可能会想的去修改这两个寄存器里面的值，这个时候我们应该如何修改呢？</p>
<p>我想信大家第一反应就是mov指令，但是在8086CPU中mov叫做传送指令，能修改这两个寄存器的命令叫做「转移指令」，所对应得指令为jmp。<br>使用方法：</p>
<ul>
<li><p>同时修改「CS」和「IP」的内容<br>jmp 2000:3，执行后，CS = 2000，IP = 3</p>
</li>
<li><p>仅修改IP<br>mov ax，3<br>jmp ax<br>执行之后IP= 3</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 2017-3 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 汇编语言基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[向量与列表（一）]]></title>
      <url>http://yoursite.com/2017/03/14/%E5%90%91%E9%87%8F%E4%B8%8E%E5%88%97%E8%A1%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>由一个爱写笔记的人写博客，总是喜欢在开头说点什么东西。<br>这段时间真是什么都赶到一块了，Android初见成效，马上又参加比赛，同时博客还要更新，每天还要重新回炉并且加工一些之前学过的知识，时间简直让我喘不过气来，不过人一辈子总有那么特别赶的几年，但这正是自己突飞猛进的几年，在这个时候，作为一个无时不刻都在怼问题的程序员来说，二话不说就是“干”！</p>
<p>再说一下上周写博客一个总体感受。身体上很累这个就不用说了，而且内容也很赶，是真的赶。刚开始写，总是想文章尽可能多的写，虽然都是自己学过的东西，但是很多时候，一篇文章为了速成基本是拿着书往上面抄，虽然也进行了选择，但终究这个目的太过于功利，对于自己的成长不好。这周我转变了思路，之前在“得到”里面订阅了万维钢老师的专刊，周一到周五一天一篇，每篇只讲一个道理。<br>我们不追求有多快，往往快就意味着质量低下，我不喜欢做这种没有一点意义，只是单纯一味记录而已。所以接下来，我会全程放慢速度，从每篇文章上的量转变为质，不求通过每篇文章学到什么可以让你一步成为及其牛逼的人，但是在每篇文章当中，我都会告诉你，这篇文章你看完之后会学到什么，并且力求解析清楚，同时知识点绝不会太多。<br>啰嗦到这里，我只能说光扯淡，我就消耗了这篇文章绝大部分体量~。</p>
<hr>
<p>之前在大一的时候陆陆续续学过一段时间数据结构，那个时候能力差的还很远，看的很吃力，直到这个学期才正式把它给拾了起来。之前第一篇是直接从栈开始的，之后我会逐个补全进行整理。</p>
<p>我入门是跟着邓老师（邓俊辉）的书籍和视频来学习，对于一个东西的入门，视频自然很棒的，但是入门之后就要坚决摒弃了。</p>
<p>今天我们来说向量，在数据结构中向量指的是什么？<br>向量 (vector ) 就是线性数组的一种抽象与泛化， 他也是有具有线性次序的一组元素构成的集合 V {V0, Vl , … Vn} 其中的元辈分别由秩区分和确定。这里所说的秩（Rank ) 也是与各元素一 一对应的非负整数，在这个线性的序列中， 各递归实例的秩反映了它们各自被创建的时间先后， 具体地， 每一 递归实例的秩等于早于它出现的实例总数。（其实也是顺序的一种高级的叫法）</p>
<p>通过一个概念或许已经大概了解到了什么是向量，其实向量和列表都是很基本的结构，但是正是由于很基础我们才要更好的理解并且记忆，在之后会学习栈，对于栈来说，我们既可以使用向量也可以使用列表来实现，这个例子就很好的说明了，向量和列表的基础性。既然栈可以使用向量来实现，也就是说，会使用到向量的一些方法，来帮助达成目标。如果我们的方法，执行效率很低的话，就算栈的结构再怎么厉害，终究还是快不起来，上层建筑要牢靠，底层基础要打好。</p>
<p>所以下一步我们会讲，如何来实现向量里面的方法。以下是我们将要实现的方法。<br><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdmuh8nkm8j30q30dndoe" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 2017-3 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[汇编语言基础之寄存器（一）]]></title>
      <url>http://yoursite.com/2017/03/13/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>对于一个汇编语言程序员来说，CPU中的主要部件是寄存器。寄存器是CPU中程序员可以用指令进行读写的部件。程序员通过改变寄存器中的内容来相应的实现对于CPU的控制。</p>
<p>不同CPU拥有的寄存器数量和CPU内部结构都不相同。拿8086CPU举例，有14个存储器，每一个存储器都有每一个存储器的名字。这些寄存器分别是 AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW 。这些寄存器不会一次性说完，在后面的介绍当中，当用到的时候再说。</p>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>在8086CPU的所有寄存器都是16位的，也就是说可以存放两个字节，AX,BX,CX,DX这四个存储器通常用来存储一般性的数据，被叫做<strong>通用存储器</strong>。<br>8086CPU上一代存储都是8位的，为了保证程序的兼容性，使基于上一代CPU所编写出来的程序，只要做简单修改就可以运行在8086上面。8086CPU的AX,BX,CX,DX都看做两个可独立使用的8位寄存器</p>
<ul>
<li>AX可分为AH和AL</li>
<li>BX可分为BH和BL</li>
<li>CX可分为CH和CL</li>
<li>DX可分为DH和DL</li>
</ul>
<p>继续拿AX来说，AX的低八位（0~7）构成了AL寄存器，高八位（8~15）构成了AH寄存器，其他也类似。</p>
<h2 id="简单几条汇编指令"><a href="#简单几条汇编指令" class="headerlink" title="简单几条汇编指令"></a>简单几条汇编指令</h2><table>
<thead>
<tr>
<th>汇编指令</th>
<th style="text-align:right">控制CPU完成的操作</th>
<th style="text-align:center">用高级语言的语法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov ax,18</td>
<td style="text-align:right">将18送入寄存器AX</td>
<td style="text-align:center">AX = 18</td>
</tr>
<tr>
<td>mov ah,78</td>
<td style="text-align:right">将78送入寄存器AH</td>
<td style="text-align:center">AH = 78</td>
</tr>
<tr>
<td>mov ax,bx</td>
<td style="text-align:right">将寄存器BX里面的数值移动到AX中</td>
<td style="text-align:center">AX = BX</td>
</tr>
<tr>
<td>add ax,bx</td>
<td style="text-align:right">将寄存器AX和BX中的数值相加，结果存入AX中</td>
<td style="text-align:center">AX = AX + BX</td>
</tr>
<tr>
<td>add ax,8</td>
<td style="text-align:right">将寄存器AX中的数值和8相加，结果存入AX中</td>
<td style="text-align:center">AX = AX + 8</td>
</tr>
</tbody>
</table>
<p>为了初步好理解这些命令，我们将数字采取十进制形式的，不过，在计算机中是0和1这样的数据，为了让用户看起来方便，最终显示的是XXXH,末尾的H代表16进制的意思。10H代表的就是十进制的16。</p>
<p>在数据传送指令和运算时，要注意指令的两个指令的两个操作对象的位数应当一致的。例如：<br>mov ax,bx<br>mov bx,cx<br>mov al,18H<br>add ax,bx<br>add ax,20000<br>等以上指令都是正确的，但是以下指令都是错误的<br>mov ax,bl   （在8位寄存器和16位寄存器之间传送数据）<br>mov bh,ax（在16位寄存器和8位寄存器之间传送数据）<br>mov al,20000（8位寄存器最大可以存放255的数据）<br>add al,100H（将一个高于8位的数据加到8位寄存器上面）</p>
<p>我们知道CPU访问内存时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维空间，并且每一个内存单元都有唯一的地址。我们将这个地址称为物理地址。<br>CPU通过地址总线，把一个内存单元的物理地址送入。在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的CPU可以有不同的形成地址的方式。我们现在讨论8086CPU是如何在内存形成物理地址的</p>
<p>我们的8086CPU是一个16位结构的CPU，那什么是16位结构的CPU？<br>概括的来说具有下面几方面结构<br>·运算器一次性最多处理16位的数据<br>·存储器的最大宽度是16位<br>·存储和寄存器之间的通路为16位</p>
<p>但是8086CPU有二十根地址总线，可以传输20位地址，我们的寻址能力是1MB，而8086CPU又是16位结构，如果从CPU的结构简单的输出，我们只有64K的寻址能力，所以在8086CPU中采用一种，用16位地址合成一个20位的地址。<br>逻辑如图所示<br><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdlj124c9hj30ka0cb0v3" alt=""><br>1）CPU中相关部件提供两个16位的地址，一个段地址和一个偏移地址；<br>2）段地址和偏移地址通过内部总线，送入一个称为地址加法器中<br>3）地址加法器将两个16位的地址合成一个20位的地址<br>4）地址加法器通过内部总线将20位物理地址送入输入输出控制电路<br>5）输入输出控制电路将20位总线送上地址总线<br>6）20位物理地址被地址总线传送到存储器中。</p>
<p>该地址加法器采用<strong>物理地址等 = 段地址 * 16 + 偏移地址</strong></p>
<p>本质含义是“基础地址+偏移地址=物理地址”，这个不仅让我们更好管理内存，还在使用和理解上更近了一步。</p>
<p>那么问题就来了我们段地址和偏移地址存储哪里呢？这个我们下回说~</p>
]]></content>
      
        <categories>
            
            <category> 2017-3 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 汇编语言基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[郭大神带我看ListView源码]]></title>
      <url>http://yoursite.com/2017/03/12/%E9%83%AD%E5%A4%A7%E7%A5%9E%E5%B8%A6%E6%88%91%E7%9C%8BListView%E6%BA%90%E7%A0%81/</url>
      <content type="html"><![CDATA[<p><em>以下是我的一些阅读源码的完整过程，如果是纯粹追求内容的读者，可能这篇文章不适合你</em></p>
<p>系列开始前依然由我我来扯一扯，为什么会出现这个玩意？开始博客第一周了。这篇是我的第七篇博客，一周没断更。毕竟之前就有写随笔的习惯，所以写博客没有太消耗自己的时间，而且正好我计划当中的一些事情，已经完成。原先的那个时间段，就很自然的让给了博客。</p>
<p>看源码是对于一个开发者很有提升的东西，但是相应的也是拥有一些门槛的。没有人带着看或者独自一人看的话很容易深陷代码细节不能自拔。当然对于一个学习Android刚满一年的人来说，就算是纯粹的代码依然有很多东西可以学习，不过我们看源码的主要目的不是这个，而了解主体思路，如果有时间看看细节也无妨。</p>
<p>这个系列本打算一周一大篇的，希望自己可以做到，好好加油吧~~。这一整天在看的过程当中，就算是已经跟着郭神的博客走了一遍，自己深入依然难度重重，我在这里会尽量用我可以描述的语言记录下来。</p>
<hr>
<p>看源码的时候思维一定要活跃，积极思考，看别人的代码是一个脑力活。你要不停地猜各种各样的事情，而且攻略之前，如果是Android本身的，不妨看一下API的继承图和简单的介绍，总之尽可能多的获取相关的信息。事不宜迟我们是时候开车了~。</p>
<blockquote>
<p>在看这些文档的时候，一定要看他的注释，一般有注释的地方都是比较重要的地方，并且这些注释可以帮助你去更好的理解。</p>
</blockquote>
<p>简单看一下继承图，ListView和GridView他的直接父类是AbsListView，换句话说，AbsListView的直接子类是ListView和GridView。ListView和GridView他们是十分类似的，按照面向对象语言的尿性，肯定会抽取出这两个的共同的一些特点。具体可能是什么，每个人都有每个人的思考我就不说了。只是我们看源码的时候要关注一下AbsListView,这里面必然有很重要的机制。<br><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdk8d8z87ij30k307wgm6" alt=""></p>
<p>这里看一下AbsListView的注释对于这个对象的描述</p>
<blockquote>
<p>Base class that can be used to implement virtualized lists of<br>items. A list does not have a spatial definition here. For<br>instance, subclases of this class can display the content of the<br>list in a grid, in a carousel, as stack, etc.</p>
</blockquote>
<p>这里描述，这是一个基础的类，这个类可以被使用去实现一些虚拟的列表，它后面举了一些例子。<br>到目前为止，如果不切入主题，我自己能获得帮助理解的信息都已经获取完毕，是时候开始了。</p>
<p>今天的要看的是ListView的源码。看源码切勿从头开始看，因为代码简直太多了，以我的能力（学生，刻苦自学小一年）马上就会陷入代码细节当中，可能不光我这样。我们应该选择一个我们平时比较熟悉的，之后我们马上就可以想起下面这两行。</p>
<pre><code>ListView list = (ListView) findViewById(R.id.listView);
list.setAdapter(MyAdapter);
</code></pre><p>一个行是获取ListVie的实例对象，显然没有用处。那么第二行setAdapter(),这个是一个ListView的一个方法，看来我们找到入手点了。</p>
<h2 id="setAdapter-ListAdapter-adapter"><a href="#setAdapter-ListAdapter-adapter" class="headerlink" title="setAdapter(ListAdapter adapter)"></a>setAdapter(ListAdapter adapter)</h2><p>我们依然优先看注释<br><strong>Sets the data behind this ListView. The adapter passed to this method may be wrapped by a {@link WrapperListAdapter}, depending on the ListView features currently in use. For instance, adding headers and/or footers will cause the adapter to be wrapped.</strong></p>
<p>他说设置的这些信息会用于ListView，这个adapter通过这个方法可能被WrapperListAdapter包裹，被包装成什么样子，这个取决于当前ListView的一些特点，就比如说，在这些信息的头部和尾部添加一些内容。（就好像被包裹住了一样）</p>
<p>知道这些信息感觉对于了解ListView并没有什么帮助，接下来我们进入到setAdapter的源码，在其中你可能会发现一些你认为有用的方法，就比如<em>resetList()</em> , <em>requestLayout()</em>,但是你进入到具体内容发现,对于深入理解ListView并没有什么帮助，到这里我们目前可以想到的切入点已经断了。</p>
<p>我们应该开始思考了，我还可以朝着哪里进入呢？</p>
<p>ListView怎么说也是一个View，对于一个View来说,onMeasure,onLayout,onDraw,三个方法首当其冲，onMeasure是用于测量的数据的，重要的内容基本不会在这里，onDraw就是用来绘制的，真正的核心不会在这里。onLayout是真正放置布局的地方，所以核心极有可能在这里。</p>
<blockquote>
<p>写到这里我去上了个厕所，看了一篇万维钢老师的文章，题目是《失败不是成功之母，成功是成功之母》，真正对于失败有价值的有三点要素：<br>1、及时。一旦不对马上就有人给你指出来。<br>2、对事不对人。你错了，下次改正过来就是，没有必要上升到“你这个人行不行”的层面<br>3、错误的代价很小。<br>对于咱们刚才的失误，大可放心吸收经验就是，刚才的失败正是所谓的有效的失败、成功的失败。<br>抱歉大家我有稍微扯了一扯</p>
</blockquote>
<p>稍微打断了一下思路，但是在前进之前，我们吸取教训我们大致通读一下注释，当然信息量比较多，但是在这里花时间是值得的。对于大体有一个了解之后，我们再继续。我们在做事情之前，先宏观把控然后再具体分析，就会简单多了，或许你认为这会很浪费时间，但是目前来说是必由之路。</p>
<p>我们大体阅读之后，发现AbsListView中有个很重要的内部类<strong>RecycleBin</strong><br>我们依然看注释！</p>
<p><strong>The RecycleBin facilitates reuse of views across layouts. The RecycleBin has two levels of storage: ActiveViews and ScrapViews. ActiveViews are those views which were onscreen at the start of a layout. By construction, they are displaying current information. At the end of layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews are old views that could potentially be used by the adapter to avoid allocating views unnecessarily.</strong></p>
<p>我简单说一下这个的意思，RecycleBin会帮助我们重新利用View，这个RecycleBin有两个等级存储： ActiveViews and ScrapViews。ActiviteViews 是指正在屏幕上的Views。通过构造函数，他们展现当前的信息， At the end of layout（我翻译不出来味道，就拿原文了），所有在ActiveViews中的view都会被降级进入ScrapViews。ScrapViews是一些老的View，并且未来可能被使用的，在这里保存，可以避免必要的分配View。看完了，这个内部类真的很关键！！！<br>这个内部类里面有几个重要的方法，我这个直接说明了，这个对于后面的理解都很有帮助（这里我直接粘贴了郭神一段）</p>
<ul>
<li><p><strong>fillActiveViews()</strong> 这个方法接收两个参数，第一个参数表示要存储的view的数量，第二个参数表示ListView中第一个可见元素的position值。RecycleBin当中使用mActiveViews这个数组来存储View，调用这个方法后就会根据传入的参数来将ListView中的指定元素存储到mActiveViews数组当中。</p>
</li>
<li><p><strong>getActiveView()</strong> 这个方法和fillActiveViews()是对应的，用于从mActiveViews数组当中获取数据。该方法接收一个position参数，表示元素在ListView当中的位置，方法内部会自动将position值转换成mActiveViews数组对应的下标值。需要注意的是，mActiveViews当中所存储的View，一旦被获取了之后就会从mActiveViews当中移除，下次获取同样位置的View将会返回null，也就是说mActiveViews不能被重复利用。</p>
</li>
<li><p><strong>addScrapView()</strong> 用于将一个废弃的View进行缓存，该方法接收一个View参数，当有某个View确定要废弃掉的时候(比如滚动出了屏幕)，就应该调用这个方法来对View进行缓存，RecycleBin当中使用mScrapViews和mCurrentScrap这两个List来存储废弃View。</p>
</li>
<li><p><strong>getScrapView</strong> 用于从废弃缓存中取出一个View，这些废弃缓存中的View是没有顺序可言的，因此getScrapView()方法中的算法也非常简单，就是直接从mCurrentScrap当中获取尾部的一个scrap view进行返回。</p>
</li>
<li><p><strong>setViewTypeCount()</strong> 我们都知道Adapter当中可以重写一个getViewTypeCount()来表示ListView中有几种类型的数据项，而setViewTypeCount()方法的作用就是为每种类型的数据项都单独启用一个RecycleBin缓存机制。实际上，getViewTypeCount()方法通常情况下使用的并不是很多，所以我们只要知道RecycleBin当中有这样一个功能就行了。</p>
</li>
</ul>
<p>我们继续往下，开始看onLayout(),当你搜索到的时候，你会发现在ListView里面没有，那么肯定就在他的父类里面了，果然在AbsListView中，这个注释还写着，子类不应该复写这个方法，而应该替换layoutChildren(),到这里我们应该知道了，主要的核心逻辑大概都在layoutChildren()这个方法中体现。但是我们依然看一下onLayout方法</p>
<h2 id="第一次layout"><a href="#第一次layout" class="headerlink" title="第一次layout"></a>第一次layout</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onLayout(changed, l, t, r, b);</div><div class="line"></div><div class="line">        mInLayout = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</div><div class="line">        <span class="keyword">if</span> (changed) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">                getChildAt(i).forceLayout();</div><div class="line">            &#125;</div><div class="line">            mRecycler.markChildrenDirty();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        layoutChildren();</div><div class="line">        mInLayout = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR;</div><div class="line"></div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> Move somewhere sane. This doesn't belong in onLayout().</span></div><div class="line">        <span class="keyword">if</span> (mFastScroll != <span class="keyword">null</span>) &#123;</div><div class="line">            mFastScroll.onItemCountChanged(getChildCount(), mItemCount);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>onLayout()方法中并没有做什么复杂的逻辑操作，主要就是一个判断，如果ListView的大小或者位置发生了变化，那么changed变量就会变成true，此时会要求所有的子布局都强制进行重绘。除此之外倒没有什么难理解的地方了，不过我们注意到，在第14行调用了layoutChildren()这个方法,我们进入这个layoutChildren()方法中，发现他是一个空方法，不过也正常，刚才上面也提到了，这个方法应该被子类所替换，所以我们去ListView中找这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> blockLayoutRequests = mBlockLayoutRequests;</div><div class="line">        <span class="keyword">if</span> (blockLayoutRequests) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mBlockLayoutRequests = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">super</span>.layoutChildren();</div><div class="line"></div><div class="line">            invalidate();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mAdapter == <span class="keyword">null</span>) &#123;</div><div class="line">                resetList();</div><div class="line">                invokeOnItemScrollListener();</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childrenTop = mListPadding.top;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childrenBottom = mBottom - mTop - mListPadding.bottom;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</div><div class="line"></div><div class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> delta = <span class="number">0</span>;</div><div class="line"></div><div class="line">            View sel;</div><div class="line">            View oldSel = <span class="keyword">null</span>;</div><div class="line">            View oldFirst = <span class="keyword">null</span>;</div><div class="line">            View newSel = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">            <span class="comment">// Remember stuff we will need down below</span></div><div class="line">            <span class="keyword">switch</span> (mLayoutMode) &#123;</div><div class="line">            <span class="keyword">case</span> LAYOUT_SET_SELECTION:</div><div class="line">                index = mNextSelectedPosition - mFirstPosition;</div><div class="line">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; childCount) &#123;</div><div class="line">                    newSel = getChildAt(index);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> LAYOUT_FORCE_TOP:</div><div class="line">            <span class="keyword">case</span> LAYOUT_FORCE_BOTTOM:</div><div class="line">            <span class="keyword">case</span> LAYOUT_SPECIFIC:</div><div class="line">            <span class="keyword">case</span> LAYOUT_SYNC:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> LAYOUT_MOVE_SELECTION:</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="comment">// Remember the previously selected view</span></div><div class="line">                index = mSelectedPosition - mFirstPosition;</div><div class="line">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; childCount) &#123;</div><div class="line">                    oldSel = getChildAt(index);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Remember the previous first child</span></div><div class="line">                oldFirst = getChildAt(<span class="number">0</span>);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (mNextSelectedPosition &gt;= <span class="number">0</span>) &#123;</div><div class="line">                    delta = mNextSelectedPosition - mSelectedPosition;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Caution: newSel might be null</span></div><div class="line">                newSel = getChildAt(index + delta);</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keyword">boolean</span> dataChanged = mDataChanged;</div><div class="line">            <span class="keyword">if</span> (dataChanged) &#123;</div><div class="line">                handleDataChanged();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Handle the empty set by removing all views that are visible</span></div><div class="line">            <span class="comment">// and calling it a day</span></div><div class="line">            <span class="keyword">if</span> (mItemCount == <span class="number">0</span>) &#123;</div><div class="line">                resetList();</div><div class="line">                invokeOnItemScrollListener();</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mItemCount != mAdapter.getCount()) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The content of the adapter has changed but "</span></div><div class="line">                        + <span class="string">"ListView did not receive a notification. Make sure the content of "</span></div><div class="line">                        + <span class="string">"your adapter is not modified from a background thread, but only from "</span></div><div class="line">                        + <span class="string">"the UI thread. Make sure your adapter calls notifyDataSetChanged() "</span></div><div class="line">                        + <span class="string">"when its content changes. [in ListView("</span> + getId() + <span class="string">", "</span> + getClass()</div><div class="line">                        + <span class="string">") with Adapter("</span> + mAdapter.getClass() + <span class="string">")]"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            setSelectedPositionInt(mNextSelectedPosition);</div><div class="line"></div><div class="line">            AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = <span class="keyword">null</span>;</div><div class="line">            View accessibilityFocusLayoutRestoreView = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">int</span> accessibilityFocusPosition = INVALID_POSITION;</div><div class="line"></div><div class="line">            <span class="comment">// Remember which child, if any, had accessibility focus. This must</span></div><div class="line">            <span class="comment">// occur before recycling any views, since that will clear</span></div><div class="line">            <span class="comment">// accessibility focus.</span></div><div class="line">            <span class="keyword">final</span> ViewRootImpl viewRootImpl = getViewRootImpl();</div><div class="line">            <span class="keyword">if</span> (viewRootImpl != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">final</span> View focusHost = viewRootImpl.getAccessibilityFocusedHost();</div><div class="line">                <span class="keyword">if</span> (focusHost != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">final</span> View focusChild = getAccessibilityFocusedChild(focusHost);</div><div class="line">                    <span class="keyword">if</span> (focusChild != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">if</span> (!dataChanged || isDirectChildHeaderOrFooter(focusChild)</div><div class="line">                                || focusChild.hasTransientState() || mAdapterHasStableIds) &#123;</div><div class="line">                            <span class="comment">// The views won't be changing, so try to maintain</span></div><div class="line">                            <span class="comment">// focus on the current host and virtual view.</span></div><div class="line">                            accessibilityFocusLayoutRestoreView = focusHost;</div><div class="line">                            accessibilityFocusLayoutRestoreNode = viewRootImpl</div><div class="line">                                    .getAccessibilityFocusedVirtualView();</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="comment">// If all else fails, maintain focus at the same</span></div><div class="line">                        <span class="comment">// position.</span></div><div class="line">                        accessibilityFocusPosition = getPositionForView(focusChild);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            View focusLayoutRestoreDirectChild = <span class="keyword">null</span>;</div><div class="line">            View focusLayoutRestoreView = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">            <span class="comment">// Take focus back to us temporarily to avoid the eventual call to</span></div><div class="line">            <span class="comment">// clear focus when removing the focused child below from messing</span></div><div class="line">            <span class="comment">// things up when ViewAncestor assigns focus back to someone else.</span></div><div class="line">            <span class="keyword">final</span> View focusedChild = getFocusedChild();</div><div class="line">            <span class="keyword">if</span> (focusedChild != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// <span class="doctag">TODO:</span> in some cases focusedChild.getParent() == null</span></div><div class="line"></div><div class="line">                <span class="comment">// We can remember the focused view to restore after re-layout</span></div><div class="line">                <span class="comment">// if the data hasn't changed, or if the focused position is a</span></div><div class="line">                <span class="comment">// header or footer.</span></div><div class="line">                <span class="keyword">if</span> (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)</div><div class="line">                        || focusedChild.hasTransientState() || mAdapterHasStableIds) &#123;</div><div class="line">                    focusLayoutRestoreDirectChild = focusedChild;</div><div class="line">                    <span class="comment">// Remember the specific view that had focus.</span></div><div class="line">                    focusLayoutRestoreView = findFocus();</div><div class="line">                    <span class="keyword">if</span> (focusLayoutRestoreView != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">// Tell it we are going to mess with it.</span></div><div class="line">                        focusLayoutRestoreView.dispatchStartTemporaryDetach();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                requestFocus();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Pull all children into the RecycleBin.</span></div><div class="line">            <span class="comment">// These views will be reused if possible</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> firstPosition = mFirstPosition;</div><div class="line">            <span class="keyword">final</span> RecycleBin recycleBin = mRecycler;</div><div class="line">            <span class="keyword">if</span> (dataChanged) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">                    recycleBin.addScrapView(getChildAt(i), firstPosition+i);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                recycleBin.fillActiveViews(childCount, firstPosition);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Clear out old views</span></div><div class="line">            detachAllViewsFromParent();</div><div class="line">            recycleBin.removeSkippedScrap();</div><div class="line"></div><div class="line">            <span class="keyword">switch</span> (mLayoutMode) &#123;</div><div class="line">            <span class="keyword">case</span> LAYOUT_SET_SELECTION:</div><div class="line">                <span class="keyword">if</span> (newSel != <span class="keyword">null</span>) &#123;</div><div class="line">                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    sel = fillFromMiddle(childrenTop, childrenBottom);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> LAYOUT_SYNC:</div><div class="line">                sel = fillSpecific(mSyncPosition, mSpecificTop);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> LAYOUT_FORCE_BOTTOM:</div><div class="line">                sel = fillUp(mItemCount - <span class="number">1</span>, childrenBottom);</div><div class="line">                adjustViewsUpOrDown();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> LAYOUT_FORCE_TOP:</div><div class="line">                mFirstPosition = <span class="number">0</span>;</div><div class="line">                sel = fillFromTop(childrenTop);</div><div class="line">                adjustViewsUpOrDown();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> LAYOUT_SPECIFIC:</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> selectedPosition = reconcileSelectedPosition();</div><div class="line">                sel = fillSpecific(selectedPosition, mSpecificTop);</div><div class="line">                <span class="comment">/**</span></div><div class="line">                 * When ListView is resized, FocusSelector requests an async selection for the</div><div class="line">                 * previously focused item to make sure it is still visible. If the item is not</div><div class="line">                 * selectable, it won't regain focus so instead we call FocusSelector</div><div class="line">                 * to directly request focus on the view after it is visible.</div><div class="line">                 */</div><div class="line">                <span class="keyword">if</span> (sel == <span class="keyword">null</span> &amp;&amp; mFocusSelector != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">final</span> Runnable focusRunnable = mFocusSelector</div><div class="line">                            .setupFocusIfValid(selectedPosition);</div><div class="line">                    <span class="keyword">if</span> (focusRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">                        post(focusRunnable);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> LAYOUT_MOVE_SELECTION:</div><div class="line">                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">if</span> (childCount == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (!mStackFromBottom) &#123;</div><div class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> position = lookForSelectablePosition(<span class="number">0</span>, <span class="keyword">true</span>);</div><div class="line">                        setSelectedPositionInt(position);</div><div class="line">                        sel = fillFromTop(childrenTop);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> position = lookForSelectablePosition(mItemCount - <span class="number">1</span>, <span class="keyword">false</span>);</div><div class="line">                        setSelectedPositionInt(position);</div><div class="line">                        sel = fillUp(mItemCount - <span class="number">1</span>, childrenBottom);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (mSelectedPosition &gt;= <span class="number">0</span> &amp;&amp; mSelectedPosition &lt; mItemCount) &#123;</div><div class="line">                        sel = fillSpecific(mSelectedPosition,</div><div class="line">                                oldSel == <span class="keyword">null</span> ? childrenTop : oldSel.getTop());</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFirstPosition &lt; mItemCount) &#123;</div><div class="line">                        sel = fillSpecific(mFirstPosition,</div><div class="line">                                oldFirst == <span class="keyword">null</span> ? childrenTop : oldFirst.getTop());</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        sel = fillSpecific(<span class="number">0</span>, childrenTop);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Flush any cached views that did not get reused above</span></div><div class="line">            recycleBin.scrapActiveViews();</div><div class="line"></div><div class="line">            <span class="comment">// remove any header/footer that has been temp detached and not re-attached</span></div><div class="line">            removeUnusedFixedViews(mHeaderViewInfos);</div><div class="line">            removeUnusedFixedViews(mFooterViewInfos);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (sel != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// The current selected item should get focus if items are</span></div><div class="line">                <span class="comment">// focusable.</span></div><div class="line">                <span class="keyword">if</span> (mItemsCanFocus &amp;&amp; hasFocus() &amp;&amp; !sel.hasFocus()) &#123;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> focusWasTaken = (sel == focusLayoutRestoreDirectChild &amp;&amp;</div><div class="line">                            focusLayoutRestoreView != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                            focusLayoutRestoreView.requestFocus()) || sel.requestFocus();</div><div class="line">                    <span class="keyword">if</span> (!focusWasTaken) &#123;</div><div class="line">                        <span class="comment">// Selected item didn't take focus, but we still want to</span></div><div class="line">                        <span class="comment">// make sure something else outside of the selected view</span></div><div class="line">                        <span class="comment">// has focus.</span></div><div class="line">                        <span class="keyword">final</span> View focused = getFocusedChild();</div><div class="line">                        <span class="keyword">if</span> (focused != <span class="keyword">null</span>) &#123;</div><div class="line">                            focused.clearFocus();</div><div class="line">                        &#125;</div><div class="line">                        positionSelector(INVALID_POSITION, sel);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        sel.setSelected(<span class="keyword">false</span>);</div><div class="line">                        mSelectorRect.setEmpty();</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    positionSelector(INVALID_POSITION, sel);</div><div class="line">                &#125;</div><div class="line">                mSelectedTop = sel.getTop();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> inTouchMode = mTouchMode == TOUCH_MODE_TAP</div><div class="line">                        || mTouchMode == TOUCH_MODE_DONE_WAITING;</div><div class="line">                <span class="keyword">if</span> (inTouchMode) &#123;</div><div class="line">                    <span class="comment">// If the user's finger is down, select the motion position.</span></div><div class="line">                    <span class="keyword">final</span> View child = getChildAt(mMotionPosition - mFirstPosition);</div><div class="line">                    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</div><div class="line">                        positionSelector(mMotionPosition, child);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSelectorPosition != INVALID_POSITION) &#123;</div><div class="line">                    <span class="comment">// If we had previously positioned the selector somewhere,</span></div><div class="line">                    <span class="comment">// put it back there. It might not match up with the data,</span></div><div class="line">                    <span class="comment">// but it's transitioning out so it's not a big deal.</span></div><div class="line">                    <span class="keyword">final</span> View child = getChildAt(mSelectorPosition - mFirstPosition);</div><div class="line">                    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</div><div class="line">                        positionSelector(mSelectorPosition, child);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// Otherwise, clear selection.</span></div><div class="line">                    mSelectedTop = <span class="number">0</span>;</div><div class="line">                    mSelectorRect.setEmpty();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Even if there is not selected position, we may need to</span></div><div class="line">                <span class="comment">// restore focus (i.e. something focusable in touch mode).</span></div><div class="line">                <span class="keyword">if</span> (hasFocus() &amp;&amp; focusLayoutRestoreView != <span class="keyword">null</span>) &#123;</div><div class="line">                    focusLayoutRestoreView.requestFocus();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Attempt to restore accessibility focus, if necessary.</span></div><div class="line">            <span class="keyword">if</span> (viewRootImpl != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">final</span> View newAccessibilityFocusedView = viewRootImpl.getAccessibilityFocusedHost();</div><div class="line">                <span class="keyword">if</span> (newAccessibilityFocusedView == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (accessibilityFocusLayoutRestoreView != <span class="keyword">null</span></div><div class="line">                            &amp;&amp; accessibilityFocusLayoutRestoreView.isAttachedToWindow()) &#123;</div><div class="line">                        <span class="keyword">final</span> AccessibilityNodeProvider provider =</div><div class="line">                                accessibilityFocusLayoutRestoreView.getAccessibilityNodeProvider();</div><div class="line">                        <span class="keyword">if</span> (accessibilityFocusLayoutRestoreNode != <span class="keyword">null</span> &amp;&amp; provider != <span class="keyword">null</span>) &#123;</div><div class="line">                            <span class="keyword">final</span> <span class="keyword">int</span> virtualViewId = AccessibilityNodeInfo.getVirtualDescendantId(</div><div class="line">                                    accessibilityFocusLayoutRestoreNode.getSourceNodeId());</div><div class="line">                            provider.performAction(virtualViewId,</div><div class="line">                                    AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, <span class="keyword">null</span>);</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (accessibilityFocusPosition != INVALID_POSITION) &#123;</div><div class="line">                        <span class="comment">// Bound the position within the visible children.</span></div><div class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> position = MathUtils.constrain(</div><div class="line">                                accessibilityFocusPosition - mFirstPosition, <span class="number">0</span>,</div><div class="line">                                getChildCount() - <span class="number">1</span>);</div><div class="line">                        <span class="keyword">final</span> View restoreView = getChildAt(position);</div><div class="line">                        <span class="keyword">if</span> (restoreView != <span class="keyword">null</span>) &#123;</div><div class="line">                            restoreView.requestAccessibilityFocus();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Tell focus view we are done mucking with it, if it is still in</span></div><div class="line">            <span class="comment">// our view hierarchy.</span></div><div class="line">            <span class="keyword">if</span> (focusLayoutRestoreView != <span class="keyword">null</span></div><div class="line">                    &amp;&amp; focusLayoutRestoreView.getWindowToken() != <span class="keyword">null</span>) &#123;</div><div class="line">                focusLayoutRestoreView.dispatchFinishTemporaryDetach();</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            mLayoutMode = LAYOUT_NORMAL;</div><div class="line">            mDataChanged = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (mPositionScrollAfterLayout != <span class="keyword">null</span>) &#123;</div><div class="line">                post(mPositionScrollAfterLayout);</div><div class="line">                mPositionScrollAfterLayout = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            mNeedSync = <span class="keyword">false</span>;</div><div class="line">            setNextSelectedPositionInt(mSelectedPosition);</div><div class="line"></div><div class="line">            updateScrollIndicators();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mItemCount &gt; <span class="number">0</span>) &#123;</div><div class="line">                checkSelectionChanged();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            invokeOnItemScrollListener();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (mFocusSelector != <span class="keyword">null</span>) &#123;</div><div class="line">                mFocusSelector.onLayoutComplete();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!blockLayoutRequests) &#123;</div><div class="line">                mBlockLayoutRequests = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这段代码真的很长，挑重点来说，在第12行有getChildCount()，这方法是获取当前View中有几个子View的，很显然现在为止，没有对咱们这个View进行任何添加操作，所以这里就是0了。这样我们发现一条线索，但是大家不要忘记之前我们说过的那个很重要的内部类RecycleBin,所以接下来我们在第144行发现RecycleBin，紧接着会根据dataChanged这个布尔型的值来判断执行逻辑，dataChanged只有在数据源发生改变的情况下才会变成true，其它情况都是false，因此这里会进入到第151行的执行逻辑，调用RecycleBin的fillActiveViews()方法，这个方法用来缓存当前在屏幕上显示着的View的，就目前来说，什么都没有，所有它也缓冲不成了。我们继续顺着ChildCount = 0 这条线索，在199行发现了，一个判断，我们进去里面紧接着有个判断加载布局顺序的方向，这里面有个属性是StackFromBottom，当false的时候是布局顺序是从上往下加载的。自然的我们进入<strong>fillFromTop()</strong>方法。</p>
<p>注释：<strong>Fills the list from top to bottom, starting with mFirstPosition</strong><br>从上至下，开始填充列表，并且开始的位置在<em>mFirstPosition</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> View <span class="title">fillFromTop</span><span class="params">(<span class="keyword">int</span> nextTop)</span> </span>&#123;</div><div class="line">        mFirstPosition = Math.min(mFirstPosition, mSelectedPosition);</div><div class="line">        mFirstPosition = Math.min(mFirstPosition, mItemCount - <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (mFirstPosition &lt; <span class="number">0</span>) &#123;</div><div class="line">            mFirstPosition = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> fillDown(mFirstPosition, nextTop);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>对于传进来的数值，进行了合理性的判断，然后继续调用<strong>fillDown(mFirstPosition, nextTop)</strong>，通过这个函数的参数，它指定了加载第一个元素的位置，和下一个元素的位置，这里面我们把第二个参数可以看成标注加载方向的一个变量，分析在这里，这个方法的功能已经大致分析出来了，依然看注释</p>
<p><strong>Fills the list from pos down to the end of the list view.</strong></p>
<p>这个证明了刚才的分析是正确的，我们来看它的源码（在这里我们不可避免的要看，因为这个是我们前进的一条主线）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> View <span class="title">fillDown</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> nextTop)</span> </span>&#123;</div><div class="line">        View selectedView = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> end = (mBottom - mTop);</div><div class="line">        <span class="keyword">if</span> ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">            end -= mListPadding.bottom;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (nextTop &lt; end &amp;&amp; pos &lt; mItemCount) &#123;</div><div class="line">            <span class="comment">// is this the selected item?</span></div><div class="line">            <span class="keyword">boolean</span> selected = pos == mSelectedPosition;</div><div class="line">            View child = makeAndAddView(pos, nextTop, <span class="keyword">true</span>, mListPadding.left, selected);</div><div class="line"></div><div class="line">            nextTop = child.getBottom() + mDividerHeight;</div><div class="line">            <span class="keyword">if</span> (selected) &#123;</div><div class="line">                selectedView = child;</div><div class="line">            &#125;</div><div class="line">            pos++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> selectedView;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p> 代码不多，但是我们感觉离着正确的答案越来越近了，直到现在我们依然没有看见任何在布局中添加View的代码。里面第一映入眼帘的是一个while循环，我们捎带着瞟一下上面和下面，上面是对数值的一些操作，用处不大，下面是设置一下属性内容，作用不大，看来我们的重点就在while循环里面了，首先看这个判断条件<strong>nextTop &lt; end &amp;&amp; pos &lt; mItemCount</strong>，end通过上面代码来看，应该表示能显示的最下边的像素。mItemCount，这个数据在前面被赋值了,getCount有木有很熟悉的赶脚，没错！这就是为什么继承BaseAdapter时，getCount必须进行重写，如果不重写就会认为里面没有数据，就不会加载View了，接下来，在刚才分析之中已经感觉出来了，while循环里面的就要放置View了！而且他一次性放置只放置一屏幕，不会在屏幕外也加载，就算有1000条数据，也只能一屏幕一屏幕的加载了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mItemCount = mAdapter.getCount();</div></pre></td></tr></table></figure></p>
<p>我们进入makeAndAddView(pos, nextTop, true, mListPadding.left, selected)中，第一步看注释，已经不用我说了吧~<br><strong>Obtains the view and adds it to our list of children. The view can be made fresh, converted from an unused view, or used as is if it was in the recycle bin.</strong><br>添加View并且加它到我们的list的子数据中。这个view能被刷新，并且还可以从一个不使用的View中转化过来，或者如果有的话，直接使用recycle bin里面的东西。<br>咱们之前分析的东西在里终于被重点提到了！！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> View <span class="title">makeAndAddView</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span> y, <span class="keyword">boolean</span> flow, <span class="keyword">int</span> childrenLeft,</span></span></div><div class="line">            <span class="keyword">boolean</span> selected) &#123;</div><div class="line">        <span class="keyword">if</span> (!mDataChanged) &#123;</div><div class="line">            <span class="comment">// Try to use an existing view for this position.</span></div><div class="line">            <span class="keyword">final</span> View activeView = mRecycler.getActiveView(position);</div><div class="line">            <span class="keyword">if</span> (activeView != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Found it. We're reusing an existing child, so it just needs</span></div><div class="line">                <span class="comment">// to be positioned like a scrap view.</span></div><div class="line">                setupChild(activeView, position, y, flow, childrenLeft, selected, <span class="keyword">true</span>);</div><div class="line">                <span class="keyword">return</span> activeView;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Make a new view for this position, or convert an unused view if</span></div><div class="line">        <span class="comment">// possible.</span></div><div class="line">        <span class="keyword">final</span> View child = obtainView(position, mIsScrap);</div><div class="line"></div><div class="line">        <span class="comment">// This needs to be positioned and measured.</span></div><div class="line">        setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[<span class="number">0</span>]);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> child;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在第3行判断数据是否改变，当然false啦！紧接着尝试从RecycleBin当中快速获取一个active view，不过我们目前没有对RecycleBin进行存值操作，所以得到的是null，我们继续往下，到了第16行，上面的注释写着，会在这个位置上面生成一个新View，或者可能转换一个不使用的View。</p>
<p>这个函数在ListView中找不到，在AbsListView中~<br><strong>Gets a view and have it show the data associated with the specified<br>position. This is called when we have already discovered that the view<br>is not available for reuse in the recycle bin. The only choices left are<br>converting an old view or making a new one.</strong></p>
<p>得到一个View并且让他在指定位置上展示数据，这个函数会在我们已经发现这个View不能从RecycleBin直接获得，这个接下唯一的选择就是转换一个老View或者造一个新的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="function">View <span class="title">obtainView</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span>[] outMetadata)</span> </span>&#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"obtainView"</span>);</div><div class="line"></div><div class="line">        outMetadata[<span class="number">0</span>] = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Check whether we have a transient state view. Attempt to re-bind the</span></div><div class="line">        <span class="comment">// data and discard the view if we fail.</span></div><div class="line">        <span class="keyword">final</span> View transientView = mRecycler.getTransientStateView(position);</div><div class="line">        <span class="keyword">if</span> (transientView != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">final</span> LayoutParams params = (LayoutParams) transientView.getLayoutParams();</div><div class="line"></div><div class="line">            <span class="comment">// If the view type hasn't changed, attempt to re-bind the data.</span></div><div class="line">            <span class="keyword">if</span> (params.viewType == mAdapter.getItemViewType(position)) &#123;</div><div class="line">                <span class="keyword">final</span> View updatedView = mAdapter.getView(position, transientView, <span class="keyword">this</span>);</div><div class="line"></div><div class="line">                <span class="comment">// If we failed to re-bind the data, scrap the obtained view.</span></div><div class="line">                <span class="keyword">if</span> (updatedView != transientView) &#123;</div><div class="line">                    setItemViewLayoutParams(updatedView, position);</div><div class="line">                    mRecycler.addScrapView(updatedView, position);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            outMetadata[<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            <span class="comment">// Finish the temporary detach started in addScrapView().</span></div><div class="line">            transientView.dispatchFinishTemporaryDetach();</div><div class="line">            <span class="keyword">return</span> transientView;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> View scrapView = mRecycler.getScrapView(position);</div><div class="line">        <span class="keyword">final</span> View child = mAdapter.getView(position, scrapView, <span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (scrapView != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (child != scrapView) &#123;</div><div class="line">                <span class="comment">// Failed to re-bind the data, return scrap to the heap.</span></div><div class="line">                mRecycler.addScrapView(scrapView, position);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.isTemporarilyDetached()) &#123;</div><div class="line">                outMetadata[<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                <span class="comment">// Finish the temporary detach started in addScrapView().</span></div><div class="line">                child.dispatchFinishTemporaryDetach();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mCacheColorHint != <span class="number">0</span>) &#123;</div><div class="line">            child.setDrawingCacheBackgroundColor(mCacheColorHint);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) &#123;</div><div class="line">            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        setItemViewLayoutParams(child, position);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (AccessibilityManager.getInstance(mContext).isEnabled()) &#123;</div><div class="line">            <span class="keyword">if</span> (mAccessibilityDelegate == <span class="keyword">null</span>) &#123;</div><div class="line">                mAccessibilityDelegate = <span class="keyword">new</span> ListItemAccessibilityDelegate();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (child.getAccessibilityDelegate() == <span class="keyword">null</span>) &#123;</div><div class="line">                child.setAccessibilityDelegate(mAccessibilityDelegate);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> child;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>我们会看到在第30行，他尝试这从ScrapView中获取一个，回答同样是不可以的，因为这个没有数据，我们第31行看见了，我们的adapter.getView（），这个方法我们很熟悉，我们会返回一个我们已经准备好的item，返回也是return child；</p>
<p>这个方法执行完了，我们回到makeAndAddView（），继续向下执行第19行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> View <span class="title">makeAndAddView</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span> y, <span class="keyword">boolean</span> flow, <span class="keyword">int</span> childrenLeft,</span></span></div><div class="line">            <span class="keyword">boolean</span> selected) &#123;</div><div class="line">        <span class="keyword">if</span> (!mDataChanged) &#123;</div><div class="line">            <span class="comment">// Try to use an existing view for this position.</span></div><div class="line">            <span class="keyword">final</span> View activeView = mRecycler.getActiveView(position);</div><div class="line">            <span class="keyword">if</span> (activeView != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Found it. We're reusing an existing child, so it just needs</span></div><div class="line">                <span class="comment">// to be positioned like a scrap view.</span></div><div class="line">                setupChild(activeView, position, y, flow, childrenLeft, selected, <span class="keyword">true</span>);</div><div class="line">                <span class="keyword">return</span> activeView;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Make a new view for this position, or convert an unused view if</span></div><div class="line">        <span class="comment">// possible.</span></div><div class="line">        <span class="keyword">final</span> View child = obtainView(position, mIsScrap);</div><div class="line"></div><div class="line">        <span class="comment">// This needs to be positioned and measured.</span></div><div class="line">        setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[<span class="number">0</span>]);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> child;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在第19行会调用setupChild()，忽略参数问题，光看方法名字——安装Child，看来这个方法里面将会放置View！</p>
<p><strong>Adds a view as a child and make sure it is measured (if necessary) and<br>positioned properly.</strong></p>
<p>感觉不用我再翻译了，作为child添加一个View看来结论就是在这个地方设置了View啊！！！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupChild</span><span class="params">(View child, <span class="keyword">int</span> position, <span class="keyword">int</span> y, <span class="keyword">boolean</span> flowDown, <span class="keyword">int</span> childrenLeft,</span></span></div><div class="line">            <span class="keyword">boolean</span> selected, <span class="keyword">boolean</span> isAttachedToWindow) &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"setupListItem"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isSelected = selected &amp;&amp; shouldShowSelector();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> updateChildSelected = isSelected != child.isSelected();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mode = mTouchMode;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isPressed = mode &gt; TOUCH_MODE_DOWN &amp;&amp; mode &lt; TOUCH_MODE_SCROLL</div><div class="line">                &amp;&amp; mMotionPosition == position;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> updateChildPressed = isPressed != child.isPressed();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needToMeasure = !isAttachedToWindow || updateChildSelected</div><div class="line">                || child.isLayoutRequested();</div><div class="line"></div><div class="line">        <span class="comment">// Respect layout params that are already in the view. Otherwise make</span></div><div class="line">        <span class="comment">// some up...</span></div><div class="line">        AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams();</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">            p = (AbsListView.LayoutParams) generateDefaultLayoutParams();</div><div class="line">        &#125;</div><div class="line">        p.viewType = mAdapter.getItemViewType(position);</div><div class="line">        p.isEnabled = mAdapter.isEnabled(position);</div><div class="line"></div><div class="line">        <span class="comment">// Set up view state before attaching the view, since we may need to</span></div><div class="line">        <span class="comment">// rely on the jumpDrawablesToCurrentState() call that occurs as part</span></div><div class="line">        <span class="comment">// of view attachment.</span></div><div class="line">        <span class="keyword">if</span> (updateChildSelected) &#123;</div><div class="line">            child.setSelected(isSelected);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (updateChildPressed) &#123;</div><div class="line">            child.setPressed(isPressed);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mChoiceMode != CHOICE_MODE_NONE &amp;&amp; mCheckStates != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (child <span class="keyword">instanceof</span> Checkable) &#123;</div><div class="line">                ((Checkable) child).setChecked(mCheckStates.get(position));</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getContext().getApplicationInfo().targetSdkVersion</div><div class="line">                    &gt;= android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">                child.setActivated(mCheckStates.get(position));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((isAttachedToWindow &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter</div><div class="line">                &amp;&amp; p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123;</div><div class="line">            attachViewToParent(child, flowDown ? -<span class="number">1</span> : <span class="number">0</span>, p);</div><div class="line"></div><div class="line">            <span class="comment">// If the view was previously attached for a different position,</span></div><div class="line">            <span class="comment">// then manually jump the drawables.</span></div><div class="line">            <span class="keyword">if</span> (isAttachedToWindow</div><div class="line">                    &amp;&amp; (((AbsListView.LayoutParams) child.getLayoutParams()).scrappedFromPosition)</div><div class="line">                            != position) &#123;</div><div class="line">                child.jumpDrawablesToCurrentState();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            p.forceAdd = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</div><div class="line">                p.recycledHeaderFooter = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            addViewInLayout(child, flowDown ? -<span class="number">1</span> : <span class="number">0</span>, p, <span class="keyword">true</span>);</div><div class="line">            <span class="comment">// add view in layout will reset the RTL properties. We have to re-resolve them</span></div><div class="line">            child.resolveRtlPropertiesIfNeeded();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (needToMeasure) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec,</div><div class="line">                    mListPadding.left + mListPadding.right, p.width);</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> lpHeight = p.height;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeightSpec;</div><div class="line">            <span class="keyword">if</span> (lpHeight &gt; <span class="number">0</span>) &#123;</div><div class="line">                childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                childHeightSpec = MeasureSpec.makeSafeMeasureSpec(getMeasuredHeight(),</div><div class="line">                        MeasureSpec.UNSPECIFIED);</div><div class="line">            &#125;</div><div class="line">            child.measure(childWidthSpec, childHeightSpec);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            cleanupLayoutState(child);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> w = child.getMeasuredWidth();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> h = child.getMeasuredHeight();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childTop = flowDown ? y : y - h;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (needToMeasure) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childRight = childrenLeft + w;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childBottom = childTop + h;</div><div class="line">            child.layout(childrenLeft, childTop, childRight, childBottom);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            child.offsetLeftAndRight(childrenLeft - child.getLeft());</div><div class="line">            child.offsetTopAndBottom(childTop - child.getTop());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mCachingStarted &amp;&amp; !child.isDrawingCacheEnabled()) &#123;</div><div class="line">            child.setDrawingCacheEnabled(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>代码依然很多，但是我们这里只说重点!在第59行出现了一个方法addViewInLayout(child, flowDown ? -1 : 0, p, true);看函数名，就知道了。到目前为止我们的layout上面已经有View了。</p>
<p>咱们的第一次layout终于完毕！</p>
<h2 id="第二次Layout"><a href="#第二次Layout" class="headerlink" title="第二次Layout"></a>第二次Layout</h2><p>即使是一个再简单的View，在展示到界面上之前都会经历至少两次onMeasure()和两次onLayout()的过程。其实这只是一个很小的细节，平时对我们影响并不大，因为不管是onMeasure()或者onLayout()几次，反正都是执行的相同的逻辑，我们并不需要进行过多关心。但是在ListView中情况就不一样了，因为这就意味着layoutChildren()过程会执行两次，而这个过程当中涉及到向ListView中添加子元素，如果相同的逻辑执行两遍的话，那么ListView中就会存在一份重复的数据了。因此ListView在layoutChildren()过程当中做了第二次Layout的逻辑处理，非常巧妙地解决了这个问题，下面我们就来分析一下第二次Layout的过程。</p>
<p>时间直接进入layoutChildren()，因为OnLayout里面几乎什么都没有。<br>第一次和第二次的流程其实差不多，不过具体细节就有所不同了~<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> blockLayoutRequests = mBlockLayoutRequests;</div><div class="line">        <span class="keyword">if</span> (blockLayoutRequests) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mBlockLayoutRequests = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">super</span>.layoutChildren();</div><div class="line"></div><div class="line">            invalidate();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mAdapter == <span class="keyword">null</span>) &#123;</div><div class="line">                resetList();</div><div class="line">                invokeOnItemScrollListener();</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childrenTop = mListPadding.top;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childrenBottom = mBottom - mTop - mListPadding.bottom;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</div><div class="line"></div><div class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> delta = <span class="number">0</span>;</div><div class="line"></div><div class="line">            View sel;</div><div class="line">            View oldSel = <span class="keyword">null</span>;</div><div class="line">            View oldFirst = <span class="keyword">null</span>;</div><div class="line">            View newSel = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">            <span class="comment">// Remember stuff we will need down below</span></div><div class="line">            <span class="keyword">switch</span> (mLayoutMode) &#123;</div><div class="line">            <span class="keyword">case</span> LAYOUT_SET_SELECTION:</div><div class="line">                index = mNextSelectedPosition - mFirstPosition;</div><div class="line">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; childCount) &#123;</div><div class="line">                    newSel = getChildAt(index);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> LAYOUT_FORCE_TOP:</div><div class="line">            <span class="keyword">case</span> LAYOUT_FORCE_BOTTOM:</div><div class="line">            <span class="keyword">case</span> LAYOUT_SPECIFIC:</div><div class="line">            <span class="keyword">case</span> LAYOUT_SYNC:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> LAYOUT_MOVE_SELECTION:</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="comment">// Remember the previously selected view</span></div><div class="line">                index = mSelectedPosition - mFirstPosition;</div><div class="line">                <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; childCount) &#123;</div><div class="line">                    oldSel = getChildAt(index);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Remember the previous first child</span></div><div class="line">                oldFirst = getChildAt(<span class="number">0</span>);</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (mNextSelectedPosition &gt;= <span class="number">0</span>) &#123;</div><div class="line">                    delta = mNextSelectedPosition - mSelectedPosition;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Caution: newSel might be null</span></div><div class="line">                newSel = getChildAt(index + delta);</div><div class="line">            &#125;</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keyword">boolean</span> dataChanged = mDataChanged;</div><div class="line">            <span class="keyword">if</span> (dataChanged) &#123;</div><div class="line">                handleDataChanged();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Handle the empty set by removing all views that are visible</span></div><div class="line">            <span class="comment">// and calling it a day</span></div><div class="line">            <span class="keyword">if</span> (mItemCount == <span class="number">0</span>) &#123;</div><div class="line">                resetList();</div><div class="line">                invokeOnItemScrollListener();</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mItemCount != mAdapter.getCount()) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The content of the adapter has changed but "</span></div><div class="line">                        + <span class="string">"ListView did not receive a notification. Make sure the content of "</span></div><div class="line">                        + <span class="string">"your adapter is not modified from a background thread, but only from "</span></div><div class="line">                        + <span class="string">"the UI thread. Make sure your adapter calls notifyDataSetChanged() "</span></div><div class="line">                        + <span class="string">"when its content changes. [in ListView("</span> + getId() + <span class="string">", "</span> + getClass()</div><div class="line">                        + <span class="string">") with Adapter("</span> + mAdapter.getClass() + <span class="string">")]"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            setSelectedPositionInt(mNextSelectedPosition);</div><div class="line"></div><div class="line">            AccessibilityNodeInfo accessibilityFocusLayoutRestoreNode = <span class="keyword">null</span>;</div><div class="line">            View accessibilityFocusLayoutRestoreView = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">int</span> accessibilityFocusPosition = INVALID_POSITION;</div><div class="line"></div><div class="line">            <span class="comment">// Remember which child, if any, had accessibility focus. This must</span></div><div class="line">            <span class="comment">// occur before recycling any views, since that will clear</span></div><div class="line">            <span class="comment">// accessibility focus.</span></div><div class="line">            <span class="keyword">final</span> ViewRootImpl viewRootImpl = getViewRootImpl();</div><div class="line">            <span class="keyword">if</span> (viewRootImpl != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">final</span> View focusHost = viewRootImpl.getAccessibilityFocusedHost();</div><div class="line">                <span class="keyword">if</span> (focusHost != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">final</span> View focusChild = getAccessibilityFocusedChild(focusHost);</div><div class="line">                    <span class="keyword">if</span> (focusChild != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">if</span> (!dataChanged || isDirectChildHeaderOrFooter(focusChild)</div><div class="line">                                || focusChild.hasTransientState() || mAdapterHasStableIds) &#123;</div><div class="line">                            <span class="comment">// The views won't be changing, so try to maintain</span></div><div class="line">                            <span class="comment">// focus on the current host and virtual view.</span></div><div class="line">                            accessibilityFocusLayoutRestoreView = focusHost;</div><div class="line">                            accessibilityFocusLayoutRestoreNode = viewRootImpl</div><div class="line">                                    .getAccessibilityFocusedVirtualView();</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        <span class="comment">// If all else fails, maintain focus at the same</span></div><div class="line">                        <span class="comment">// position.</span></div><div class="line">                        accessibilityFocusPosition = getPositionForView(focusChild);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            View focusLayoutRestoreDirectChild = <span class="keyword">null</span>;</div><div class="line">            View focusLayoutRestoreView = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">            <span class="comment">// Take focus back to us temporarily to avoid the eventual call to</span></div><div class="line">            <span class="comment">// clear focus when removing the focused child below from messing</span></div><div class="line">            <span class="comment">// things up when ViewAncestor assigns focus back to someone else.</span></div><div class="line">            <span class="keyword">final</span> View focusedChild = getFocusedChild();</div><div class="line">            <span class="keyword">if</span> (focusedChild != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// <span class="doctag">TODO:</span> in some cases focusedChild.getParent() == null</span></div><div class="line"></div><div class="line">                <span class="comment">// We can remember the focused view to restore after re-layout</span></div><div class="line">                <span class="comment">// if the data hasn't changed, or if the focused position is a</span></div><div class="line">                <span class="comment">// header or footer.</span></div><div class="line">                <span class="keyword">if</span> (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)</div><div class="line">                        || focusedChild.hasTransientState() || mAdapterHasStableIds) &#123;</div><div class="line">                    focusLayoutRestoreDirectChild = focusedChild;</div><div class="line">                    <span class="comment">// Remember the specific view that had focus.</span></div><div class="line">                    focusLayoutRestoreView = findFocus();</div><div class="line">                    <span class="keyword">if</span> (focusLayoutRestoreView != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">// Tell it we are going to mess with it.</span></div><div class="line">                        focusLayoutRestoreView.dispatchStartTemporaryDetach();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                requestFocus();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Pull all children into the RecycleBin.</span></div><div class="line">            <span class="comment">// These views will be reused if possible</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> firstPosition = mFirstPosition;</div><div class="line">            <span class="keyword">final</span> RecycleBin recycleBin = mRecycler;</div><div class="line">            <span class="keyword">if</span> (dataChanged) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">                    recycleBin.addScrapView(getChildAt(i), firstPosition+i);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                recycleBin.fillActiveViews(childCount, firstPosition);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Clear out old views</span></div><div class="line">            detachAllViewsFromParent();</div><div class="line">            recycleBin.removeSkippedScrap();</div><div class="line"></div><div class="line">            <span class="keyword">switch</span> (mLayoutMode) &#123;</div><div class="line">            <span class="keyword">case</span> LAYOUT_SET_SELECTION:</div><div class="line">                <span class="keyword">if</span> (newSel != <span class="keyword">null</span>) &#123;</div><div class="line">                    sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    sel = fillFromMiddle(childrenTop, childrenBottom);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> LAYOUT_SYNC:</div><div class="line">                sel = fillSpecific(mSyncPosition, mSpecificTop);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> LAYOUT_FORCE_BOTTOM:</div><div class="line">                sel = fillUp(mItemCount - <span class="number">1</span>, childrenBottom);</div><div class="line">                adjustViewsUpOrDown();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> LAYOUT_FORCE_TOP:</div><div class="line">                mFirstPosition = <span class="number">0</span>;</div><div class="line">                sel = fillFromTop(childrenTop);</div><div class="line">                adjustViewsUpOrDown();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> LAYOUT_SPECIFIC:</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> selectedPosition = reconcileSelectedPosition();</div><div class="line">                sel = fillSpecific(selectedPosition, mSpecificTop);</div><div class="line">                <span class="comment">/**</span></div><div class="line">                 * When ListView is resized, FocusSelector requests an async selection for the</div><div class="line">                 * previously focused item to make sure it is still visible. If the item is not</div><div class="line">                 * selectable, it won't regain focus so instead we call FocusSelector</div><div class="line">                 * to directly request focus on the view after it is visible.</div><div class="line">                 */</div><div class="line">                <span class="keyword">if</span> (sel == <span class="keyword">null</span> &amp;&amp; mFocusSelector != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">final</span> Runnable focusRunnable = mFocusSelector</div><div class="line">                            .setupFocusIfValid(selectedPosition);</div><div class="line">                    <span class="keyword">if</span> (focusRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">                        post(focusRunnable);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> LAYOUT_MOVE_SELECTION:</div><div class="line">                sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">if</span> (childCount == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (!mStackFromBottom) &#123;</div><div class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> position = lookForSelectablePosition(<span class="number">0</span>, <span class="keyword">true</span>);</div><div class="line">                        setSelectedPositionInt(position);</div><div class="line">                        sel = fillFromTop(childrenTop);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> position = lookForSelectablePosition(mItemCount - <span class="number">1</span>, <span class="keyword">false</span>);</div><div class="line">                        setSelectedPositionInt(position);</div><div class="line">                        sel = fillUp(mItemCount - <span class="number">1</span>, childrenBottom);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (mSelectedPosition &gt;= <span class="number">0</span> &amp;&amp; mSelectedPosition &lt; mItemCount) &#123;</div><div class="line">                        sel = fillSpecific(mSelectedPosition,</div><div class="line">                                oldSel == <span class="keyword">null</span> ? childrenTop : oldSel.getTop());</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFirstPosition &lt; mItemCount) &#123;</div><div class="line">                        sel = fillSpecific(mFirstPosition,</div><div class="line">                                oldFirst == <span class="keyword">null</span> ? childrenTop : oldFirst.getTop());</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        sel = fillSpecific(<span class="number">0</span>, childrenTop);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Flush any cached views that did not get reused above</span></div><div class="line">            recycleBin.scrapActiveViews();</div><div class="line"></div><div class="line">            <span class="comment">// remove any header/footer that has been temp detached and not re-attached</span></div><div class="line">            removeUnusedFixedViews(mHeaderViewInfos);</div><div class="line">            removeUnusedFixedViews(mFooterViewInfos);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (sel != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// The current selected item should get focus if items are</span></div><div class="line">                <span class="comment">// focusable.</span></div><div class="line">                <span class="keyword">if</span> (mItemsCanFocus &amp;&amp; hasFocus() &amp;&amp; !sel.hasFocus()) &#123;</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> focusWasTaken = (sel == focusLayoutRestoreDirectChild &amp;&amp;</div><div class="line">                            focusLayoutRestoreView != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                            focusLayoutRestoreView.requestFocus()) || sel.requestFocus();</div><div class="line">                    <span class="keyword">if</span> (!focusWasTaken) &#123;</div><div class="line">                        <span class="comment">// Selected item didn't take focus, but we still want to</span></div><div class="line">                        <span class="comment">// make sure something else outside of the selected view</span></div><div class="line">                        <span class="comment">// has focus.</span></div><div class="line">                        <span class="keyword">final</span> View focused = getFocusedChild();</div><div class="line">                        <span class="keyword">if</span> (focused != <span class="keyword">null</span>) &#123;</div><div class="line">                            focused.clearFocus();</div><div class="line">                        &#125;</div><div class="line">                        positionSelector(INVALID_POSITION, sel);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        sel.setSelected(<span class="keyword">false</span>);</div><div class="line">                        mSelectorRect.setEmpty();</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    positionSelector(INVALID_POSITION, sel);</div><div class="line">                &#125;</div><div class="line">                mSelectedTop = sel.getTop();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> inTouchMode = mTouchMode == TOUCH_MODE_TAP</div><div class="line">                        || mTouchMode == TOUCH_MODE_DONE_WAITING;</div><div class="line">                <span class="keyword">if</span> (inTouchMode) &#123;</div><div class="line">                    <span class="comment">// If the user's finger is down, select the motion position.</span></div><div class="line">                    <span class="keyword">final</span> View child = getChildAt(mMotionPosition - mFirstPosition);</div><div class="line">                    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</div><div class="line">                        positionSelector(mMotionPosition, child);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSelectorPosition != INVALID_POSITION) &#123;</div><div class="line">                    <span class="comment">// If we had previously positioned the selector somewhere,</span></div><div class="line">                    <span class="comment">// put it back there. It might not match up with the data,</span></div><div class="line">                    <span class="comment">// but it's transitioning out so it's not a big deal.</span></div><div class="line">                    <span class="keyword">final</span> View child = getChildAt(mSelectorPosition - mFirstPosition);</div><div class="line">                    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</div><div class="line">                        positionSelector(mSelectorPosition, child);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// Otherwise, clear selection.</span></div><div class="line">                    mSelectedTop = <span class="number">0</span>;</div><div class="line">                    mSelectorRect.setEmpty();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Even if there is not selected position, we may need to</span></div><div class="line">                <span class="comment">// restore focus (i.e. something focusable in touch mode).</span></div><div class="line">                <span class="keyword">if</span> (hasFocus() &amp;&amp; focusLayoutRestoreView != <span class="keyword">null</span>) &#123;</div><div class="line">                    focusLayoutRestoreView.requestFocus();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Attempt to restore accessibility focus, if necessary.</span></div><div class="line">            <span class="keyword">if</span> (viewRootImpl != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">final</span> View newAccessibilityFocusedView = viewRootImpl.getAccessibilityFocusedHost();</div><div class="line">                <span class="keyword">if</span> (newAccessibilityFocusedView == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (accessibilityFocusLayoutRestoreView != <span class="keyword">null</span></div><div class="line">                            &amp;&amp; accessibilityFocusLayoutRestoreView.isAttachedToWindow()) &#123;</div><div class="line">                        <span class="keyword">final</span> AccessibilityNodeProvider provider =</div><div class="line">                                accessibilityFocusLayoutRestoreView.getAccessibilityNodeProvider();</div><div class="line">                        <span class="keyword">if</span> (accessibilityFocusLayoutRestoreNode != <span class="keyword">null</span> &amp;&amp; provider != <span class="keyword">null</span>) &#123;</div><div class="line">                            <span class="keyword">final</span> <span class="keyword">int</span> virtualViewId = AccessibilityNodeInfo.getVirtualDescendantId(</div><div class="line">                                    accessibilityFocusLayoutRestoreNode.getSourceNodeId());</div><div class="line">                            provider.performAction(virtualViewId,</div><div class="line">                                    AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS, <span class="keyword">null</span>);</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            accessibilityFocusLayoutRestoreView.requestAccessibilityFocus();</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (accessibilityFocusPosition != INVALID_POSITION) &#123;</div><div class="line">                        <span class="comment">// Bound the position within the visible children.</span></div><div class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> position = MathUtils.constrain(</div><div class="line">                                accessibilityFocusPosition - mFirstPosition, <span class="number">0</span>,</div><div class="line">                                getChildCount() - <span class="number">1</span>);</div><div class="line">                        <span class="keyword">final</span> View restoreView = getChildAt(position);</div><div class="line">                        <span class="keyword">if</span> (restoreView != <span class="keyword">null</span>) &#123;</div><div class="line">                            restoreView.requestAccessibilityFocus();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Tell focus view we are done mucking with it, if it is still in</span></div><div class="line">            <span class="comment">// our view hierarchy.</span></div><div class="line">            <span class="keyword">if</span> (focusLayoutRestoreView != <span class="keyword">null</span></div><div class="line">                    &amp;&amp; focusLayoutRestoreView.getWindowToken() != <span class="keyword">null</span>) &#123;</div><div class="line">                focusLayoutRestoreView.dispatchFinishTemporaryDetach();</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            mLayoutMode = LAYOUT_NORMAL;</div><div class="line">            mDataChanged = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (mPositionScrollAfterLayout != <span class="keyword">null</span>) &#123;</div><div class="line">                post(mPositionScrollAfterLayout);</div><div class="line">                mPositionScrollAfterLayout = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            mNeedSync = <span class="keyword">false</span>;</div><div class="line">            setNextSelectedPositionInt(mSelectedPosition);</div><div class="line"></div><div class="line">            updateScrollIndicators();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mItemCount &gt; <span class="number">0</span>) &#123;</div><div class="line">                checkSelectionChanged();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            invokeOnItemScrollListener();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (mFocusSelector != <span class="keyword">null</span>) &#123;</div><div class="line">                mFocusSelector.onLayoutComplete();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!blockLayoutRequests) &#123;</div><div class="line">                mBlockLayoutRequests = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>依然是在第22行，调用getChildCount()方法来获取子View的数量，只不过现在得到的值不会再是0了，而是ListView中的View数量，下面在第151行调用了RecycleBin的fillActiveViews()方法，这次效果可就不一样了，因为目前ListView中已经有子View了，这样所有的子View都会被缓存到RecycleBin的mActiveViews数组当中，后面将会使用到他们。</p>
<p>紧接着在第155行执行这个方法detachAllViewsFromParent();要知道这个方法在第一次layout中同样执行了，不过因为当是ListView中没有任何View所以这个方法和没执行一样。但是要知道现在我们屏幕上已经有了View。我们开看看这个方法的作用，这个方法会将所有ListView当中的子View全部清除掉，从而保证第二次Layout过程不会产生一份重复的数据。可能会问了，这样把已经加载好的View又清除掉，待会还要再重新加载一遍，这不是严重影响效率吗？不用担心，还记得我们刚刚调用了RecycleBin的fillActiveViews()方法来缓存子View吗，待会儿将会直接使用这些缓存好的View来进行加载，而并不会重新执行一遍inflate过程，因此效率方面并不会有什么明显的影响。</p>
<p>接下拉到了199行，现在我们的childCount 已经不是0，所以我们进入else的逻辑里面，执行fillSpecific（）方法<br>注释：<br><strong>Put a specific item at a specific location on the screen and then build<br>up and down from there.</strong><br>放置一个指定item在屏幕上的指定位置，然后从这个位置的上下开始构建其他的view.</p>
<p>接下来会进入到我们熟悉的fillDown（）中，然后会进入makeAndAddView（），不过这次我们来看一下，具体逻辑是什么样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> View <span class="title">makeAndAddView</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span> y, <span class="keyword">boolean</span> flow, <span class="keyword">int</span> childrenLeft,</span></span></div><div class="line">            <span class="keyword">boolean</span> selected) &#123;</div><div class="line">        <span class="keyword">if</span> (!mDataChanged) &#123;</div><div class="line">            <span class="comment">// Try to use an existing view for this position.</span></div><div class="line">            <span class="keyword">final</span> View activeView = mRecycler.getActiveView(position);</div><div class="line">            <span class="keyword">if</span> (activeView != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Found it. We're reusing an existing child, so it just needs</span></div><div class="line">                <span class="comment">// to be positioned like a scrap view.</span></div><div class="line">                setupChild(activeView, position, y, flow, childrenLeft, selected, <span class="keyword">true</span>);</div><div class="line">                <span class="keyword">return</span> activeView;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Make a new view for this position, or convert an unused view if</span></div><div class="line">        <span class="comment">// possible.</span></div><div class="line">        <span class="keyword">final</span> View child = obtainView(position, mIsScrap);</div><div class="line"></div><div class="line">        <span class="comment">// This needs to be positioned and measured.</span></div><div class="line">        setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[<span class="number">0</span>]);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> child;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在第5行中我们会尝试着回去一个ActiveView，当然我们现在是可以获取到的，我们不会向下走到16行，而是直接走setupChild(activeView, position, y, flow, childrenLeft, selected, true)方法中，这里注意了，最后一个元素是true，这个参数表明当前的View是之前被回收过的，我们进入这个方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupChild</span><span class="params">(View child, <span class="keyword">int</span> position, <span class="keyword">int</span> y, <span class="keyword">boolean</span> flowDown, <span class="keyword">int</span> childrenLeft,</span></span></div><div class="line">            <span class="keyword">boolean</span> selected, <span class="keyword">boolean</span> isAttachedToWindow) &#123;</div><div class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"setupListItem"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isSelected = selected &amp;&amp; shouldShowSelector();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> updateChildSelected = isSelected != child.isSelected();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mode = mTouchMode;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isPressed = mode &gt; TOUCH_MODE_DOWN &amp;&amp; mode &lt; TOUCH_MODE_SCROLL</div><div class="line">                &amp;&amp; mMotionPosition == position;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> updateChildPressed = isPressed != child.isPressed();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needToMeasure = !isAttachedToWindow || updateChildSelected</div><div class="line">                || child.isLayoutRequested();</div><div class="line"></div><div class="line">        <span class="comment">// Respect layout params that are already in the view. Otherwise make</span></div><div class="line">        <span class="comment">// some up...</span></div><div class="line">        AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams();</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">            p = (AbsListView.LayoutParams) generateDefaultLayoutParams();</div><div class="line">        &#125;</div><div class="line">        p.viewType = mAdapter.getItemViewType(position);</div><div class="line">        p.isEnabled = mAdapter.isEnabled(position);</div><div class="line"></div><div class="line">        <span class="comment">// Set up view state before attaching the view, since we may need to</span></div><div class="line">        <span class="comment">// rely on the jumpDrawablesToCurrentState() call that occurs as part</span></div><div class="line">        <span class="comment">// of view attachment.</span></div><div class="line">        <span class="keyword">if</span> (updateChildSelected) &#123;</div><div class="line">            child.setSelected(isSelected);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (updateChildPressed) &#123;</div><div class="line">            child.setPressed(isPressed);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mChoiceMode != CHOICE_MODE_NONE &amp;&amp; mCheckStates != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (child <span class="keyword">instanceof</span> Checkable) &#123;</div><div class="line">                ((Checkable) child).setChecked(mCheckStates.get(position));</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getContext().getApplicationInfo().targetSdkVersion</div><div class="line">                    &gt;= android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">                child.setActivated(mCheckStates.get(position));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((isAttachedToWindow &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter</div><div class="line">                &amp;&amp; p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123;</div><div class="line">            attachViewToParent(child, flowDown ? -<span class="number">1</span> : <span class="number">0</span>, p);</div><div class="line"></div><div class="line">            <span class="comment">// If the view was previously attached for a different position,</span></div><div class="line">            <span class="comment">// then manually jump the drawables.</span></div><div class="line">            <span class="keyword">if</span> (isAttachedToWindow</div><div class="line">                    &amp;&amp; (((AbsListView.LayoutParams) child.getLayoutParams()).scrappedFromPosition)</div><div class="line">                            != position) &#123;</div><div class="line">                child.jumpDrawablesToCurrentState();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            p.forceAdd = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">if</span> (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</div><div class="line">                p.recycledHeaderFooter = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            addViewInLayout(child, flowDown ? -<span class="number">1</span> : <span class="number">0</span>, p, <span class="keyword">true</span>);</div><div class="line">            <span class="comment">// add view in layout will reset the RTL properties. We have to re-resolve them</span></div><div class="line">            child.resolveRtlPropertiesIfNeeded();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (needToMeasure) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec,</div><div class="line">                    mListPadding.left + mListPadding.right, p.width);</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> lpHeight = p.height;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeightSpec;</div><div class="line">            <span class="keyword">if</span> (lpHeight &gt; <span class="number">0</span>) &#123;</div><div class="line">                childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                childHeightSpec = MeasureSpec.makeSafeMeasureSpec(getMeasuredHeight(),</div><div class="line">                        MeasureSpec.UNSPECIFIED);</div><div class="line">            &#125;</div><div class="line">            child.measure(childWidthSpec, childHeightSpec);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            cleanupLayoutState(child);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> w = child.getMeasuredWidth();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> h = child.getMeasuredHeight();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childTop = flowDown ? y : y - h;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (needToMeasure) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childRight = childrenLeft + w;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childBottom = childTop + h;</div><div class="line">            child.layout(childrenLeft, childTop, childRight, childBottom);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            child.offsetLeftAndRight(childrenLeft - child.getLeft());</div><div class="line">            child.offsetTopAndBottom(childTop - child.getTop());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mCachingStarted &amp;&amp; !child.isDrawingCacheEnabled()) &#123;</div><div class="line">            child.setDrawingCacheEnabled(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们会在第45行调用attachViewToParent(child, flowDown ? -1 : 0, p)，在第一次Layout过程则是执行的else语句中的addViewInLayout()方法。这两个方法最大的区别在于，如果我们需要向ViewGroup中添加一个新的子View，应该调用addViewInLayout()方法，而如果是想要将一个之前detach的View重新attach到ViewGroup上，就应该调用attachViewToParent()方法。那么由于前面在layoutChildren()方法当中调用了detachAllViewsFromParent()方法，这样ListView中所有的子View都是处于detach状态的，所以这里attachViewToParent()方法是正确的选择。</p>
<p>经历了这样一个detach又attach的过程，ListView中所有的子View又都可以正常显示出来了，那么第二次Layout过程结束。</p>
<h2 id="滑动加载更多数据"><a href="#滑动加载更多数据" class="headerlink" title="滑动加载更多数据"></a>滑动加载更多数据</h2><p>到目前只还只加载了一小部分数据，如果要加载100条，那么剩余的应该怎么去加载呢？毫无疑问动态的去加载，那么接下来我们要看的就是onTouchEvent（）方法中的，这个onTouchEvent方法在ListView找不到，那么只会在AbsListView中了。仔细思考一下也对，对于ListView还是GridView来说，最终机制都是查不了多少的，真正不同的也就放置在子View的位置不同，他们的更新数据都是滑动更新，故抽象提取出来了。</p>
<p>这个方法依然不短，同时也没有注释，到这个时候，只有发挥自己已经学过的知识了。触摸一般分为三种，按下、滑动、抬起，短暂思考，最重要无疑是重点，所以我们主要看move操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!isEnabled()) &#123;</div><div class="line">            <span class="comment">// A disabled view that is clickable still consumes the touch</span></div><div class="line">            <span class="comment">// events, it just doesn't respond to them.</span></div><div class="line">            <span class="keyword">return</span> isClickable() || isLongClickable();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mPositionScroller != <span class="keyword">null</span>) &#123;</div><div class="line">            mPositionScroller.stop();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mIsDetaching || !isAttachedToWindow()) &#123;</div><div class="line">            <span class="comment">// Something isn't right.</span></div><div class="line">            <span class="comment">// Since we rely on being attached to get data set change notifications,</span></div><div class="line">            <span class="comment">// don't risk doing anything where we might try to resync and find things</span></div><div class="line">            <span class="comment">// in a bogus state.</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        startNestedScroll(SCROLL_AXIS_VERTICAL);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mFastScroll != <span class="keyword">null</span> &amp;&amp; mFastScroll.onTouchEvent(ev)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        initVelocityTrackerIfNotExists();</div><div class="line">        <span class="keyword">final</span> MotionEvent vtev = MotionEvent.obtain(ev);</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = ev.getActionMasked();</div><div class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">            mNestedYOffset = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        vtev.offsetLocation(<span class="number">0</span>, mNestedYOffset);</div><div class="line">        <span class="keyword">switch</span> (actionMasked) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</div><div class="line">                onTouchDown(ev);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</div><div class="line">                onTouchMove(ev, vtev);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</div><div class="line">                onTouchUp(ev);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL: &#123;</div><div class="line">                onTouchCancel();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_POINTER_UP: &#123;</div><div class="line">                onSecondaryPointerUp(ev);</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> x = mMotionX;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> y = mMotionY;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> motionPosition = pointToPosition(x, y);</div><div class="line">                <span class="keyword">if</span> (motionPosition &gt;= <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// Remember where the motion event started</span></div><div class="line">                    <span class="keyword">final</span> View child = getChildAt(motionPosition - mFirstPosition);</div><div class="line">                    mMotionViewOriginalTop = child.getTop();</div><div class="line">                    mMotionPosition = motionPosition;</div><div class="line">                &#125;</div><div class="line">                mLastY = y;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_POINTER_DOWN: &#123;</div><div class="line">                <span class="comment">// New pointers take over dragging duties</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = ev.getActionIndex();</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> id = ev.getPointerId(index);</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX(index);</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY(index);</div><div class="line">                mMotionCorrection = <span class="number">0</span>;</div><div class="line">                mActivePointerId = id;</div><div class="line">                mMotionX = x;</div><div class="line">                mMotionY = y;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> motionPosition = pointToPosition(x, y);</div><div class="line">                <span class="keyword">if</span> (motionPosition &gt;= <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// Remember where the motion event started</span></div><div class="line">                    <span class="keyword">final</span> View child = getChildAt(motionPosition - mFirstPosition);</div><div class="line">                    mMotionViewOriginalTop = child.getTop();</div><div class="line">                    mMotionPosition = motionPosition;</div><div class="line">                &#125;</div><div class="line">                mLastY = y;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mVelocityTracker != <span class="keyword">null</span>) &#123;</div><div class="line">            mVelocityTracker.addMovement(vtev);</div><div class="line">        &#125;</div><div class="line">        vtev.recycle();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>我们会发现mov操作中里面直接调用了onTouchMove这个方法，我们进去看一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onTouchMove</span><span class="params">(MotionEvent ev, MotionEvent vtev)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mHasPerformedLongPress) &#123;</div><div class="line">            <span class="comment">// Consume all move events following a successful long press.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> pointerIndex = ev.findPointerIndex(mActivePointerId);</div><div class="line">        <span class="keyword">if</span> (pointerIndex == -<span class="number">1</span>) &#123;</div><div class="line">            pointerIndex = <span class="number">0</span>;</div><div class="line">            mActivePointerId = ev.getPointerId(pointerIndex);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mDataChanged) &#123;</div><div class="line">            <span class="comment">// Re-sync everything if data has been changed</span></div><div class="line">            <span class="comment">// since the scroll operation can query the adapter.</span></div><div class="line">            layoutChildren();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY(pointerIndex);</div><div class="line"></div><div class="line">        <span class="keyword">switch</span> (mTouchMode) &#123;</div><div class="line">            <span class="keyword">case</span> TOUCH_MODE_DOWN:</div><div class="line">            <span class="keyword">case</span> TOUCH_MODE_TAP:</div><div class="line">            <span class="keyword">case</span> TOUCH_MODE_DONE_WAITING:</div><div class="line">                <span class="comment">// Check if we have moved far enough that it looks more like a</span></div><div class="line">                <span class="comment">// scroll than a tap. If so, we'll enter scrolling mode.</span></div><div class="line">                <span class="keyword">if</span> (startScrollIfNeeded((<span class="keyword">int</span>) ev.getX(pointerIndex), y, vtev)) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// Otherwise, check containment within list bounds. If we're</span></div><div class="line">                <span class="comment">// outside bounds, cancel any active presses.</span></div><div class="line">                <span class="keyword">final</span> View motionView = getChildAt(mMotionPosition - mFirstPosition);</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(pointerIndex);</div><div class="line">                <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</div><div class="line">                    setPressed(<span class="keyword">false</span>);</div><div class="line">                    <span class="keyword">if</span> (motionView != <span class="keyword">null</span>) &#123;</div><div class="line">                        motionView.setPressed(<span class="keyword">false</span>);</div><div class="line">                    &#125;</div><div class="line">                    removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ?</div><div class="line">                            mPendingCheckForTap : mPendingCheckForLongPress);</div><div class="line">                    mTouchMode = TOUCH_MODE_DONE_WAITING;</div><div class="line">                    updateSelectorState();</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (motionView != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// Still within bounds, update the hotspot.</span></div><div class="line">                    <span class="keyword">final</span> <span class="keyword">float</span>[] point = mTmpPoint;</div><div class="line">                    point[<span class="number">0</span>] = x;</div><div class="line">                    point[<span class="number">1</span>] = y;</div><div class="line">                    transformPointToViewLocal(point, motionView);</div><div class="line">                    motionView.drawableHotspotChanged(point[<span class="number">0</span>], point[<span class="number">1</span>]);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> TOUCH_MODE_SCROLL:</div><div class="line">            <span class="keyword">case</span> TOUCH_MODE_OVERSCROLL:</div><div class="line">                scrollIfNeeded((<span class="keyword">int</span>) ev.getX(pointerIndex), y, vtev);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><em>到目前为止我看的是最新的Android7.0的源码，里面很大一部分结构已经被改变，正如题目所说我是跟着郭大神的文档走的，看来到这里只能靠自己的能力了。</em></p>
<p>可以看到，这个方法里面有了一个switch语句，是根据当前的TouchMode来选择的。我看在第52行，看到一个TOUCH_MODE_SCROLL这样的一个模式，我们跟踪进入到它下面的scrollIfNeeded((int) ev.getX(pointerIndex), y, vtev)这个方法中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scrollIfNeeded</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, MotionEvent vtev)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rawDeltaY = y - mMotionY;</div><div class="line">        <span class="keyword">int</span> scrollOffsetCorrection = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> scrollConsumedCorrection = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (mLastY == Integer.MIN_VALUE) &#123;</div><div class="line">            rawDeltaY -= mMotionCorrection;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (dispatchNestedPreScroll(<span class="number">0</span>, mLastY != Integer.MIN_VALUE ? mLastY - y : -rawDeltaY,</div><div class="line">                mScrollConsumed, mScrollOffset)) &#123;</div><div class="line">            rawDeltaY += mScrollConsumed[<span class="number">1</span>];</div><div class="line">            scrollOffsetCorrection = -mScrollOffset[<span class="number">1</span>];</div><div class="line">            scrollConsumedCorrection = mScrollConsumed[<span class="number">1</span>];</div><div class="line">            <span class="keyword">if</span> (vtev != <span class="keyword">null</span>) &#123;</div><div class="line">                vtev.offsetLocation(<span class="number">0</span>, mScrollOffset[<span class="number">1</span>]);</div><div class="line">                mNestedYOffset += mScrollOffset[<span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> deltaY = rawDeltaY;</div><div class="line">        <span class="keyword">int</span> incrementalDeltaY =</div><div class="line">                mLastY != Integer.MIN_VALUE ? y - mLastY + scrollConsumedCorrection : deltaY;</div><div class="line">        <span class="keyword">int</span> lastYCorrection = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mTouchMode == TOUCH_MODE_SCROLL) &#123;</div><div class="line">            <span class="keyword">if</span> (PROFILE_SCROLLING) &#123;</div><div class="line">                <span class="keyword">if</span> (!mScrollProfilingStarted) &#123;</div><div class="line">                    Debug.startMethodTracing(<span class="string">"AbsListViewScroll"</span>);</div><div class="line">                    mScrollProfilingStarted = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mScrollStrictSpan == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// If it's non-null, we're already in a scroll.</span></div><div class="line">                mScrollStrictSpan = StrictMode.enterCriticalSpan(<span class="string">"AbsListView-scroll"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (y != mLastY) &#123;</div><div class="line">                <span class="comment">// We may be here after stopping a fling and continuing to scroll.</span></div><div class="line">                <span class="comment">// If so, we haven't disallowed intercepting touch events yet.</span></div><div class="line">                <span class="comment">// Make sure that we do so in case we're in a parent that can intercept.</span></div><div class="line">                <span class="keyword">if</span> ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) == <span class="number">0</span> &amp;&amp;</div><div class="line">                        Math.abs(rawDeltaY) &gt; mTouchSlop) &#123;</div><div class="line">                    <span class="keyword">final</span> ViewParent parent = getParent();</div><div class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">                        parent.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> motionIndex;</div><div class="line">                <span class="keyword">if</span> (mMotionPosition &gt;= <span class="number">0</span>) &#123;</div><div class="line">                    motionIndex = mMotionPosition - mFirstPosition;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// If we don't have a motion position that we can reliably track,</span></div><div class="line">                    <span class="comment">// pick something in the middle to make a best guess at things below.</span></div><div class="line">                    motionIndex = getChildCount() / <span class="number">2</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">int</span> motionViewPrevTop = <span class="number">0</span>;</div><div class="line">                View motionView = <span class="keyword">this</span>.getChildAt(motionIndex);</div><div class="line">                <span class="keyword">if</span> (motionView != <span class="keyword">null</span>) &#123;</div><div class="line">                    motionViewPrevTop = motionView.getTop();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// No need to do all this work if we're not going to move anyway</span></div><div class="line">                <span class="keyword">boolean</span> atEdge = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">if</span> (incrementalDeltaY != <span class="number">0</span>) &#123;</div><div class="line">                    atEdge = trackMotionScroll(deltaY, incrementalDeltaY);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Check to see if we have bumped into the scroll limit</span></div><div class="line">                motionView = <span class="keyword">this</span>.getChildAt(motionIndex);</div><div class="line">                <span class="keyword">if</span> (motionView != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// Check if the top of the motion view is where it is</span></div><div class="line">                    <span class="comment">// supposed to be</span></div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> motionViewRealTop = motionView.getTop();</div><div class="line">                    <span class="keyword">if</span> (atEdge) &#123;</div><div class="line">                        <span class="comment">// Apply overscroll</span></div><div class="line"></div><div class="line">                        <span class="keyword">int</span> overscroll = -incrementalDeltaY -</div><div class="line">                                (motionViewRealTop - motionViewPrevTop);</div><div class="line">                        <span class="keyword">if</span> (dispatchNestedScroll(<span class="number">0</span>, overscroll - incrementalDeltaY, <span class="number">0</span>, overscroll,</div><div class="line">                                mScrollOffset)) &#123;</div><div class="line">                            lastYCorrection -= mScrollOffset[<span class="number">1</span>];</div><div class="line">                            <span class="keyword">if</span> (vtev != <span class="keyword">null</span>) &#123;</div><div class="line">                                vtev.offsetLocation(<span class="number">0</span>, mScrollOffset[<span class="number">1</span>]);</div><div class="line">                                mNestedYOffset += mScrollOffset[<span class="number">1</span>];</div><div class="line">                            &#125;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">final</span> <span class="keyword">boolean</span> atOverscrollEdge = overScrollBy(<span class="number">0</span>, overscroll,</div><div class="line">                                    <span class="number">0</span>, mScrollY, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, mOverscrollDistance, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">                            <span class="keyword">if</span> (atOverscrollEdge &amp;&amp; mVelocityTracker != <span class="keyword">null</span>) &#123;</div><div class="line">                                <span class="comment">// Don't allow overfling if we're at the edge</span></div><div class="line">                                mVelocityTracker.clear();</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            <span class="keyword">final</span> <span class="keyword">int</span> overscrollMode = getOverScrollMode();</div><div class="line">                            <span class="keyword">if</span> (overscrollMode == OVER_SCROLL_ALWAYS ||</div><div class="line">                                    (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS &amp;&amp;</div><div class="line">                                            !contentFits())) &#123;</div><div class="line">                                <span class="keyword">if</span> (!atOverscrollEdge) &#123;</div><div class="line">                                    mDirection = <span class="number">0</span>; <span class="comment">// Reset when entering overscroll.</span></div><div class="line">                                    mTouchMode = TOUCH_MODE_OVERSCROLL;</div><div class="line">                                &#125;</div><div class="line">                                <span class="keyword">if</span> (incrementalDeltaY &gt; <span class="number">0</span>) &#123;</div><div class="line">                                    mEdgeGlowTop.onPull((<span class="keyword">float</span>) -overscroll / getHeight(),</div><div class="line">                                            (<span class="keyword">float</span>) x / getWidth());</div><div class="line">                                    <span class="keyword">if</span> (!mEdgeGlowBottom.isFinished()) &#123;</div><div class="line">                                        mEdgeGlowBottom.onRelease();</div><div class="line">                                    &#125;</div><div class="line">                                    invalidateTopGlow();</div><div class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (incrementalDeltaY &lt; <span class="number">0</span>) &#123;</div><div class="line">                                    mEdgeGlowBottom.onPull((<span class="keyword">float</span>) overscroll / getHeight(),</div><div class="line">                                            <span class="number">1</span>.f - (<span class="keyword">float</span>) x / getWidth());</div><div class="line">                                    <span class="keyword">if</span> (!mEdgeGlowTop.isFinished()) &#123;</div><div class="line">                                        mEdgeGlowTop.onRelease();</div><div class="line">                                    &#125;</div><div class="line">                                    invalidateBottomGlow();</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    mMotionY = y + lastYCorrection + scrollOffsetCorrection;</div><div class="line">                &#125;</div><div class="line">                mLastY = y + lastYCorrection + scrollOffsetCorrection;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mTouchMode == TOUCH_MODE_OVERSCROLL) &#123;</div><div class="line">            <span class="keyword">if</span> (y != mLastY) &#123;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> oldScroll = mScrollY;</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> newScroll = oldScroll - incrementalDeltaY;</div><div class="line">                <span class="keyword">int</span> newDirection = y &gt; mLastY ? <span class="number">1</span> : -<span class="number">1</span>;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (mDirection == <span class="number">0</span>) &#123;</div><div class="line">                    mDirection = newDirection;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">int</span> overScrollDistance = -incrementalDeltaY;</div><div class="line">                <span class="keyword">if</span> ((newScroll &lt; <span class="number">0</span> &amp;&amp; oldScroll &gt;= <span class="number">0</span>) || (newScroll &gt; <span class="number">0</span> &amp;&amp; oldScroll &lt;= <span class="number">0</span>)) &#123;</div><div class="line">                    overScrollDistance = -oldScroll;</div><div class="line">                    incrementalDeltaY += overScrollDistance;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    incrementalDeltaY = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (overScrollDistance != <span class="number">0</span>) &#123;</div><div class="line">                    overScrollBy(<span class="number">0</span>, overScrollDistance, <span class="number">0</span>, mScrollY, <span class="number">0</span>, <span class="number">0</span>,</div><div class="line">                            <span class="number">0</span>, mOverscrollDistance, <span class="keyword">true</span>);</div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> overscrollMode = getOverScrollMode();</div><div class="line">                    <span class="keyword">if</span> (overscrollMode == OVER_SCROLL_ALWAYS ||</div><div class="line">                            (overscrollMode == OVER_SCROLL_IF_CONTENT_SCROLLS &amp;&amp;</div><div class="line">                                    !contentFits())) &#123;</div><div class="line">                        <span class="keyword">if</span> (rawDeltaY &gt; <span class="number">0</span>) &#123;</div><div class="line">                            mEdgeGlowTop.onPull((<span class="keyword">float</span>) overScrollDistance / getHeight(),</div><div class="line">                                    (<span class="keyword">float</span>) x / getWidth());</div><div class="line">                            <span class="keyword">if</span> (!mEdgeGlowBottom.isFinished()) &#123;</div><div class="line">                                mEdgeGlowBottom.onRelease();</div><div class="line">                            &#125;</div><div class="line">                            invalidateTopGlow();</div><div class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawDeltaY &lt; <span class="number">0</span>) &#123;</div><div class="line">                            mEdgeGlowBottom.onPull((<span class="keyword">float</span>) overScrollDistance / getHeight(),</div><div class="line">                                    <span class="number">1</span>.f - (<span class="keyword">float</span>) x / getWidth());</div><div class="line">                            <span class="keyword">if</span> (!mEdgeGlowTop.isFinished()) &#123;</div><div class="line">                                mEdgeGlowTop.onRelease();</div><div class="line">                            &#125;</div><div class="line">                            invalidateBottomGlow();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (incrementalDeltaY != <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// Coming back to 'real' list scrolling</span></div><div class="line">                    <span class="keyword">if</span> (mScrollY != <span class="number">0</span>) &#123;</div><div class="line">                        mScrollY = <span class="number">0</span>;</div><div class="line">                        invalidateParentIfNeeded();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    trackMotionScroll(incrementalDeltaY, incrementalDeltaY);</div><div class="line"></div><div class="line">                    mTouchMode = TOUCH_MODE_SCROLL;</div><div class="line"></div><div class="line">                    <span class="comment">// We did not scroll the full amount. Treat this essentially like the</span></div><div class="line">                    <span class="comment">// start of a new touch scroll</span></div><div class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> motionPosition = findClosestMotionRow(y);</div><div class="line"></div><div class="line">                    mMotionCorrection = <span class="number">0</span>;</div><div class="line">                    View motionView = getChildAt(motionPosition - mFirstPosition);</div><div class="line">                    mMotionViewOriginalTop = motionView != <span class="keyword">null</span> ? motionView.getTop() : <span class="number">0</span>;</div><div class="line">                    mMotionY =  y + scrollOffsetCorrection;</div><div class="line">                    mMotionPosition = motionPosition;</div><div class="line">                &#125;</div><div class="line">                mLastY = y + lastYCorrection + scrollOffsetCorrection;</div><div class="line">                mDirection = newDirection;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>代码依然不短，我们往里面看在66行处发现trackMotionScroll(deltaY, incrementalDeltaY)，好吧我们找回了正轨~。名字的意思是跟踪滑动轨迹，我们进去感受一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">trackMotionScroll</span><span class="params">(<span class="keyword">int</span> deltaY, <span class="keyword">int</span> incrementalDeltaY)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</div><div class="line">        <span class="keyword">if</span> (childCount == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> firstTop = getChildAt(<span class="number">0</span>).getTop();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> lastBottom = getChildAt(childCount - <span class="number">1</span>).getBottom();</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Rect listPadding = mListPadding;</div><div class="line"></div><div class="line">        <span class="comment">// "effective padding" In this case is the amount of padding that affects</span></div><div class="line">        <span class="comment">// how much space should not be filled by items. If we don't clip to padding</span></div><div class="line">        <span class="comment">// there is no effective padding.</span></div><div class="line">        <span class="keyword">int</span> effectivePaddingTop = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> effectivePaddingBottom = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">            effectivePaddingTop = listPadding.top;</div><div class="line">            effectivePaddingBottom = listPadding.bottom;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">         <span class="comment">// FIXME account for grid vertical spacing too?</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> spaceAbove = effectivePaddingTop - firstTop;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> end = getHeight() - effectivePaddingBottom;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> spaceBelow = lastBottom - end;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> height = getHeight() - mPaddingBottom - mPaddingTop;</div><div class="line">        <span class="keyword">if</span> (deltaY &lt; <span class="number">0</span>) &#123;</div><div class="line">            deltaY = Math.max(-(height - <span class="number">1</span>), deltaY);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            deltaY = Math.min(height - <span class="number">1</span>, deltaY);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (incrementalDeltaY &lt; <span class="number">0</span>) &#123;</div><div class="line">            incrementalDeltaY = Math.max(-(height - <span class="number">1</span>), incrementalDeltaY);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            incrementalDeltaY = Math.min(height - <span class="number">1</span>, incrementalDeltaY);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> firstPosition = mFirstPosition;</div><div class="line"></div><div class="line">        <span class="comment">// Update our guesses for where the first and last views are</span></div><div class="line">        <span class="keyword">if</span> (firstPosition == <span class="number">0</span>) &#123;</div><div class="line">            mFirstPositionDistanceGuess = firstTop - listPadding.top;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mFirstPositionDistanceGuess += incrementalDeltaY;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (firstPosition + childCount == mItemCount) &#123;</div><div class="line">            mLastPositionDistanceGuess = lastBottom + listPadding.bottom;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mLastPositionDistanceGuess += incrementalDeltaY;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> cannotScrollDown = (firstPosition == <span class="number">0</span> &amp;&amp;</div><div class="line">                firstTop &gt;= listPadding.top &amp;&amp; incrementalDeltaY &gt;= <span class="number">0</span>);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> cannotScrollUp = (firstPosition + childCount == mItemCount &amp;&amp;</div><div class="line">                lastBottom &lt;= getHeight() - listPadding.bottom &amp;&amp; incrementalDeltaY &lt;= <span class="number">0</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (cannotScrollDown || cannotScrollUp) &#123;</div><div class="line">            <span class="keyword">return</span> incrementalDeltaY != <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> down = incrementalDeltaY &lt; <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> inTouchMode = isInTouchMode();</div><div class="line">        <span class="keyword">if</span> (inTouchMode) &#123;</div><div class="line">            hideSelector();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> headerViewsCount = getHeaderViewsCount();</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> footerViewsStart = mItemCount - getFooterViewsCount();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (down) &#123;</div><div class="line">            <span class="keyword">int</span> top = -incrementalDeltaY;</div><div class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">                top += listPadding.top;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</div><div class="line">                <span class="keyword">final</span> View child = getChildAt(i);</div><div class="line">                <span class="keyword">if</span> (child.getBottom() &gt;= top) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    count++;</div><div class="line">                    <span class="keyword">int</span> position = firstPosition + i;</div><div class="line">                    <span class="keyword">if</span> (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) &#123;</div><div class="line">                        <span class="comment">// The view will be rebound to new data, clear any</span></div><div class="line">                        <span class="comment">// system-managed transient state.</span></div><div class="line">                        child.clearAccessibilityFocus();</div><div class="line">                        mRecycler.addScrapView(child, position);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> bottom = getHeight() - incrementalDeltaY;</div><div class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">                bottom -= listPadding.bottom;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = childCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                <span class="keyword">final</span> View child = getChildAt(i);</div><div class="line">                <span class="keyword">if</span> (child.getTop() &lt;= bottom) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    start = i;</div><div class="line">                    count++;</div><div class="line">                    <span class="keyword">int</span> position = firstPosition + i;</div><div class="line">                    <span class="keyword">if</span> (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) &#123;</div><div class="line">                        <span class="comment">// The view will be rebound to new data, clear any</span></div><div class="line">                        <span class="comment">// system-managed transient state.</span></div><div class="line">                        child.clearAccessibilityFocus();</div><div class="line">                        mRecycler.addScrapView(child, position);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mMotionViewNewTop = mMotionViewOriginalTop + deltaY;</div><div class="line"></div><div class="line">        mBlockLayoutRequests = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">            detachViewsFromParent(start, count);</div><div class="line">            mRecycler.removeSkippedScrap();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// invalidate before moving the children to avoid unnecessary invalidate</span></div><div class="line">        <span class="comment">// calls to bubble up from the children all the way to the top</span></div><div class="line">        <span class="keyword">if</span> (!awakenScrollBars()) &#123;</div><div class="line">           invalidate();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        offsetChildrenTopAndBottom(incrementalDeltaY);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (down) &#123;</div><div class="line">            mFirstPosition += count;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> absIncrementalDeltaY = Math.abs(incrementalDeltaY);</div><div class="line">        <span class="keyword">if</span> (spaceAbove &lt; absIncrementalDeltaY || spaceBelow &lt; absIncrementalDeltaY) &#123;</div><div class="line">            fillGap(down);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mRecycler.fullyDetachScrapViews();</div><div class="line">        <span class="keyword">if</span> (!inTouchMode &amp;&amp; mSelectedPosition != INVALID_POSITION) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childIndex = mSelectedPosition - mFirstPosition;</div><div class="line">            <span class="keyword">if</span> (childIndex &gt;= <span class="number">0</span> &amp;&amp; childIndex &lt; getChildCount()) &#123;</div><div class="line">                positionSelector(mSelectedPosition, getChildAt(childIndex));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSelectorPosition != INVALID_POSITION) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childIndex = mSelectorPosition - mFirstPosition;</div><div class="line">            <span class="keyword">if</span> (childIndex &gt;= <span class="number">0</span> &amp;&amp; childIndex &lt; getChildCount()) &#123;</div><div class="line">                positionSelector(INVALID_POSITION, getChildAt(childIndex));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mSelectorRect.setEmpty();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mBlockLayoutRequests = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        invokeOnItemScrollListener();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个方法接收两个参数，deltaY表示从手指按下时的位置到当前手指位置的距离，incrementalDeltaY则表示据上次触发event事件手指在Y方向上位置的改变量，那么其实我们就可以通过incrementalDeltaY的正负值情况来判断用户是向上还是向下滑动的了。如第34行代码所示，如果incrementalDeltaY小于0，说明是向下滑动，否则就是向上滑动。</p>
<p>下面将会进行一个边界值检测的过程，可以看到，从第76行开始，当ListView向下滑动的时候，就会进入一个for循环当中，从上往下依次获取子View，第47行当中，如果该子View的bottom值已经小于top值了，就说明这个子View已经移出屏幕了，所以会调用RecycleBin的addScrapView()方法将这个View加入到废弃缓存当中，并将count计数器加1，计数器用于记录有多少个子View被移出了屏幕。那么如果是ListView向上滑动的话，其实过程是基本相同的，只不过变成了从下往上依次获取子View，然后判断该子View的top值是不是大于bottom值了，如果大于的话说明子View已经移出了屏幕，同样把它加入到废弃缓存中，并将计数器加1。<br>紧接着当着判断结束之后再134行会有offsetChildrenTopAndBottom(incrementalDeltaY)，并将incrementalDeltaY作为参数传入，这个方法的作用是让ListView中所有的子View都按照传入的参数值进行相应的偏移，这样就实现了随着手指的拖动，ListView的内容也会随着滚动的效果。</p>
<p>在第141行最后一个View被移除了屏幕，就会调用fillGap()方法的，那么我们可以认为这个方法就是来加载屏幕外的数据的</p>
<p>fillGap()是一个抽象方法，那么我们马上意识到，它的具体实现肯定是在ListView中完成的了。回到ListView当中，fillGap()方法的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillGap</span><span class="params">(<span class="keyword">boolean</span> down)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</div><div class="line">        <span class="keyword">if</span> (down) &#123;</div><div class="line">            <span class="keyword">int</span> paddingTop = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">                paddingTop = getListPaddingTop();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> startOffset = count &gt; <span class="number">0</span> ? getChildAt(count - <span class="number">1</span>).getBottom() + mDividerHeight :</div><div class="line">                    paddingTop;</div><div class="line">            fillDown(mFirstPosition + count, startOffset);</div><div class="line">            correctTooHigh(getChildCount());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> paddingBottom = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) &#123;</div><div class="line">                paddingBottom = getListPaddingBottom();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> startOffset = count &gt; <span class="number">0</span> ? getChildAt(<span class="number">0</span>).getTop() - mDividerHeight :</div><div class="line">                    getHeight() - paddingBottom;</div><div class="line">            fillUp(mFirstPosition - <span class="number">1</span>, startOffset);</div><div class="line">            correctTooLow(getChildCount());</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>down参数用于表示ListView是向下滑动还是向上滑动的，可以看到，如果是向下滑动的话就会调用fillDown()方法，而如果是向上滑动的话就会调用fillUp()方法。那么这两个方法我们都已经非常熟悉了，内部都是通过一个循环来去对ListView进行填充，所以这两个方法我们就不看了，但是填充ListView会通过调用makeAndAddView()方法来完成，又是makeAndAddView()方法，但这次的逻辑再次不同了，所以我们还是回到这个方法瞧一瞧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> View <span class="title">makeAndAddView</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">int</span> y, <span class="keyword">boolean</span> flow, <span class="keyword">int</span> childrenLeft,  </span></span></div><div class="line">        <span class="keyword">boolean</span> selected) &#123;  </div><div class="line">    View child;  </div><div class="line">    <span class="keyword">if</span> (!mDataChanged) &#123;  </div><div class="line">        <span class="comment">// Try to use an exsiting view for this position  </span></div><div class="line">        child = mRecycler.getActiveView(position);  </div><div class="line">        <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="comment">// Found it -- we're using an existing child  </span></div><div class="line">            <span class="comment">// This just needs to be positioned  </span></div><div class="line">            setupChild(child, position, y, flow, childrenLeft, selected, <span class="keyword">true</span>);  </div><div class="line">            <span class="keyword">return</span> child;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// Make a new view for this position, or convert an unused view if possible  </span></div><div class="line">    child = obtainView(position, mIsScrap);  </div><div class="line">    <span class="comment">// This needs to be positioned and measured  </span></div><div class="line">    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[<span class="number">0</span>]);  </div><div class="line">    <span class="keyword">return</span> child;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不管怎么说，这里首先仍然是会尝试调用RecycleBin的getActiveView()方法来获取子布局，只不过肯定是获取不到的了，因为在第二次Layout过程中我们已经从mActiveViews中获取过了数据，而根据RecycleBin的机制，mActiveViews是不能够重复利用的，因此这里返回的值肯定是null,我们继续走到了obtainView中，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function">View <span class="title">obtainView</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span>[] isScrap)</span> </span>&#123;  </div><div class="line">    isScrap[<span class="number">0</span>] = <span class="keyword">false</span>;  </div><div class="line">    View scrapView;  </div><div class="line">    scrapView = mRecycler.getScrapView(position);  </div><div class="line">    View child;  </div><div class="line">    <span class="keyword">if</span> (scrapView != <span class="keyword">null</span>) &#123;  </div><div class="line">        child = mAdapter.getView(position, scrapView, <span class="keyword">this</span>);  </div><div class="line">        <span class="keyword">if</span> (child != scrapView) &#123;  </div><div class="line">            mRecycler.addScrapView(scrapView);  </div><div class="line">            <span class="keyword">if</span> (mCacheColorHint != <span class="number">0</span>) &#123;  </div><div class="line">                child.setDrawingCacheBackgroundColor(mCacheColorHint);  </div><div class="line">            &#125;  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            isScrap[<span class="number">0</span>] = <span class="keyword">true</span>;  </div><div class="line">            dispatchFinishTemporaryDetach(child);  </div><div class="line">        &#125;  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        child = mAdapter.getView(position, <span class="keyword">null</span>, <span class="keyword">this</span>);  </div><div class="line">        <span class="keyword">if</span> (mCacheColorHint != <span class="number">0</span>) &#123;  </div><div class="line">            child.setDrawingCacheBackgroundColor(mCacheColorHint);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> child;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在第四行我们会主动请求获取一个ScrapView，这个时候我们是有的，我们进入第七行，getView方法中直接将ScrapView传入，看来这个就是我们在getView中复用的convertView了。</p>
<p>到此ListView分析完毕，尽管是跟着郭神的博客走，但我是先独自很认真的看了一遍，再一个人尝试着独立分析，当中难免有不会的地方，然后再看博客，就会豁然开朗，理解更上一层楼了。写了这么多尤其还是自己主观的“独立”完成了，虽然没有把源码彻底看完，但是收获的东西真的不是一般的多，不仅收获到知识，更多的知道了下次该如何看源码，这个样的文章我还会出几篇，等我轻车熟路了，就说不写分析过程，直接写自己的探索结果了。源码不是一遍就可以看懂的，要反复认证的看才可以，毕竟是别人的东西，深得要领是有一定难度的。</p>
<p>说一下感受，看源码真是一个体力加脑力的活，你的专注力要持续的跟上，才可以见到庐山真面目啊！！！很佩服那些看源码的，真是真功夫！</p>
<p>最后附上参照博客地址<a href="http://blog.csdn.net/guolin_blog/article/details/44996879" target="_blank" rel="external"> Android ListView工作原理完全解析，带你从源码的角度彻底理解</a></p>
]]></content>
      
        <categories>
            
            <category> 2017-3 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[随笔（2）]]></title>
      <url>http://yoursite.com/2017/03/11/%E9%9A%8F%E7%AC%94%EF%BC%882%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>我总是喜欢想一些乱七八糟的东西，很多时候都会有一些其他人认为不可思议的行动。我总是在尝试着各种各样我没有接触过的事情，虽然有些事情会很恐怖、会很危险，但正由于这样的事情，让我发现了各种各样的世界，让我看见了在我眼中真正的世界（好吧，这句话虽然有些浮夸，但确实是最真实的想法），渐渐的我无比热爱自己的生活。</p>
<p>也不知道什么时候，我一个大老爷们有些迷上了写字这个东西。也不知道为什么，对于自己的新想法、新思路，总有一种冲动，在笔记本上记录一下它的发展过程。交到一个真正的朋友，我更愿意用文字来和他沟通。在学习一些新东西的时候，总会在一个时间段之后写篇文档总结一下，我总是提倡共同前进的伙伴也一块来做，但很少有人拿这个东西当回事，让它一直做下去。生活上能用来文字处理的事情，我都不太愿意用其他方式。我都有点认为只有文字才是人类最究极的沟通方式。</p>
<p>创建一个属于自己的博客，在上面把自己写过的文章部署上去，对于我来说，这种方式恰到好处，自己平时乱七八糟写的东西大都不用在电脑里面等着被遗忘，最终丢入回收站的厄运。偶尔没意思了，也可以稍微看一下，只能说回头看自己的感觉很舒服，很惬意，至少我还能知道我做了一些什么东西，当然前提是你一直在努力的往前走。在搭建自己博客的时候，我有意的没有加入让搜索引擎可以检索到我的页面，或许对于一个程序员来说，闭门造轮子是一件不好的事情，大概可能主要是对于自己目前的技术还不是太满意，毕竟人们总是喜欢把自己竟可能好的一面展现给别人看，未来等着时机成熟了肯定会转到其他平台的。</p>
<p>我目前还是一名大二学生，学校老师很开明，对于有能力独自学习的同学给予充分的自由，好吧（继续说就有点夸自己的意思了），那个同学就是我，不过对此我从不认为这是我应该得到的，只能感激老师们的善良及其对我的信任。我现在课程很少，也就一节体育课，还有一门数学课（这个是我主观想去的），我有很多的时间去独自管理，当然在上学期我也旷了很多课，只是没有此刻如此清爽的感觉，和上学期遇到的问题一样，时间安排方面有些不的当的地方。总是在技术方面死命的往前走，虽然也意识到要放缓脚步，让知识积淀一些，基础牢靠了这样走的才会稳当。对于这件事情上感觉自己已经控制不住了的样子，当然本源还在自己认识不到位导致的。事情的转机就是现在，有了博客之后，主观上面就愿意去在上面写一些东西，更愿意把自己的知识拿出来放上去，弄成一个专栏会很有成就感。好处简直太多，坏处的话也就只能说更加辛苦了一下，坚持下去总是对自己没有坏处的。<br>上面写的让我回想起某广告的钙片，自从吃了它，腰不酸了，腿不疼了，一口气上六楼楼梯，也不累了。这个钙片我好像找到了。 d=====(￣▽￣*)b </p>
<p>先给自己制定一个小目标———一个月不断更。上传的内容主要还是技术性的为主，像这个样乱七八糟的就当缓解心情了。</p>
<p>本来还打算解释一下我博客的标题为什么是JianRan的，没想到扯了这么多其他东西的，不过这也符合，这个专栏的宗旨嘛~，乱七八糟随便写。</p>
]]></content>
      
        <categories>
            
            <category> 2017-3 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 乱七八糟 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[栈与队列（二）]]></title>
      <url>http://yoursite.com/2017/03/10/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>承接上文<a href="https://jinfangzhang.github.io/2017/03/08/栈与队列（一）/" target="_blank" rel="external">栈与队列（一）</a>，上文我们说了有四个方面的应用，还差几个，这篇给彻底补全</p>
<hr>
<h2 id="栈混洗"><a href="#栈混洗" class="headerlink" title="栈混洗"></a>栈混洗</h2><p>什么是栈混洗？<br>有三个栈，分别是A、B、S, 栈A中有a1– an的若干元素，a1在栈顶，an在栈顶、B和S都是空栈。<br>在这里我们只允许，将A的顶元素弹出并压入S,或将S的顶元素弹出压入B。<br>若经过一系列以上操作，A中元素全部转入B中，则称之为A的一个栈混洗（stack permutation）<br><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdi078c54ij30gs03bt98" alt=""> 中间的栈为S。<br>在这里我们把<strong>[</strong>an ,a(n-1)….,a1<strong>&gt;</strong>,看做一个栈内的所有元素，其中”<strong>[</strong>“代表栈顶，”<strong>&gt;</strong>“代表栈顶。<br>同一个输入序列，可以有多种栈混洗。就拿上图来说。<strong>&lt;</strong>1，2，3<strong>]</strong>的输入列可以有<strong>[</strong> 1，2，3<strong>&gt;</strong>,<br><strong>[</strong> 3，2，1<strong>&gt;</strong>等多种栈混洗，只要遵循上述规则。</p>
<p>那么问题就来了，一个长度为n的序列可以有多少种栈混洗？最多不可能多于$n!$,好吧,我看了一些资料，知道最后的结果是为<br>$$\frac {2n!} {(n+1)!n!}$$<br>这个数也叫做卡特兰数。感觉分析如何得出的没有什么意义，在此我们先忽略导出步骤。我们把 “先前的栈” 的$3$带入公式，发现我们共有5种栈混洗，而 $3!$ 为6,我们在这三个数的全排列中有一种栈混洗是无法获得的那就<strong>[</strong>3，1，2<strong>&gt;</strong></p>
<p>那么问题又来了，既然一个长度为n的序列的栈混洗数量不是$n!$，那么我们如何来鉴别这个栈混洗是否由之早先的栈序列获得的呢？<br>答案在其实上面我们已经给出。只要当前的栈混洗不存在<strong>[···</strong>J，···I，···K，···<strong>&gt;</strong>(之前的序列是···I,···J,···K···)，这样的序列那么我们的的栈混洗就是存在的</p>
<p>与我们之前说的括号匹配问题，其实实属同一种东西。在括号匹配的时候，对于我们可见的只有中间的栈S而已，我们有多少push操作，对应的就有多少pop操作，我们的栈中只存左括号，当栈外有右括号的时候我们就弹栈。换句话说我们有多少种该情况下的栈混洗我们就有多少种括号匹配的数量。</p>
<h2 id="中缀表达式（延迟缓冲）"><a href="#中缀表达式（延迟缓冲）" class="headerlink" title="中缀表达式（延迟缓冲）"></a>中缀表达式（延迟缓冲）</h2><p>重新提一下延迟缓冲的概念：线性扫描算法中，在预读足够长之后，方能确定可处理的前缀</p>
<p>中缀表达式就是咱们平时算术式，举一个例子：3<em>32+9</em>（3+1），这个就是所谓的中缀表达式。那么我们的目的就是用算法的形式来计算这样的式子。对于如此的简单的算式对于咱们人类来说只能说不要太简单了，我们知道”+，-，*，/“的优先级，我们知道括号有强制运算的作用。当看到一个算式的时候，我们可以随意以各种方式来计算，对于死板的计算机来说就有些复杂了。</p>
<p>初次看到如此算式，我们都不清楚如何来计算，计算机不像人类，对于它来讲，从左到右顺序扫描，慢慢求解，对于它是简单的，也是我们容易思考得到的。读取的方式有了，我们还欠缺的是，不知道此时看到的加号是否应该执行，可能它后面就有个“*”号或者“/’。那么我们只有在依次扫描过程中，先将不确定的留着，等着我们后面扫描，知道我们认为这个地方肯定是这么计算之后，我们才计算。</p>
<p>拿这个例子来说3<em>32+9</em>（3+1）<br>从左到右依次扫描，扫描到“3”，发现是数字，我们存起来，因为一个数字不可以单独计算（除非这个算式只有一个数字的）；接下来我们发现是“<em>”，没有条件运算；“3” ，不满足条件运算；“2”，还是数字！应该存入的是32而不是单独的3和2了，依然不满足条件运算；“+”，这个比之前“ \</em> ”的优先级低，说明可以运算，将运算结果96存入，把运算过的数据撤销；“+”，不可运算，存入；“9”，不可运算，存入；“（”，不满足条件，存入；“3”，不满足条件，存入；“+”，不满足条件，存入；”1“，不满足条件，存入；”）“，满足条件，计算$ 3+1$，将参加运算的数据撤销，将4存入，到现在为止，我们处理到”）“，这个地方的数据还没有处理，接下来正要处理的右括号和已经存入的左括号匹配，这两个撤销，我们到现在存入的数据为$96+9<em>4$,我们现在算式已经处理完成了，可以确保“ \</em> ”可以运算，计算$9*4$，将处理过的数据撤销，将36存入；好吧现在里面只有两个数的加法$96+36$，将运算结果132存入。到此我们计算完毕。</p>
<p>在这个过程当中我们发现，可能我在上面判断是否有条件计算的过程没有说，这个过程其实就是比较两个算符的优先级，当是后者的优先级高时，我们进行存入操作，当小于后者时，我们认为可以计算了，所以我们欠缺的其实是一张优先级表而已。大部分运算符只能处理两个数据，“！”等是个特例，不过我们都是可以确认我们的计算数据个数的。而且我们发现，在处理过程当中符号和数据应该分开存储更加清爽，同时也方便了很多。当然存储数据的地方是栈，我们细想起来，我们的操作不就是<strong>压栈</strong>和<strong>弹栈</strong>两种操作吗？存入操作就是在栈顶push，要取的数据也在栈顶。我们算法思路已经清晰。接下来就是算法具体思路如下：<br><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdi09c9csuj30yf0kvwz9" alt=""><br>这是运算符优先级表。<br><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fdi0abrn0vj315w0mc1j1" alt=""></p>
<h2 id="栈式运算"><a href="#栈式运算" class="headerlink" title="栈式运算"></a>栈式运算</h2><p><em>其实这个标题和中缀表达式是连着的。</em></p>
<p>我们对于上面计算方式，其实也是可以改进的，为什么我们要识别符号的优先级呢？为什么不能见到算符算就好了，对于这样的需求，我们伟大的科学家已经解决！ 解决方案就是先把算式转换成逆波兰表达式。<br>具体步骤，我们依然以上面的算式为例。<br><strong>起始（1）:</strong>3*32+9*（3+1）<br><strong>（2）:</strong>((3*32)+(9*(3+1)))—&gt;能加多少括号就加多少括号<br><strong>（3）:</strong>((3,32)*(9 (3,1)+)*)+   —&gt;把符号移到对应括号的右边<br><strong>（4）完成：</strong>$3,32,*9,3,1+*+<br>然后使用中缀表达式的解法来解，即可</p>
]]></content>
      
        <categories>
            
            <category> 2017-3 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[汇编语言基础（一）]]></title>
      <url>http://yoursite.com/2017/03/09/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<hr>
<p>因为某些课程的需要，并且学校还不会开设这门课程，那么只好自己动手丰衣足食了<br>以下内容仅仅是基础当中的基础</p>
<hr>
<h2 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h2><p>大家都清楚计算机里面的数据只有两种形式0和1。计算机是由电路组成的，电路只有开关两种状态，存储信息同样也只要高电平和低电平两种表示状态。从人理解计算机的角度来讲，计算机里面的信息分为两种，一种是命令，一种是数据，我们可以通过命令对数据进行操纵。但是对于计算机来说，不过是命令还是数据其本质都是0和1，也就是信息。关键就看计算机怎么看待这个信息了。<br>1000100111011000 -&gt;89D8H（数据）<br>1000100111011000 -&gt;mov ax,bx（程序）</p>
<p>对于汇编语言来说，他是最接近底层的语言，仅仅封装了一些助记符。对于机器来说，不同类型的机器，可能拥有不一样的汇编语言。所以我们此刻讲到的汇编是以8086CPU来讲的。</p>
<h2 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h2><p>存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号，例如有128个存储单元，编号从0~127.</p>
<p>那么一个存储单元能存储多少信息呢？我们知道计算机的最小单位是bit，也就是一个二进制位。8个bit组成一个Byte，即8个二进制位。一个存储存储器有128个存储单元，那么就可以存储128 Byte。</p>
<h2 id="CPU对存储器的读写"><a href="#CPU对存储器的读写" class="headerlink" title="CPU对存储器的读写"></a>CPU对存储器的读写</h2><p>CPU要从内容中读数据，首先要指定存储单元的地址，另外，在一台计算机当中，可不只有存储器这一种器件。CPU还要在读写数据时还要指明，他要对哪个器件进行操作，进行哪种操作，是从中读数据还是取数据。可见，CPU要想进行数据的读写，必须和外部器件，进行下面三类信息的交互<br>· 存储单元的地址（地址信息）<br>· 器件的选择，读或写的命令（控制信息）<br>· 读或写的数据（数据信息）<br>这三种信息是通过三类导线进行连接的。地址总线、控制总线、数据总线。</p>
<p>举一个例子，CPU从3号存储单元中读取数据的过程<br>1）CPU通过地址线将<strong>地址信息3</strong>发出<br>2）CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。<br>3）存储器将3号单元中的数据8通过数据线送入CPU</p>
<p>每个CPU芯片都有许多管脚，也可以说，这些管教引出总线。一个CPU可以引出3种总线，这三种总线宽度标志着这个CPU的不同方面的性能<br>·地址总线的宽度决定了CPU的寻址能力<br>·数据总线的宽度决定CPU与其他器件进行数据传送时的一次数据传送量<br>·控制总线的宽度决定CPU对系统其他器件的控制能力。</p>
]]></content>
      
        <categories>
            
            <category> 2017-3 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 汇编语言基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[栈与队列（一）]]></title>
      <url>http://yoursite.com/2017/03/08/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><em>今天开始新一部分的内容&lt;数据结构&gt;，因为博客在我学习数据结构期间才搭建好，所以内容方面可能断断续续的，不过这些我以后都会调整好的</em><br>（这个本来是昨天要提交的，无奈太晚只能留到明天，保证没有下次了）</p>
<hr>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><strong>栈的特点</strong>：是先进后出（FILO），而且每一次出去（弹栈）的元素或者每一次进入（压栈）的元素都只能对栈顶元素进行操作。（好吧在这里本来想插入图片的，先略过这个东西）</p>
<p>既然是数据结构肯定会提供一些接口便于使用</p>
<ol>
<li>push(): 压栈</li>
<li>pop():  弹栈</li>
<li>top():  在不弹栈的基础上获取栈顶元素内容<br>因为我们的栈是可以基于向量或者链表实现的，所以一些基本方法，如size()、empty()以及其他开放的接口均直接沿用</li>
</ol>
<p>到此栈的特点介绍完毕，它的输入输出数据的规则和一些暴露在外部接口。</p>
<p>接下来我们来说说，根据栈这种FILO的原则有哪些应用呢？<br>总的来说可以分为四大类：<br>· 逆序输出(conversion)：输出次序与处理过程颠倒；递归深度和输出长度不容易预支<br>· 递归嵌套(stack permutation +parenthesis)：具有自相似性的问题可递归描述，但分支位置和嵌套深度不固定<br>· 延迟计算(evaluation)：线性扫描算法模式中，在预读足够长之后，方能确定可处理的前缀<br>· 栈式计算(RPN)：基于栈结构的特定计算模式</p>
<ol>
<li><p>进制转换（逆序输出）<br>对于一个任意十进制的数字，如果想转换成其他进制，只需每一次除以进制位数，取余，最终被除数为零停止，然后以逆序的形式读出，这个就是该进制下的这个数字的对应表示。具体思想我以上已经表述清楚，但是很多时候大家会求出来的是一个正序的数，而我们要的是逆序。对于这样一个问题，我们请用栈来解决问题<br>算法实现：</p>
<blockquote>
<pre><code>void convert(Stck&lt;char&gt; &amp;S,int n, int base){
    static char digit[]={&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;};
    //常用的进制都是十进制的，这是为了提交数据表示能力
    while(n&gt;0){
        s.push(digit[n%base]);//余数入栈，到时候只需要一次弹栈即可以获得相对应的进制
        n/=base;//n更新为其对base的除商
    }
}
</code></pre></blockquote>
</li>
<li><p>括号匹配（递归嵌套）</p>
<p>我们乍一看貌似没有什么思路，咱们可以慢慢来思考，首先对于一个如此的算式“(（2+3）+（2+3）+（2+5））”，咱先把一些不必要的东西去除只留下括号“（（）（）（））”，主要为了突出问题的本质。我们从最左边开始，依次的深入，我们会发现，最里层的括号，左边括号紧挨着的 就是他的右半边括号，然后我们可以忽略这对匹配好的括号，我们依次向外递推，每向外推出一层，就会有一对括号匹配。大概以上面的思路，我们这一下面的想法，怎么使用栈？，从左往右一次遍历括号，遇见一个左括号就进行压栈，然后这样我们逐步的就到了算式的“最底层”,然后遇见一个右括号就进行弹栈，遇见一个就进行弹栈，最终当栈里面没有元素了同时算式里面的括号已经没有了，好的，现在我们可以说这个算式括号匹配的：<br>依照我们的思路算法不难写出，以下是算法实现：</p>
<blockquote>
<pre><code>bool paren(char exp[],int lo,int hi){
    Stack&lt;char&gt; S; //我们使用栈进行记录
    for(int i = lo; i&lt; hi;i++)
        if(&apos;(&apos;==exp[i]) S.push(exp[i]);//遇左括号：则进栈
        else if(！S.empty())S.pop;//遇到右括号，栈非空弹栈
        else return false;//否则（遇到右括号时已空），不匹配
    return S.empty;//最终，栈空当且仅当匹配

}
</code></pre></blockquote>
</li>
</ol>
<p>反思一下，当然有些同学也注意到了，我们完全可以不使用栈，而仅使用计数器就可以完成，这个想法是好的而且也是可以做到的。<br>我们的思路有了，我们来看一下我们这个算法的改进是否真的可行？答案是不可以的。单纯的靠左括号和右括号来识别而忽略括号的类型，这样做显然不可以，我们不仅仅只有小括号，我们还有中括号，还有大括号等等。我们在弹栈的同时，还要进行括号类型的匹配。所以基于对这个问题的分析，我们的算法又有了提升的策略，我们在弹栈的时候，只有与之对应类型的右括号出现在栈外时才可以弹栈。当然算法不可以是上面的了。</p>
]]></content>
      
        <categories>
            
            <category> 2017-3 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java(一)]]></title>
      <url>http://yoursite.com/2017/03/07/Java-%E4%B8%80/</url>
      <content type="html"><![CDATA[<p>经典真是需要反复阅读，反复感受才可以</p>
<hr>
<p><em>在这里我会把之前看过但是没有意识到，或者自己不能理解，且十分有价值的东西罗列</em></p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ol>
<li><p>万物皆对象<br>世界上任何东西都可以被当作为对象，对于建立对象这个过程，叫做抽象，把事物从物质世界给提取出来，将这件事情的关键信息拿出来，然后对于提取的东西进行分装之后就成了对象。</p>
</li>
<li><p>程序是对象的集合，它们通过发送消息来告知彼此要做的<br>更具体来说，可以把信息想象成为特定对象的方法和调用请求。就向人与人之间交流一样，每个人都可以看做一个对象，我们通过用语言这种信息来进行彼此的交流。</p>
</li>
<li><p>每个对象都有自己的存储（有其他对象所构成的存储）<br>换句话说，就是允许对象里面有对象，不过想想也对，万物皆对象，把一件事物一些必要信息提取出来，这个信息从本质上来说就是对象。</p>
</li>
<li><p>每个对象都拥有类型<br>每个对象都有属于他的类别，人和狗都属于动物，人、狗、石头都属于物质。世界上所有的东西最终都可以归为一类。就好像Java中所有对象都自动继承Object类一样。</p>
</li>
<li><p>某一特定类型的所有对象都可以接受同样的信息<br>每一种中生物之间，都用彼此想通的语言作为交流工具</p>
</li>
</ol>
<p>说来说去面向对象的语言、就好像一个虚拟但又完整的世界</p>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>每一个对象都有每一个对象的功能，每个对象都能提供一种“服务”</p>
<p>在面向对象语言中，封装的思想随时随地的体现着<br>既然是说封装，对象就能好比一个人，对于一个人来讲肯定有些愿意提供给外部进行使用的“功能”，也有一些不愿意对外部使用的“功能”，而且其中还有一部分功能只愿意在某些私密的场合。基于这种解释，对于权限的使用就大致清楚了，private可能是谁都不愿意说的小秘密或者是自己在做某一些事情当中一些独到的地方，这类的信息只允许自己查阅，public相当于自己的工作技能差不多，在工地上我可以向外界提供搬砖这个功能。protected和包权限更像是只愿意在某个特定的环境下才愿意拿出来的。</p>
<p>从纯服务角度来说，对于客户，我只需要你的服务，客户并不需要知道这个服务里面的具体实现细节，对于客户来讲，这些细节还存在一定的干扰性，而且是根本没有意义的一些东西，那么对于一项好的服务来说，客户需要什么就提供什么，不要把其他乱七八糟加进来，做好相应的封装，只提供客户需要的信息。</p>
<p>当然对于private、public、protected、默认权限 来说解释各种各样，但是无疑是再次封装<br> （对于语言的基本认识大概如此）</p>
<hr>
<h2 id="绑定、静态绑定、动态绑定的概念"><a href="#绑定、静态绑定、动态绑定的概念" class="headerlink" title="绑定、静态绑定、动态绑定的概念"></a>绑定、静态绑定、动态绑定的概念</h2><ul>
<li>绑定</li>
</ul>
<p>绑定指的是一个方法的调用与方法所在的类(方法主体)关联起来。<br>对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定。</p>
<ul>
<li>静态绑定</li>
</ul>
<p>在程序<strong>执行前</strong>方法已经被绑定，针对java简单的可以理解为程序编译期的绑定；<br>java当中的方法只有final，static，private和构造方法是前期绑定</p>
<ul>
<li>动态绑定</li>
</ul>
<p>在<strong>运行时</strong>根据具体对象的类型进行绑定。提供了一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。</p>
<p>就简单介绍到这里，因为是绪论，就不讲太多，留给后面的章节。</p>
]]></content>
      
        <categories>
            
            <category> 2017-3 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java编程思想 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[随想(1)]]></title>
      <url>http://yoursite.com/2017/03/05/%E9%9A%8F%E6%83%B3%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>搭建自己博客的想法已经持续了很长时间，但是总是给自己各种各样的理由推脱，无非是事情多，时间紧，或者之后的一段时间直接忘掉了，反正都没有付诸于行动。</p>
<p>付费阅读很是火热（可能已经火了好久我才注意到），自己关注的微信公众号，都推出了自己的小密圈，于是抱着对于自身的好奇，当然还有对于作者充分的信任，我选择加入了一个（帅张）。里面交流的虽然不是很火热，不像QQ群一样(一会一大推的消息)，但里面总是给人一种非常轻松，少去了很多浮躁的气息。而且里面分享的内容质量也很高。对于目前的我来说，总是能找到一些属于的养料进行吸收。</p>
<p>通过公众号接触张哥，感觉是一个性情十足的汉子，同时也是在IT行业优秀的前辈。</p>
<p>在里面，张哥写了一个分享叫&lt;为什么要写博客&gt;，之前也在公众号里面推送过类似的文章，同样这类的文章看的其实也有七八篇。先忽视在其他地方看到的。就这样的一位“开拓者”总是很用心的分享给我们他成功的方法。我是非常幸运，也是十分感激的。前方明明有一个比自己优秀多的人告诉自己前方的道路这样走会更快更好，自己偏偏要自己去摸索走各种弯路最终还是回到了这个上来。每次看到相应的博客，总是当时恍然大悟，茅塞顿开的感觉，然后呢？就没有了。这大概也是如今很多人通病所在。</p>
<p>在加入小密圈的同时，我也在<em>得到</em>这样一个应用上面订阅了吴军老师专栏，里面的第一篇【发刊词】就提说到了这样一个问题。几年前Google举办一次商业活动，免费向合作伙伴发放入场券，拿到入场券的人都确认要来，但是到活动开始的时候，只来了一半的人。第二点Google每张入场券收取50美元，这当前只占Google所付出费用的小部分，但是这一次，大家因为掏了50美元，都来了，基于这个教训，我们意识到，一个人只有付出（哪怕只有一点点），才会珍惜他换来的。才会比较重视的主动的去思考一些内容。事实证明这样真的是很有效的。</p>
<p>“道理我都懂，但是之后就没了下文”，这大概也就是我与真正优秀的人的差距了，别人做到了，而我却只说到了。生活中的例子不胜枚举，和我一同学习Android的同学，之前我就早就当面十分详尽的阐述了要注重看一手资料，要看Google官方文档，但是他就自己偏执一词，给出各种的理由，但是经过一个寒假的时间，才缓缓意识到这个问题，现在才慢慢开始看。这样的问题自己身上就多的数不清楚了。很多事情我们只是看到了，而没有意识到，然而自己的思想里面，非要站在一个制高点说“我意识到了”。只有当付出代价之后，你才会意识到一件事情的重要性，之后就会说，要是我当初做了，就怎么怎么样了，然而却完全没有时间改变。我很庆幸我自己真正意识到了这个问题，通过“付费”，这样一种代价很低的形式，庆幸自己没有让你自己用时间明白这一切，到时候就真的完了。</p>
<p>已经使得到和<em>小密圈</em>一段时间，渐渐的已经熟悉的这么一个环境，聚集了一群志同道合的人，聊起天来也会感到分外轻松。我也不是一味夸许付费阅读有多好，但是“付费”的的确确过滤出了一个更好的环境，一个更有品质的环境。在小密圈中各路的前辈总是会乐意分享出自己阅读过程中有价值的文章给我们，同时也可以和向我一样处于同等阶段的同学们，互相了解。不是说非要通过付费的方式来可以获得，但是这个过程绝对会浪费比这种形式多出好几本的时间。在<em>得到</em>里面更多的是向学习优秀的人（更确切的说是卓越），如何去思考一些事情，知道大咖们在关注什么，可以通过他们来了解一些带有他们思考的前沿。方方面面的东西都可以帮助自己成长。开始尝试自己不曾做过的，开始主动的去步入一个新的世界（说了如此对于我付费阅读的优点，终究是属于自己的，我说的这些抽象出来都是所谓的事情，纯粹来说，这一件事情本身没有什么意义，所有意义都是人为赋予的且对于自己来说是唯一的）</p>
</blockquote>
<p>通过这样一个途径让我开始做一些之前没有的事情，就拿刚做的来说，搭建博客并且开始写博客，以此为起点我要开始做一些之前带有抵触情</p>
<ul>
<li>持续的写技术博客</li>
<li>主动看纯英文文档</li>
<li>开始使用第三方库</li>
<li>尝试看常用第三方源码</li>
</ul>
<p>到目前为止，我已经拥有了自己的博客。</p>
<p>这次博客用了不到一天的时间，没有过度的修饰，毕竟当前还是用来写文章，记录文章的。过多花哨的功能除更加美观外基本没有什么过多的作用。同时创建自己博客的初衷，不仅仅是做技术记录，单纯的技术博客，更多的是想记录下我的生活而不是仅仅是我的职业。刚开始文章各方面无论是语言表述方面还是排版方面都是很有欠缺的，希望自己通过这样一个小的平台来逐步提升自己，作为一个大学生来说，最基本的除具备未来职业的基本专业知识外，还要拥有良好的表达能力和写作能力。到我毕业之后希望给自己交一份不错的答卷。</p>
]]></content>
      
        <categories>
            
            <category> 2017-3 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 乱七八糟 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
