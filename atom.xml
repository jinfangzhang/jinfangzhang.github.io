<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JianRan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-04T08:41:01.435Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JianRan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>堆与堆排序</title>
    <link href="http://yoursite.com/2018/03/27/heap-1/"/>
    <id>http://yoursite.com/2018/03/27/heap-1/</id>
    <published>2018-03-27T13:21:55.000Z</published>
    <updated>2018-04-04T08:41:01.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么使用堆"><a href="#为什么使用堆" class="headerlink" title="为什么使用堆"></a><strong>为什么使用堆</strong></h2><p>堆是一种特别的,同时也是十分有用的数据结构，由其衍生出来的应用有很多，比较典型的应用是叫做 <strong>优先队列</strong> 的应用。堆的一个很大的特点，就是其动态性，可以依靠相对简单的步骤来维持堆的性质。</p><blockquote><p>由于个人眼界问题，对于堆的认识还不深刻，这一部分等到以后，有足够学识之后再来补充</p></blockquote><h2 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a><strong>堆的定义</strong></h2><p>堆总体思想其实就是树，在其中二叉堆是一个较为经典的实现。当然，在一个二叉树的基础上还要满足一些条件才可以被称为一个堆(最大堆)：</p><ol><li><p>树中任何一个节点的值(根节点除外)，总是不大于其父节点的值</p></li><li><p>是一个完全二叉树</p></li></ol><p>依照这样的定义实现的堆，会发现根节点的元素是堆中所有元素最大的那一个。于是乎，这样的一个堆可以称为最大堆或者说大顶堆，相反也有最小堆和小顶堆之说。在下面我们全都采用大顶堆来进行描述。</p><h2 id="堆的经典实现"><a href="#堆的经典实现" class="headerlink" title="堆的经典实现"></a><strong>堆的经典实现</strong></h2><p><img src="http://p3o1bechg.bkt.clouddn.com/FtLkd8QGI86QM-_jUE0QiJly8VRQ" alt="-"></p><p>当看到上面这个堆的图时，很容易就可以联想到使用树这种数据结构来进行实现。但，对于堆来说，还有一种较为经典的、使用数组实现的方法。</p><p>也正因为堆是一个完全树，依据其特性，才能够使用数组进行实现。</p><p>数据依然是上图，如果我们从根节点开始标号，每一层从左往右依次标号，最终标完之后是下图这样的。</p><p><img src="http://p3o1bechg.bkt.clouddn.com/FmMrwbNJIMQJFjgwDQ8lWX3sjI6O" alt="-"></p><p>从一开始标号的数据，也就是如图标示的样子有这样几条规则。      </p><pre><code>1. parent(i)  = i / 22. left child(i) = 2 * i3. right child(i)= 2 * i + 1</code></pre><p>如果我们要按照起始节点为 0 开始标记的话，规则就需要稍微进行变动一下。影响并不大，但刚开始从 1 开始标记的话，会更容易理解一些。</p><p><img src="http://p3o1bechg.bkt.clouddn.com/FreC4JkRFIid7xCCx9WWOYC9M4cT" alt="-"></p><p>规则:</p><pre><code>1. parent(i)  = (i - 1) / 22. left child(i) = 2 * i + 13. right child(i)= 2 * i + 2</code></pre><h2 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a><strong>堆的实现</strong></h2><p>使用第一种方式来进行实现。毕竟是一种数据结构，先简单搭建骨架。并且要说明一点的是，堆只有两种对外的基本操作，一种是插入数据，另一种是取出当前最大的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//基本骨架</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</div><div class="line"><span class="keyword">class</span> MaxHeap</div><div class="line">&#123;</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    Item *data;</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    <span class="keyword">int</span> capacity;</div><div class="line"></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Heap(<span class="keyword">int</span> n)</div><div class="line">    &#123;</div><div class="line">        data = <span class="keyword">new</span> Item[n] count = <span class="number">0</span>;</div><div class="line">        capacity = n;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ~Heap()</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">delete</span>[] data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> isEmpty&#123;</div><div class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>使用<code>*data</code>来存储数据，<code>count</code>为当前实际存储的元素，<code>capacity</code>是当前的容量。</p><p>因为堆需要时刻动态维护堆的定义，当添加一个元素在其数组末尾时或取出根元素时，极有可能破坏了堆的定义，为此，衍生出了两种操作，shiftDown 和 shiftUp 。</p><h2 id="shiftUp"><a href="#shiftUp" class="headerlink" title="shiftUp"></a><strong>shiftUp</strong></h2><p>当数组在尾部插入一个数据时，需要对那个元素做 shiftUp 操作，使整个堆的意义再次成立。</p><p><img src="http://p3o1bechg.bkt.clouddn.com/FrxZu9YDpjru8oQfyOyPYILBT43S" alt="-"></p><p>图中我们插入了数值为 52 的元素。</p><p>对于52来说，它需要不断的和其父节点比较，如果52更大则交换位置，之后继续与父节点比较，直至不可以交换为止。到此，堆的定义将会继续维持。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; </div><div class="line">    <span class="keyword">while</span>(data[i] &gt; data[i/<span class="number">2</span>] &amp;&amp; i &gt; <span class="number">1</span>)&#123;</div><div class="line">        swap(data[i],data[i/<span class="number">2</span>]);</div><div class="line">        i = i/<span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对应的 <strong>intsert 算法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;</div><div class="line">    data[count+<span class="number">1</span>] = item;</div><div class="line">    count++;</div><div class="line">    shiftUp(count+<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="shiftDown"><a href="#shiftDown" class="headerlink" title="shiftDown"></a><strong>shiftDown</strong></h2><p>当取走根元素的之后，为了保证它依然是一棵树，我们把最后一个元素放置于根的位置，之后，对根进行 shiftDown 操作，来维持堆的定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="comment">//是否有子节点</span></div><div class="line">    <span class="keyword">while</span>(<span class="number">2</span>*i &lt;= count )&#123;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">2</span>*i;</div><div class="line">        <span class="comment">//有右节点的同时右节点更大。</span></div><div class="line">        <span class="keyword">if</span>( j + <span class="number">1</span> &lt;= count &amp;&amp; data[j+<span class="number">1</span>] &gt; data[j])</div><div class="line">            j++;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(data[i] &lt; data[j])</div><div class="line">            j = j;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        swap(data[i],data[j]);</div><div class="line">        i = j;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>extractMax<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</div><div class="line">    Item ret = data[<span class="number">1</span>];</div><div class="line"></div><div class="line">    swap( data[<span class="number">1</span>] , data[count] );</div><div class="line">    count --;</div><div class="line">    shiftDown(<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="HeapSort"><a href="#HeapSort" class="headerlink" title="HeapSort"></a><strong>HeapSort</strong></h2><p>正好因为堆本身的特点，写起排序也会很简单。将要排序的数据依次插入堆中，让其生成一个堆，然后再依次去除根元素，并赋值给原来的数组，以达到排序的目的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort1</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line"></div><div class="line">    MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(n);</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</div><div class="line">        maxheap.insert(arr[i]);</div><div class="line"></div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i-- )</div><div class="line">        arr[i] = maxheap.extractMax();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="建堆优化"><a href="#建堆优化" class="headerlink" title="建堆优化"></a><strong>建堆优化</strong></h2><p>在上面的算法中是依次一个一个的插入一个空堆中，以此得到一个完整的堆。而直接对一堆数据进行建堆操作来说，表现会更好。</p><blockquote><p>对于前者，它的算法复杂度是$O(nlog^n)$<br>对于后者，它的算法复杂度是$O(n)$</p></blockquote><p>数学还ok的同志可以去证一下，其他同志就跟上我，感受感受得了。</p><p>对于一堆数据如何对他进行建堆？</p><p>一个完整堆来说，其实每一个节点都可以被认为是一个堆。那么换句话来说，对于一套数据来说，只要满足其中每个节点对其子节点都是一个堆，应用到整个数据，那么就可以就构成了一个堆。</p><p>因为就一个元素而言，它怎么也是一个堆，那么只需要对其非叶子节点，从第一个非叶子节点，依次进行 shiftDown 操作，即可。</p><p>直接增加一个构造函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">MaxHeap(Item arr[], <span class="keyword">int</span> n)&#123;</div><div class="line">    data = <span class="keyword">new</span> Item[n+<span class="number">1</span>];</div><div class="line">    capacity = n;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i ++ )</div><div class="line">        data[i+<span class="number">1</span>] = arr[i];</div><div class="line">    count = n;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = count/<span class="number">2</span> ; i &gt;= <span class="number">1</span> ; i -- )</div><div class="line">        shiftDown(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>于是乎排序算法调整为<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort2</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line"></div><div class="line">    MaxHeap&lt;T&gt; maxheap = MaxHeap&lt;T&gt;(arr,n);</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = n<span class="number">-1</span> ; i &gt;= <span class="number">0</span> ; i-- )</div><div class="line">        arr[i] = maxheap.extractMax();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果比较:<br><img src="http://p3o1bechg.bkt.clouddn.com/FlJdMS-fQ0OPVcvm0xUGYNfaf0pf" alt="-"></p><p>虽然堆排序全方位落后与归并排序，但堆排序的强项在其动态性。</p><h2 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a><strong>空间优化</strong></h2><p>可以看到，上面算法无论怎么处理，都需要在堆中另行开辟 $O(n)$ 级别的空间。但实际上只需要做很小的一个调整，就可以将算法的空间复杂度降为 $O(1)$ 级别</p><p>我们可以想象在一个由数组形成的堆当中，最左边的元素就是其根，换句话最左边的元素是其所有数据的最大值。</p><p>我们可以让最左侧的元素与数组中最后一个元素交换位置，并且收缩堆大小。此时整个数据就会被分为两块。一块可以称为堆区域，另一块可以称为排序区域。</p><p>显然在简单做了一次交换之后，堆区域已经不能满足一个堆的定义。这个时候，只需要对最左侧的元素，执行依次 shiftDown操作 之后，对于堆区域而言，又满足了定义。</p><p>之后，以此往复，当堆的大小为1的时候，也就是整个数组已经是排好了序</p><p>但这里要有一点注意的是，我们使用数据建造的堆，已经不能使用以索引 1 开头的了，而改成从索引0开始。为此我们需要简单的改写一下shiftDown算法,并让他对外可以使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(Item *items, <span class="keyword">int</span> i，<span class="keyword">int</span> count)</span></span>&#123;</div><div class="line">    <span class="comment">//是否有子节点</span></div><div class="line">    <span class="keyword">while</span>(<span class="number">2</span> * i + <span class="number">1</span> &lt;= count )&#123;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * i + <span class="number">1</span>;</div><div class="line">        <span class="comment">//有右节点的同时右节点更大。</span></div><div class="line">        <span class="keyword">if</span>( j + <span class="number">1</span> &lt;= count &amp;&amp; data[j+<span class="number">1</span>] &gt; data[j])</div><div class="line">            j++;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(data[i] &lt; data[j])</div><div class="line">            j = j;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        swap(data[i],data[j]);</div><div class="line">        i = j;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">void heapSort(T arr[], int n)&#123;</div><div class="line"></div><div class="line">    //首先堆整个数组进行建堆操作</div><div class="line">    for( int i = (n-1-1)/2 ; i &gt;= 0 ; i -- )</div><div class="line">        __shiftDown2(arr, n, i);</div><div class="line"></div><div class="line">    //然后取出数组，直至堆区域中没有数据</div><div class="line">    for( int i = n-1; i &gt; 0 ; i-- )&#123;</div><div class="line">        swap( arr[0] , arr[i] );</div><div class="line">        __shiftDown2(arr, i, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="还能优化"><a href="#还能优化" class="headerlink" title="还能优化"></a><strong>还能优化</strong></h2><p>我们在前面两节，无论从时间复杂度还是空间复杂度都进行了优化，但是还有一个比较微小的点，对整个算法速度会有不小的影响。</p><p>简单思考一下，下面这个问题。</p><pre><code>1、交换操作的效率高还是赋值的效率高？2、能否将所有的交换操作换成赋值操作？</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么使用堆&quot;&gt;&lt;a href=&quot;#为什么使用堆&quot; class=&quot;headerlink&quot; title=&quot;为什么使用堆&quot;&gt;&lt;/a&gt;&lt;strong&gt;为什么使用堆&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;堆是一种特别的,同时也是十分有用的数据结构，由其衍生出来的应用有很多，比较
      
    
    </summary>
    
      <category term="2018-3" scheme="http://yoursite.com/categories/2018-3/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>log0000000</title>
    <link href="http://yoursite.com/2018/03/23/log0000000/"/>
    <id>http://yoursite.com/2018/03/23/log0000000/</id>
    <published>2018-03-23T08:30:31.000Z</published>
    <updated>2018-03-23T08:30:31.360Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>快速排序|二路快排、三路排序</title>
    <link href="http://yoursite.com/2018/03/11/quickSort-2/"/>
    <id>http://yoursite.com/2018/03/11/quickSort-2/</id>
    <published>2018-03-11T03:08:07.000Z</published>
    <updated>2018-03-22T09:58:35.992Z</updated>
    
    <content type="html"><![CDATA[<p>初稿 2018.3.11<br>修改 2018.3.22</p><hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h2><p>之前，讨论了一下快速排序的优化问题，主要是在两方面上，当递归的数据规模足够小的时候和递归的数组规模不平衡的问题。</p><p>当数组足够小时，可以采用插入排序进行优化，这是对于所有递归排序算法都可以优化的事情。</p><p>导致数组规模不平均，一部分是数据源的问题，我们使用随机化的方式解决。这次我们依然来说数组规模不平均，之前讨论的在重复数据很少的情况下，但是当重复元素很多的情况下呢？</p><p>假设我们产生了1000000的数据，这些数据范围全部都在 [0,10] 这个区间当中。其中必然拥有及其大量的相同元素。之前为了找到一个合适的位置以合理的区分开 <code>&gt;V</code> 和 <code>&lt;=V</code> 或者是  <code>=&gt;V</code> 和 <code>&lt;V</code>区间， 使他们尽可能的分成平均的两份。但就现在的情况来说，正因为拥有大量的重复元素，无论是让<code>&gt;V区间</code> 还是 <code>&lt;V小于区间</code> 让他们任何一个去包含 <code>=V</code> 这种情况的数据，都将引起不平衡。更何况还是在重复数据如此之多的情况下，随机的那个点，只要有一点不平衡的，都将会导致极度的不平衡现象。这里举一个例子进行实验。 </p><p><img src="http://p3o1bechg.bkt.clouddn.com/Fmyqxki4--Squgf8L8zJaDMDm-K9" alt="1"></p><p>最终，在对含有大量重复元素进行排序时，快速排序退化成了$n^2$级别。</p><p>为了解决如此问题，我们换一种思路来实现，这就是我们的二路排序。</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a><strong>算法实现</strong></h2><p>现在区间分成如下所示两个部分，我们依然用最左侧元素为中心，同样也叫 V 。对于 <code>小于V</code>这部分，用 i 来标示这个区间，i 具体指向这个区间的下一个。同样用 j 来标示 <code>大于V</code>这部分，同样 j 也是指向这个区间的下一个。有一点不同的是，对于<code>小于V</code>这部分来说，是向后延伸，而<code>大于V</code>是向前衍生。</p><p>我们首先从 i 出发，当出现<code>小于V</code>时候，i 直接向后移动，直到遇到不满足<code>小于V时</code>，开始转向 j，当出现<code>大于V</code>时候，j 直接向前移动，直至不满足<code>大于V</code>为止。此时，交换 i 和 j 的位置，以此往复，直到 <code>i &gt; j</code> 时停止。</p><p><img src="http://p3o1bechg.bkt.clouddn.com/Fmt_y-7dHlrp-opofkYRQbVzV5Lq" alt="erlu"></p><p>这里可能会有疑惑，那么为什么不是<code>小于等于V</code> 和 <code>大于等于V</code> 呢？你不妨按照这种情况对 1,0,0,0,0,0,0,0  这样的数组做实行一下，你会发现这样又会出现极度不平衡的现象。</p><p>现在来进行代码实现。总的结构都一样，不同只是 partition 里面的算法不同。这里唯一要一点要注意的是对于 i 和 j 的初值，和定义之间的关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">int</span> _partition2(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</div><div class="line"></div><div class="line">    swap( arr[l] , arr[rand()%(r-l+<span class="number">1</span>)+l] );</div><div class="line">    T v = arr[l];</div><div class="line"></div><div class="line">    <span class="comment">// arr[l+1...i) &lt;= v; arr(j...r] &gt;= v</span></div><div class="line">    <span class="keyword">int</span> i = l+<span class="number">1</span>, j = r;</div><div class="line">    <span class="keyword">while</span>( <span class="literal">true</span> )&#123;</div><div class="line">        <span class="keyword">while</span>( i &lt;= r &amp;&amp; arr[i] &lt; v )</div><div class="line">            i ++;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>( j &gt;= l+<span class="number">1</span> &amp;&amp; arr[j] &gt; v )</div><div class="line">            j --;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>( i &gt; j )</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        swap( arr[i] , arr[j] );</div><div class="line">        i ++;</div><div class="line">        j --;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    swap( arr[l] , arr[j]);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> j;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>结果,最终好了很多。<br><img src="http://p3o1bechg.bkt.clouddn.com/Fpsf6m-2bi8I2Pip8f8ERyuAnSY9" alt="--"></p><h2 id="三路快排"><a href="#三路快排" class="headerlink" title="三路快排"></a><strong>三路快排</strong></h2><p>二路快排来说，是将 <code>=v</code> 这部分的数据平摊到  <code>&lt;v</code> 和 <code>&gt;v</code> ,以保证整个算法，不会递归过深，且退化成$O(n^2)$的情况。总的来说，它是将数据两块来思考的</p><p>对于三路排序来说，会将 <code>=v</code> 这部分的数据单独拿出来作分析，只排列其余两种情况的数组。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a><strong>具体实现</strong></h3><p>依然是拿 V 这个元素作为作为中心，和上面有所不同的是，我们单独将 <code>=v</code>这个部分拿了出来，lt 去标示 <code>&lt;v部分</code>的最后一个元素，gt去标示 <code>&gt;v部分</code>的第一个元素。i 表示正在比较的那一个元素。瞬间划分出了几个区间，小于V 的区间 <strong>[ l+1, lt ]</strong>, 等于V 的区间<strong>[ lt + 1, i )</strong> , 大于V的区间<strong>[ gt, r]</strong> </p><p>所以也会出现三种情况，当 e 等于 v 时，i直接向后移动一个位置即可。当 e 小于 v 的时候，e 与 lt+1(也就是，<code>=v部分</code>的第一个元素)交换位置，更新 i 的位置，进行 + 1 操作。当 e 大于 v 的时候，e 和 gt - 1 的元素交换位置 ，此时i不需要更新。</p><p><img src="http://p3o1bechg.bkt.clouddn.com/FvlvGAQPsXi2lcutWXEJzoZFgLkx" alt="-"></p><p>因为最后需要分为两个值，所以结构稍微变更一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort3Ways</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line"></div><div class="line">    srand(time(<span class="literal">NULL</span>));</div><div class="line">    __quickSort3Ways( arr, <span class="number">0</span>, n<span class="number">-1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> __quickSort3Ways(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 对于小规模数组, 使用插入排序进行优化</span></div><div class="line">    <span class="keyword">if</span>( r - l &lt;= <span class="number">15</span> )&#123;</div><div class="line">        insertionSort(arr,l,r);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot</span></div><div class="line">    swap( arr[l], arr[rand()%(r-l+<span class="number">1</span>)+l ] );</div><div class="line"></div><div class="line">    T v = arr[l];</div><div class="line"></div><div class="line">    <span class="keyword">int</span> lt = l;     <span class="comment">// arr[l+1...lt] &lt; v</span></div><div class="line">    <span class="keyword">int</span> gt = r + <span class="number">1</span>; <span class="comment">// arr[gt...r] &gt; v</span></div><div class="line">    <span class="keyword">int</span> i = l+<span class="number">1</span>;    <span class="comment">// arr[lt+1...i) == v</span></div><div class="line">    <span class="keyword">while</span>( i &lt; gt )&#123;</div><div class="line">        <span class="keyword">if</span>( arr[i] &lt; v )&#123;</div><div class="line">            swap( arr[i], arr[lt+<span class="number">1</span>]);</div><div class="line">            i ++;</div><div class="line">            lt ++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( arr[i] &gt; v )&#123;</div><div class="line">            swap( arr[i], arr[gt<span class="number">-1</span>]);</div><div class="line">            gt --;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123; <span class="comment">// arr[i] == v</span></div><div class="line">            i ++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>最后结果，你会发现三路快排在大量重复元素中，明显由于其他两个算法，但在其他情况下，会略差一点，但都维持在 $log^n$级别。</p><p>两种排序，各有优劣，具体场景需要酌情选取。<br><img src="http://p3o1bechg.bkt.clouddn.com/FpBnQwMaduQ43fnIB-jQyuXyovwT" alt="-"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;初稿 2018.3.11&lt;br&gt;修改 2018.3.22&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;之前，讨论了一下快速排序
      
    
    </summary>
    
      <category term="2018-3" scheme="http://yoursite.com/categories/2018-3/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>log019</title>
    <link href="http://yoursite.com/2018/03/10/log019/"/>
    <id>http://yoursite.com/2018/03/10/log019/</id>
    <published>2018-03-10T14:14:24.000Z</published>
    <updated>2018-03-11T01:15:19.407Z</updated>
    
    <content type="html"><![CDATA[<p>没有完成今天的任务，对这一周总的来说，大的事情都已经做完。也算是新一年的准备工作已经完毕。</p><p>注意到自己只有关于时间的分配，而没有关于精力的分配。一天24小时用完就去睡觉即可，那精力用完还有时间应该去干什么？一个值得思考的问题</p><p>还有一天，第一周就完成了。抓紧时间冲刺一下吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;没有完成今天的任务，对这一周总的来说，大的事情都已经做完。也算是新一年的准备工作已经完毕。&lt;/p&gt;
&lt;p&gt;注意到自己只有关于时间的分配，而没有关于精力的分配。一天24小时用完就去睡觉即可，那精力用完还有时间应该去干什么？一个值得思考的问题&lt;/p&gt;
&lt;p&gt;还有一天，第一周就完
      
    
    </summary>
    
      <category term="2018-3" scheme="http://yoursite.com/categories/2018-3/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log018</title>
    <link href="http://yoursite.com/2018/03/10/log018/"/>
    <id>http://yoursite.com/2018/03/10/log018/</id>
    <published>2018-03-10T00:35:12.000Z</published>
    <updated>2018-03-10T00:35:53.555Z</updated>
    
    <content type="html"><![CDATA[<p>算是第一天，开了一个好头。</p><p>如果非要说缺点，那就是在休息上面花费了过多的时间。那些时间都是可以拿来做更重要的事情的。</p><p>运动虽然够了，但是水分严重缺失。</p><p>晚饭目前应该想点办法去高效的解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;算是第一天，开了一个好头。&lt;/p&gt;
&lt;p&gt;如果非要说缺点，那就是在休息上面花费了过多的时间。那些时间都是可以拿来做更重要的事情的。&lt;/p&gt;
&lt;p&gt;运动虽然够了，但是水分严重缺失。&lt;/p&gt;
&lt;p&gt;晚饭目前应该想点办法去高效的解决。&lt;/p&gt;

      
    
    </summary>
    
      <category term="2018-3" scheme="http://yoursite.com/categories/2018-3/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>快速排序|优化(一)</title>
    <link href="http://yoursite.com/2018/03/09/quickSortAdvance/"/>
    <id>http://yoursite.com/2018/03/09/quickSortAdvance/</id>
    <published>2018-03-09T02:39:34.000Z</published>
    <updated>2018-03-11T03:09:07.599Z</updated>
    
    <content type="html"><![CDATA[<p>像往常一样，在了解了算法的基本思想之后。我们来看看有哪些地方值得我们优化</p><h2 id="第一个优化"><a href="#第一个优化" class="headerlink" title="第一个优化"></a>第一个优化</h2><p>因为在上一篇中实现的是一个递归算法，对于所有的递归算法而言，当数组规模变得足够小的时候，我们可以采用插入排序进行优化，和归并排序的第一个优化相同，具体去看<a href="https://jinfangzhang.github.io/2018/02/08/mergesSortAdvance/" target="_blank" rel="external">那一篇文章</a></p><h2 id="第二个优化"><a href="#第二个优化" class="headerlink" title="第二个优化"></a>第二个优化</h2><p>这里我们主要来解释一下第二个优化。都知道归并排序和快速排序都使用递归算法进行实现。归并排序每次向下递归，数组规模会被稳定的平分成两份，最终会有 $log_2^n$ 层，它被分成的规模永远是恒定的。而对于快速排序来，他同样也会被分为两块，但是被分的大小完全是随机，不均等的两块。想一种最糟糕的情况，对于一个近乎有序的数组，这个算法瞬间将退化成 $n^2$ 级别的算法。</p><p>要解决这种情况也很简单，使分界点更加随机，在快速排序中，分界点也就是每一块最左端的元素。我们随机和其他元素交换一下位置即可。</p><p>虽然对于最坏情况依然会退化成$n^2$级别，但能保证在99.999%的情况下，依然是$log^n$级别的算法。</p><p>具体代码就不贴了～～。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;像往常一样，在了解了算法的基本思想之后。我们来看看有哪些地方值得我们优化&lt;/p&gt;
&lt;h2 id=&quot;第一个优化&quot;&gt;&lt;a href=&quot;#第一个优化&quot; class=&quot;headerlink&quot; title=&quot;第一个优化&quot;&gt;&lt;/a&gt;第一个优化&lt;/h2&gt;&lt;p&gt;因为在上一篇中实现的是一个递
      
    
    </summary>
    
      <category term="2018-3" scheme="http://yoursite.com/categories/2018-3/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>log017</title>
    <link href="http://yoursite.com/2018/03/09/log017/"/>
    <id>http://yoursite.com/2018/03/09/log017/</id>
    <published>2018-03-09T01:39:00.000Z</published>
    <updated>2018-03-09T01:39:44.115Z</updated>
    
    <content type="html"><![CDATA[<p>开学一周，基本给假期收了一个尾。中断了好久的日志，从今天开始要一天不落。</p><p>相信经过一年的学习，英语可以达到与人交流的水平～～</p><p>晚上基本 11 点之后就不干什么活了，看会书，等到 12 点左右就睡觉，保证每天 7-8 小时的睡眠时间。早上7点起床，看会得到就准备开始今天的生活。</p><p>每天的早餐也列入计划当中。</p><p>总的来说，一切都步入正轨。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开学一周，基本给假期收了一个尾。中断了好久的日志，从今天开始要一天不落。&lt;/p&gt;
&lt;p&gt;相信经过一年的学习，英语可以达到与人交流的水平～～&lt;/p&gt;
&lt;p&gt;晚上基本 11 点之后就不干什么活了，看会书，等到 12 点左右就睡觉，保证每天 7-8 小时的睡眠时间。早上7点起床，
      
    
    </summary>
    
      <category term="2018-3" scheme="http://yoursite.com/categories/2018-3/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log016</title>
    <link href="http://yoursite.com/2018/03/05/log016/"/>
    <id>http://yoursite.com/2018/03/05/log016/</id>
    <published>2018-03-05T00:55:27.000Z</published>
    <updated>2018-03-05T00:56:04.298Z</updated>
    
    <content type="html"><![CDATA[<p>开学第一周要给假期做一个收尾工作，主要包括，数据结构2篇文章，学校相关的两篇文章，一篇自我成长记录的日记。</p><p>及其明确安排自己的时间，并且确定在这个学期中，将要完成的东西。</p><p>重新提醒一下，自己上午的时间安排，是以1个小时为单位，下午是以1.5个小时为单位，穿插学习得到和英语的时间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开学第一周要给假期做一个收尾工作，主要包括，数据结构2篇文章，学校相关的两篇文章，一篇自我成长记录的日记。&lt;/p&gt;
&lt;p&gt;及其明确安排自己的时间，并且确定在这个学期中，将要完成的东西。&lt;/p&gt;
&lt;p&gt;重新提醒一下，自己上午的时间安排，是以1个小时为单位，下午是以1.5个小时
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>QucikSort</title>
    <link href="http://yoursite.com/2018/03/03/quciksort-1/"/>
    <id>http://yoursite.com/2018/03/03/quciksort-1/</id>
    <published>2018-03-03T03:29:59.000Z</published>
    <updated>2018-03-09T01:23:35.415Z</updated>
    
    <content type="html"><![CDATA[<p>2018.3.3 初稿<br>2018.3.9 修改</p><hr><p>快速排序，也叫做轴点排序。它和归并排序都属于分治算法，并且算法复杂度都在 $nlog^n$ 这个级别。和之前的插入排序、选择排序、归并排序，还有之后会说到的堆排序，其中每一个都是非常有代表性的思想，不管怎么说都应该去熟练的掌握这些思想。</p><p>同一种算法思想，每种不同的定义都意味着一种不太相同的解法，但这只区分在具体实现层次，对于更高层级的算法思想内还是相同的。随着算法复杂度的增加，定义的重要性也会随之增加。简单的算法稍加思考就可以得出结论，甚至都没有感觉到定义的存在，但在之后的算法中，会越来越感到定义的重要性。它不仅仅可以使你的思路明确，还会简化很多问题。</p><p>下面去具体感受一下快速排序的思想</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a><strong>基本思想</strong></h2><blockquote><p> 将要排序的数据将会分割成独立的两部分，对于要排序元素的前面的元素都比它小，其后面都比它大。</p></blockquote><p>更明确点说，是经过排序之后，要排序的元素将会放置到他应该放的位置，同时在这个元素前面都是比它小的元素，在它后面都是比它大的元素。之后对分出来的两部分再进行如此算法。把这个过程叫做 <strong>partition</strong></p><p>我们需要一个变量 v 来记录当前排序的元素，也就是说排序结束后一定会放到正确位置上的元素。还需要一个变量 j 来区分，比 v 小的部分和比 v 大的部分之间的分界点。最后用变量 i 来确定当前正在比较的对象。基本概念结合下图来理解</p><p><img src="http://p3o1bechg.bkt.clouddn.com/Fo0AqY1xFLGG-4gjyjvEFB-P6BLc" alt="图片"></p><p>我们维护了<strong>[ l + 1, j ]</strong> 和 <strong>[ j + 1, i )</strong> 这两个范围。当正在比较的对象 <strong>大于</strong> v 时，仅需要将 i 往后移动一个位置，将其归入<strong>[ j + 1, i )</strong>这个范文 。当 <strong>小于</strong> v 时，我们需要和 j + 1 位置上的元素换一下位置，并且更新 j 的位置，进行 + 1 操作。直到最后，所有元素比较完成之后，我们只需要和 j 位置的元素交换一下位置。</p><p><img src="http://p3o1bechg.bkt.clouddn.com/FkNkkW8niJQuEp2UAZz-Ne2gz7tl" alt="finish"></p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a><strong>算法实现</strong></h2><p>定义 quickSort，它将对大小为 n 的 arr 数组进行排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(T arr[], <span class="keyword">int</span> n )</span></span>&#123;</div><div class="line">    __quickSort(arr, <span class="number">0</span> , n - <span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>定义 __quickSort 它将排序 arr数组 [l, r] 范围内的数据,其内部首先对递归到底的数据进行处理,然后调用 partition 算法，我们默认总是将 位置 为 l 的元素作为排序元素，然后返回这个元素的正确位置 p 。接下来，对范围 [ l , p - 1 ] 和 [ p + 1 , r ] 进行进一步排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> __quickSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</div><div class="line">    <span class="keyword">if</span>( l &gt;= r )</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> p = __partition(arr, l, r);</div><div class="line">    __quickSort(arr, l, p<span class="number">-1</span>);</div><div class="line">    __qucikSort(arr, p+<span class="number">1</span>, r);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>定义 partition ，是对 [ l , r ] 这个区间进行排序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </div><div class="line"><span class="keyword">int</span> __partition(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</div><div class="line">    T v = arr[l];</div><div class="line">    <span class="keyword">int</span> j = l;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(arr[i] &gt; v)&#123;</div><div class="line">            <span class="comment">//什么都不做</span></div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            j++</div><div class="line">            swap(arr[j], arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    swap(arr[l], arr[j]);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> j ;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>来和我们已经优化过的归并排序作一下比较，不同机器结果可能会有比较大的差异，不过我们后续还是会继续优化快速排序的。</p><p><img src="http://p3o1bechg.bkt.clouddn.com/FowPOx1pPvtaCDsparO7LlRcQrdb" alt="result"></p><hr><p>从理论上来说，QuickSort 要比 MergeSort 快 30% 左右，但是结果并非如此，我多次尝试结果都没有太大的变化，最后找到问题所在，是 <strong>swap函数</strong>执行时间过长，这会说到C++的泛型问题，在之后会写一篇文章，这里只需手动写一个swap函数即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">T tmp = arr[j];</div><div class="line">arr[j] = arr[i];</div><div class="line">arr[i] = tmp;</div></pre></td></tr></table></figure></p><p>修改之后的结果是（好了很多）<br><img src="http://p3o1bechg.bkt.clouddn.com/FuaQJ1sKjj27owKi6FhEz7L0PbP5" alt="fixed"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018.3.3 初稿&lt;br&gt;2018.3.9 修改&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;快速排序，也叫做轴点排序。它和归并排序都属于分治算法，并且算法复杂度都在 $nlog^n$ 这个级别。和之前的插入排序、选择排序、归并排序，还有之后会说到的堆排序，其中每一个都是非常有代表性的思想
      
    
    </summary>
    
      <category term="2018-3" scheme="http://yoursite.com/categories/2018-3/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>go|面向「对象」</title>
    <link href="http://yoursite.com/2018/03/01/go-object-oriented/"/>
    <id>http://yoursite.com/2018/03/01/go-object-oriented/</id>
    <published>2018-03-01T03:06:28.000Z</published>
    <updated>2018-03-01T07:40:19.032Z</updated>
    
    <content type="html"><![CDATA[<p>go语言仅支持封装，不支持继承和多态，所以go语言没有class 只有struct</p><h2 id="结构的定义"><a href="#结构的定义" class="headerlink" title="结构的定义"></a><strong>结构的定义</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> treeNode <span class="keyword">struct</span>&#123;</div><div class="line">    left, right *treeNode</div><div class="line">    value <span class="keyword">int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="结构的创建"><a href="#结构的创建" class="headerlink" title="结构的创建"></a><strong>结构的创建</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//空值创建</span></div><div class="line"><span class="keyword">var</span> root treeNode</div><div class="line">r := <span class="built_in">new</span>(treeNode)</div><div class="line"></div><div class="line"><span class="comment">//带值</span></div><div class="line">root1 := treeNode&#123;value: <span class="number">3</span>&#125;</div><div class="line">root2 := treeNode&#123;<span class="number">5</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">//通过slice的创建</span></div><div class="line">nodes := []treeNode&#123;</div><div class="line">    &#123;value: <span class="number">3</span>&#125;,</div><div class="line">    &#123;&#125;,</div><div class="line">    &#123;<span class="number">6</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>为结构定义方法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node treeNode)</span> <span class="title">print</span><span class="params">()</span></span>&#123;</div><div class="line">    fmt.Println(node.value)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其实这和普通方法基本都是一样的，而且依旧是传值,如果有下面这段代码，他是不可以改变结构体内部的数据的，只能通过指针的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不可以改变</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node treeNode)</span> <span class="title">setValue</span><span class="params">(value <span class="keyword">int</span>)</span></span>&#123;</div><div class="line">    node.value = value</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//可以改变</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *treeNode)</span> <span class="title">setValue</span><span class="params">(value <span class="keyword">int</span>)</span></span>&#123;</div><div class="line">    node.value = value</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h2><p>struct 没有构造函数的说法</p><p>方法中可以返回局部变量的地址</p><p>无论是地址还是结构，一律使「 . 」来访问成员</p><p>只有使用指针才可以改变结构内容</p><p><strong>nil 指针也可以调用方法</strong></p><p>##<strong>封装</strong></p><ul><li><p><strong>针对包来说，首字母大写代表 public，首字母小写代表 private</strong></p></li><li><p><strong>每个目录一个包，包名不和目录名要一样，但每个目录只能有一个包。main包 包含可执行入口</strong></p></li><li><p><strong>为结构定义的方法必须放在同一个包内，但是可以是不同的文件</strong></p></li></ul><h2 id="如果扩展一个已有的类型"><a href="#如果扩展一个已有的类型" class="headerlink" title="如果扩展一个已有的类型"></a><strong>如果扩展一个已有的类型</strong></h2><p>两种方法，一种定义别名，另一种是定义组合</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">type</span> myTreeNode <span class="keyword">struct</span> &#123;</div><div class="line">    node *tree.Node</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myNode *myTreeNode)</span> <span class="title">postOrder</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> myNode == <span class="literal">nil</span> || myNode.node == <span class="literal">nil</span>&#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    left := myTreeNode&#123;myNode.node.Left&#125;</div><div class="line">    left.postOrder()</div><div class="line">    right := myTreeNode&#123;myNode.node.Right&#125;</div><div class="line">    right.postOrder()</div><div class="line">    myNode.node.Print()</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Queue []<span class="keyword">int</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Push</span><span class="params">(v <span class="keyword">int</span>)</span></span>&#123;</div><div class="line">    *q = <span class="built_in">append</span>(*q,v)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span>&#123;</div><div class="line">    head := (*q)[<span class="number">0</span>]</div><div class="line">    *q = (*q)[<span class="number">1</span>:]</div><div class="line">    <span class="keyword">return</span> head</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(*q) == <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="GOPATH-环境变量"><a href="#GOPATH-环境变量" class="headerlink" title="GOPATH 环境变量"></a>GOPATH 环境变量</h2><p>默认在 ～/go(unix, linux)</p><p>官方推荐: 所有项目和第三库都放在同一个 GOPATH 下面</p><p>也可以将每个项目放在不同的 GOPATH 中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;go语言仅支持封装，不支持继承和多态，所以go语言没有class 只有struct&lt;/p&gt;
&lt;h2 id=&quot;结构的定义&quot;&gt;&lt;a href=&quot;#结构的定义&quot; class=&quot;headerlink&quot; title=&quot;结构的定义&quot;&gt;&lt;/a&gt;&lt;strong&gt;结构的定义&lt;/strong&gt;
      
    
    </summary>
    
      <category term="2018-3" scheme="http://yoursite.com/categories/2018-3/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go|内建容器</title>
    <link href="http://yoursite.com/2018/02/28/go-inner-container-1/"/>
    <id>http://yoursite.com/2018/02/28/go-inner-container-1/</id>
    <published>2018-02-28T04:24:10.000Z</published>
    <updated>2018-03-01T01:19:10.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><p>数组是值类型，也就是说传递的时候，是通过拷贝的方式，进行传递</p><h3 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a><strong>定义数组</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span>  </div><div class="line">arr2 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;   <span class="comment">//如果使用 : 去定义数组，那么必须赋初值</span></div><div class="line">arr3 := [...]<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;    <span class="comment">//让系统自己识别，有几个数字</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> grid [<span class="number">4</span>][<span class="number">5</span>]<span class="keyword">int</span>      <span class="comment">//定义多维数组</span></div></pre></td></tr></table></figure><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a><strong>遍历数组</strong></h3><p>最基本的形式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</div><div class="line">    fmt.Println(arr[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用 <strong>range</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i , v : = <span class="keyword">range</span> arr &#123;   <span class="comment">//i 是数组的下表， v 是数组的值</span></div><div class="line">    fmt.Println(i, v)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><ul><li><p><strong>[10]int</strong> 和 <strong>[20]int</strong> 是不同的类型</p></li><li><p>[]int 和 [5]int 代表完全不同的含义，前者表示切片，后者才表示数组</p></li><li><p>数组是值类型</p></li><li><p>它不像C，数组头指针并不代表数组的地址</p></li></ul><p><strong>go语言中不直接使用数组</strong></p><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a><strong>Slice</strong></h2><h3 id="Slice-是什么"><a href="#Slice-是什么" class="headerlink" title="Slice 是什么"></a><strong>Slice 是什么</strong></h3><p>Slice 是 数组 的一个 View<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;  <span class="comment">//数组</span></div><div class="line">s := arr[<span class="number">2</span>:<span class="number">6</span>]   <span class="comment">//slice     s =&gt; 2,3,4,5  [2,6)</span></div></pre></td></tr></table></figure></p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;  <span class="comment">//数组</span></div><div class="line">s := arr[<span class="number">2</span>:<span class="number">6</span>]   <span class="comment">//slice     s =&gt; 2,3,4,5  [2,6)</span></div><div class="line">s1 := arr[:<span class="number">6</span>]   <span class="comment">//slice     s =&gt; 0,1,2,3,4,5  [0,6)</span></div><div class="line">s2 := arr[<span class="number">2</span>:]   <span class="comment">//slice     s =&gt; 2,3,4,5,6,7,8  [2, len(arr) )</span></div><div class="line">s3 := arr[:]   <span class="comment">//slice     s =&gt; 0,1,2,3,4,5,6,7,8  [0,len(arr) )</span></div></pre></td></tr></table></figure><p>s[0] 代表当前Slice 的第一个数组</p><p><strong>可以通过修改Slice中的值去修改原来数组当中的值</strong></p><h3 id="进一步操作"><a href="#进一步操作" class="headerlink" title="进一步操作"></a><strong>进一步操作</strong></h3><p>下面的Slice 的都是投影同一个数组的arr<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;  <span class="comment">//数组</span></div><div class="line">s := arr[:]     <span class="comment">//  0,1,2,3,4,5,6,7,8</span></div><div class="line">s = s[:<span class="number">5</span>]     <span class="comment">//    0,1,2,3,4</span></div><div class="line">s = s[<span class="number">2</span>:]     <span class="comment">//    2,3,4</span></div></pre></td></tr></table></figure></p><p>试图理解一下，下面这些代码<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;  <span class="comment">//数组</span></div><div class="line">s1 := arr[<span class="number">2</span>,<span class="number">6</span>]  <span class="comment">//2,3,4,5</span></div><div class="line"><span class="comment">//s1 只有四个数字</span></div><div class="line">s2 := s1[<span class="number">3</span>,<span class="number">5</span>]   <span class="comment">//5,6   s[3]    s[4]</span></div><div class="line">fmt.Println(s1[<span class="number">4</span>]   <span class="comment">//error 直接取是取不出来的</span></div></pre></td></tr></table></figure></p><p>为了正确理解上面代码，我们有必要深入了解一下slice</p><p><img src="http://p3o1bechg.bkt.clouddn.com/FnsLz75IFKrn5b9r1Mc6Ji94k0IP" alt="slice"></p><ul><li><p>slice中一个ptr的指针，指向slice开头的那一个元素</p></li><li><p>len是slice的大小，通过下标的方式，只能访问到len以内的元素</p></li><li><p>cap是从slice第一个元素到投影数组的最后一个元素的大小，在cap范围内的，可以通过再切片来访问到</p></li></ul><p><strong>为此，我们可以通过 len() 和 cap() 方法获取该slice的值</strong></p><h3 id="向Slice添加元素"><a href="#向Slice添加元素" class="headerlink" title="向Slice添加元素"></a><strong>向Slice添加元素</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</div><div class="line">s1 := arr[<span class="number">2</span>:<span class="number">6</span>]</div><div class="line">s2 := s1[<span class="number">3</span>:<span class="number">5</span>]</div><div class="line">s3 := <span class="built_in">append</span>(s2,<span class="number">10</span>)</div><div class="line">s4 := <span class="built_in">append</span>(s3,<span class="number">11</span>)</div><div class="line">s5 := <span class="built_in">append</span>(s4,<span class="number">12</span>)</div></pre></td></tr></table></figure><p>进过上面代码之后，arr最后会是多少</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">s1  <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span></div><div class="line">s2  <span class="number">5</span>,<span class="number">6</span></div><div class="line">s3  <span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span></div><div class="line">s4  <span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">11</span></div><div class="line">s5  <span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span></div><div class="line"></div><div class="line">arr <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span></div></pre></td></tr></table></figure><p>s4,s5 当中的 11 和 12 去哪里了？</p><p>他们的视图已经不是原来的arr，而是一个新数组，因为已经超过了 s2 的 cap，系统重新开一个更大cap的数组</p><h3 id="slice的创建"><a href="#slice的创建" class="headerlink" title="slice的创建"></a><strong>slice的创建</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s []<span class="keyword">int</span> <span class="comment">//len=0 cap=0   s = nil</span></div><div class="line"></div><div class="line"><span class="comment">//先建立了一个arr，他的值为2,4,6,8</span></div><div class="line"><span class="comment">//再创建了一个slice的视图</span></div><div class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;</div><div class="line"></div><div class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>)   <span class="comment">//len(s2) = 16 cap(s2) = 16</span></div><div class="line"></div><div class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>,<span class="number">32</span>) <span class="comment">//len(s3) = 16 cap(s3) = 32</span></div></pre></td></tr></table></figure><h3 id="slice-的复制"><a href="#slice-的复制" class="headerlink" title="slice 的复制"></a><strong>slice 的复制</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">copy(s2,s1)//把s1的内容拷贝到s2当中</div><div class="line">//s2  [2,4,6,8,0,0,0,0,0,0,0,0,0,0,0,0]</div></pre></td></tr></table></figure><h3 id="slice-的-删除"><a href="#slice-的-删除" class="headerlink" title="slice 的 删除"></a><strong>slice 的 删除</strong></h3><p>系统没有内建函数，但是我们可以通过append来</p><p>如果我们想删除 s2 中的8的话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// s2   [2,4,6,8,0,0,0,0,0,0,0,0,0,0,0,0]</div><div class="line">append(s2[:3], s2[4:])</div></pre></td></tr></table></figure></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h2><p>go语言的 nil 是可以参与运算的</p><p>这个Map是一个HashMap</p><h3 id="定义map"><a href="#定义map" class="headerlink" title="定义map"></a><strong>定义map</strong></h3><p>定义格式：map[K]V, map[K1]map[K2]V</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">m := map[string]string &#123;</div><div class="line">    &quot;name&quot;: &quot;jianran&quot;,</div><div class="line">    &quot;sex&quot;: &quot;nan&quot;,</div><div class="line">    &quot;age&quot;: &quot;20&quot;,</div><div class="line">&#125;</div><div class="line"></div><div class="line">//定义空map</div><div class="line">var m2 map[string]int       m2 == nil </div><div class="line"></div><div class="line">m3 := make(map[string]int)  m3 == empty map</div></pre></td></tr></table></figure><h3 id="遍历map"><a href="#遍历map" class="headerlink" title="遍历map"></a><strong>遍历map</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</div><div class="line">    fmt.Println(k, v)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="getting-value"><a href="#getting-value" class="headerlink" title="getting value"></a><strong>getting value</strong></h3><p>一般情况<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name := m[<span class="string">"name"</span>]</div></pre></td></tr></table></figure></p><p>如果我们的键在map当中并没有会怎么样？<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">n := m[<span class="string">"nme"</span>]</div></pre></td></tr></table></figure></p><p>它并不会报错，会打一个空串。那么如果是这样，我们应该如何判断这个 key 是否存在呢？<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">n, ok := m[<span class="string">"nme"</span>]   <span class="comment">//如果 OK 的 变量是 true 说明存在，为 false 说明不存在</span></div></pre></td></tr></table></figure></p><h3 id="Deleting-value"><a href="#Deleting-value" class="headerlink" title="Deleting value"></a><strong>Deleting value</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">delete</span>(m, <span class="string">"name"</span>)   <span class="comment">//将会删除 m 中 键为 name 的这对键值对</span></div></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a><strong>注意</strong></h3><p>map使用哈希表，必须可以比较相等</p><p>除了 slice，map，function的内建类型都可以作为key</p><p>struct 类型不包括上述字段，也可以作为key</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;&lt;strong&gt;数组&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;数组是值类型，也就是说传递的时候，是通过拷贝的方式，进行传递&lt;/p&gt;
&lt;h3 id=&quot;定义数组&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>extends和implements的一些思考</title>
    <link href="http://yoursite.com/2018/02/27/extends%E5%92%8Cimplements%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2018/02/27/extends和implements的一些思考/</id>
    <published>2018-02-27T09:33:51.000Z</published>
    <updated>2018-03-10T01:14:13.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="extends-amp-implements"><a href="#extends-amp-implements" class="headerlink" title="extends &amp; implements"></a><strong>extends &amp; implements</strong></h2><p>继承和接口，在 java 中简单来说就是 extend 和 implements。继承从语义上来说，就是会得到父类的一些东西（方法，参数），无论你是否愿意。而接口，它本身就是空的，并不会得到什么东西，我画了个图来更加的感受一下</p><p><figure class="half"><br>    <img src="http://p3o1bechg.bkt.clouddn.com/FnaG4YHoc8Gei1MR50NsTqI4fCWO"><br>    <img divstyle="float:none;clear:both;" src="http://p3o1bechg.bkt.clouddn.com/FoJK7B-8HZD49aOVrEnIZIQ-tHAr"><br></figure><br>当我们使用 extends 的时候，子类会得到一些具体实现的代码。这样做有好有坏，好的地方上，我们可以提高的代码的复用性，使我们不需要去重复的去写一些代码。坏的地方，就是增加了耦合，强制我们去依赖细节。</p><p>使用 implements 的时候，有点反过来的味道。我们操作的永远会是interface或者 abstract 的子类。也就是在抽象层次上进行操作。这样我们会更少的去依赖细节，增加可拓展性。</p><p>extends 也可以理解成面向抽象进行操作，只不过它拥有一些细节而已，extends 和 implements 都可以看成面向抽象，具体其实就要你的具体业务了。</p><p>在写代码的过程中，时刻要应对的变化。我们所创造的系统应该更加的容易的扩展，而不是每次都去修改原先的代码，这样对系统无论是安全性还是维护成本来说，都是应该尽量避免的行为。虽然无法预测未来的事情，但我们至少可以掌控当下写的内容。</p><h2 id="尽量遵循一些原则"><a href="#尽量遵循一些原则" class="headerlink" title="尽量遵循一些原则"></a><strong>尽量遵循一些原则</strong></h2><p>在设计写代码时，我们应该尽可能的避免直接依赖细节，尽可能的操作抽象，尤其是在写框架的时候。我们<strong>应该针对接口编程，而不是针对特定的实现</strong>。</p><p>应该去尽量<strong>使用组合</strong>，这里举一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Class Duck&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</div><div class="line">        ....    <span class="comment">// 具体代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果想去修改fly中的方法，除了覆写别无它法，而且覆写的成本会很高，如果换一种方式。我们只需要去改变Flayable的变量值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Class Duck&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> Flyable flyBehavior</span></div><div class="line">    <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span>&#123;</div><div class="line">        flyBehavior.fly();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>除以上以外，我们应该去<strong>隔离变化</strong>，其实从某种意义上来说面向抽象是就是一种隔离变化的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;extends-amp-implements&quot;&gt;&lt;a href=&quot;#extends-amp-implements&quot; class=&quot;headerlink&quot; title=&quot;extends &amp;amp; implements&quot;&gt;&lt;/a&gt;&lt;strong&gt;extends &amp;a
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Java编程思想" scheme="http://yoursite.com/tags/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>go|基本语法糖</title>
    <link href="http://yoursite.com/2018/02/27/go_syntactic_sugar1/"/>
    <id>http://yoursite.com/2018/02/27/go_syntactic_sugar1/</id>
    <published>2018-02-27T02:55:24.000Z</published>
    <updated>2018-03-01T01:19:07.591Z</updated>
    
    <content type="html"><![CDATA[<p>go语言中变量的声名和很多语言都是反着来的,而且go语言只有值传递</p><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a><strong>定义变量</strong></h2><p>go语言是强类型<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//go语言会动态的识别类型</span></div><div class="line"><span class="keyword">var</span> aa</div><div class="line"><span class="keyword">var</span> aa = <span class="number">3</span></div><div class="line"><span class="keyword">var</span> a, b, c, s = <span class="number">3</span>, <span class="number">4</span>, <span class="literal">true</span>, <span class="string">"def"</span></div><div class="line"> </div><div class="line"></div><div class="line"><span class="keyword">var</span> ss <span class="keyword">string</span></div><div class="line"><span class="keyword">var</span> cc ww <span class="keyword">string</span></div><div class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span> = <span class="number">3</span>, <span class="number">4</span></div><div class="line"></div><div class="line"><span class="comment">//定义包内部变量，不可以使用 `:` 来定义变量</span></div><div class="line">bb := <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment">//扎堆定义变量</span></div><div class="line"><span class="keyword">var</span> &#123;</div><div class="line">    cc = <span class="number">4</span></div><div class="line">    ee = <span class="number">6</span></div><div class="line">    ff = <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a><strong>枚举</strong></h2><p>go语言没有像java一样的enum，但可以通过 const 关键字来(const 的意思是不可改变的)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//类型一    手动输入</span></div><div class="line"><span class="keyword">const</span>(</div><div class="line">    cpp = <span class="number">0</span></div><div class="line">java = <span class="number">1</span></div><div class="line">python = <span class="number">2</span></div><div class="line">golang = <span class="number">3</span></div><div class="line">)</div><div class="line"><span class="comment">//类型二    不想手动输入，可以使用iota 自增长</span></div><div class="line"><span class="keyword">const</span>(</div><div class="line">    cpp = <span class="literal">iota</span>  <span class="comment">//0</span></div><div class="line">    java        <span class="comment">//1</span></div><div class="line">    python      <span class="comment">//2</span></div><div class="line">    golang      <span class="comment">//3</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">//类型三    对于iota的进一步使用</span></div><div class="line"><span class="comment">//b,kb,mb,gb,tb,pb</span></div><div class="line"><span class="keyword">const</span>(</div><div class="line">b = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)    <span class="comment">//1</span></div><div class="line">kb                      <span class="comment">//1024</span></div><div class="line">mb                      <span class="comment">//1048576</span></div><div class="line">gb                      ...</div><div class="line">tb</div><div class="line">pb</div><div class="line">)</div></pre></td></tr></table></figure><h2 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a><strong>Branch</strong></h2><p>go语言对于语句像 分支语句和循环语句尽量，省略括号</p><p>go 语言 的 nil 相当于 其他语言的 NULL、null，但 nil 还有其他特别的地方</p><h3 id="If"><a href="#If" class="headerlink" title="If"></a><strong>If</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//普通</span></div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</div><div class="line">    ...</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>语言在条件判断的基础上还加入了向for语言的赋初值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> a:=<span class="number">0</span>; a&lt;<span class="number">10</span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a><strong>Switch</strong></h3><p>依然保留一般性的语法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//普通</span></div><div class="line"><span class="keyword">switch</span> op &#123;</div><div class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</div><div class="line"><span class="keyword">return</span> a + b</div><div class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</div><div class="line"><span class="keyword">return</span> a - b</div><div class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</div><div class="line"><span class="keyword">return</span> a / b</div><div class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</div><div class="line"><span class="keyword">return</span> a * b</div><div class="line"><span class="keyword">default</span>:</div><div class="line"><span class="built_in">panic</span>(<span class="string">"unsupported operation:"</span> + op)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>switch语句相应做了扩展。语句可以在case当中直接写条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">g:= &quot;&quot;</div><div class="line">switch &#123;</div><div class="line">    case score &lt; 0 || score &gt; 100:</div><div class="line">    panic(fmt.Sprintf(</div><div class="line">    &quot;Wrong score: %d&quot;, score))</div><div class="line">    case score &lt; 60:</div><div class="line">    g = &quot;F&quot;</div><div class="line">    case score &lt; 80:</div><div class="line">    g = &quot;C&quot;</div><div class="line">    case score &lt; 90:</div><div class="line">    g = &quot;B&quot;</div><div class="line">    case score &lt;= 100:</div><div class="line">    g = &quot;A&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="Loop"><a href="#Loop" class="headerlink" title="Loop"></a><strong>Loop</strong></h2><p>go没有while语句，但是 for 已足以</p><p>基本形式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ; ; &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果没有任何条件，就相当一个死循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//死循环</div><div class="line">for&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果只有一个判断条件，可以省略两个冒号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for n &lt; 10 &#123;</div><div class="line">fmt.Print(n)</div><div class="line">n++</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a><strong>Function</strong></h2><p>go语言的函数可以返回多个返回值，同时声明方式也是反着的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回一个值</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">eval</span><span class="params">(a,b <span class="keyword">int</span>, op <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">返回多个值</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="params">(q,r <span class="keyword">int</span>)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> a / b,a % b</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>go语言是支持函数式编程的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">(op <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>,<span class="title">a</span>, <span class="title">b</span> <span class="title">int</span>) <span class="title">int</span></span>&#123;</div><div class="line"><span class="keyword">return</span> op(a, b)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Point"><a href="#Point" class="headerlink" title="Point"></a><strong>Point</strong></h2><p>在go语言中，指针是不允许进行运算的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a <span class="keyword">int</span>  = <span class="number">2</span></div><div class="line"><span class="keyword">var</span> pa *<span class="keyword">int</span> = &amp;a</div><div class="line">*pa = <span class="number">3</span></div><div class="line">fmt.Println(a)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;go语言中变量的声名和很多语言都是反着来的,而且go语言只有值传递&lt;/p&gt;
&lt;h2 id=&quot;定义变量&quot;&gt;&lt;a href=&quot;#定义变量&quot; class=&quot;headerlink&quot; title=&quot;定义变量&quot;&gt;&lt;/a&gt;&lt;strong&gt;定义变量&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;go语言
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>log015</title>
    <link href="http://yoursite.com/2018/02/27/log015/"/>
    <id>http://yoursite.com/2018/02/27/log015/</id>
    <published>2018-02-26T16:03:18.000Z</published>
    <updated>2018-02-27T03:07:48.545Z</updated>
    
    <content type="html"><![CDATA[<p>假期最后几天，父母要出差。只能转移到奶奶家。</p><p>效率变得会比以往低一点，但每天必须要做的事情，还是要做的。</p><p>在积极做总结中…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假期最后几天，父母要出差。只能转移到奶奶家。&lt;/p&gt;
&lt;p&gt;效率变得会比以往低一点，但每天必须要做的事情，还是要做的。&lt;/p&gt;
&lt;p&gt;在积极做总结中…&lt;/p&gt;

      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>浮点数</title>
    <link href="http://yoursite.com/2018/02/21/float/"/>
    <id>http://yoursite.com/2018/02/21/float/</id>
    <published>2018-02-21T04:02:21.000Z</published>
    <updated>2018-02-22T01:00:26.655Z</updated>
    
    <content type="html"><![CDATA[<p>浮点数总是给我一种朦朦胧胧的感觉，知道它描述的数字有偏差，知道它在C语言中不能和整数型直接转换，却始终不敢拍着胸膛说“我懂了”。float的种种疑惑和仅停留在可以表达小数的认识上。</p><hr><p>我们需要先了解一下计算机的浮点数表示法。在 C 语言中计算机的浮点数用的是 IEEE 754 标准</p><p>IEEE 754标准中规定float单精度浮点数在机器中表示用 </p><ul><li>用 1 位表示数字的符号 S (Sign)</li><li>用 8 位来表示指数 E (Exponent)</li><li>用23 位来表示尾数 M (Mantissa)</li></ul><p>对于double双精度浮点数</p><ul><li>用 1 位表示符号 S (Sign)</li><li>用 11 位表示指数 E (Exponent)</li><li>用 52 位表示尾数 M (Mantissa)</li></ul><p>IEEE 浮点值的格式如下图所示:<br><img src="http://p3o1bechg.bkt.clouddn.com/FhyIhmiWMhg9CXzHfIvwVzmKEzXI" alt="IEEE 754"></p><p>这里我们以32位为例，来展示计算公式</p><p>$$(-1)^S * (1 + \frac{M}{2^{23}}) * 2^{\textrm{(E - 127)}}$$</p><p>让我们更进步的解释一下浮点数的三段各部分的意思</p><ul><li><p>第一段是符号位。</p></li><li><p>第二段是指数位，对于任何数ｘ，其都可以找到一个ｎ，使得$2^n&lt;=x&lt;=2^{n+1} $，比如，拿３来说，因为$2^1&lt;3&lt;2^2$,所以 $n=1$，同时，为了表示 0.00x 这样的数，所以需要有负数。8个比特位，总共能表示 255 个数字，为了表示负数,也就是在[-127,128]这个区间中，才有$2^{\textrm{(E - 127)}}$</p></li><li>第三段叫做偏移量会更准确一些，如果没有所谓的偏移量，我们展示的将是一个$2^{\textrm{(E - 127)}}$,精简一点也就是$2^x$，不如说这个数字就是一个基值，我们将会在这个基值上面再进行偏移，偏移的总量同样是$2^x$。偏移量为23位，就是说把这段数字分为了$2^{23}$份，展开公式会更好的展示出来:<br>$$(-1)^S * (1 * 2^{E - 127} + \frac{M}{2^{23}} * 2^{E - 127})$$</li></ul><p>正因为我们是在$2^x$的基础上偏移$\frac{M}{2^{23}}$,难免会有些数字无法完全吻合，只能依靠近似数来模拟。偏差由此而来。</p><p>为了更好的理解我们来拿3.14来看看</p><ol><li>3.14是正数，S的值为1</li><li>$2^1 &lt; 3.14 &lt; 2^2$ 所以$E - 127 = 1$,E 等于128</li><li>$(3.14 - 2^1)/2^1 = 0.57$, $\frac{M}{2^{23}} = 0.57$ ，求出来的M不是一个整数，到这里就出现了精度问题</li></ol><p>这里可以看出，计算浮点数的计算量还是很大的，如果没有硬件的直接支持对于计算机的消耗可想而知。同样依照这样的一条思路，也可以事先算好这么一个对应规格的浮点数，去和其他数字进行运算。曾经的<strong>魔数</strong>就是一个典型的例子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;浮点数总是给我一种朦朦胧胧的感觉，知道它描述的数字有偏差，知道它在C语言中不能和整数型直接转换，却始终不敢拍着胸膛说“我懂了”。float的种种疑惑和仅停留在可以表达小数的认识上。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们需要先了解一下计算机的浮点数表示法。在 C 语言中计算机的浮点数
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="程序" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>log014</title>
    <link href="http://yoursite.com/2018/02/21/log014/"/>
    <id>http://yoursite.com/2018/02/21/log014/</id>
    <published>2018-02-20T16:08:09.000Z</published>
    <updated>2018-02-27T03:07:03.540Z</updated>
    
    <content type="html"><![CDATA[<p>假期余量尽管不多，收货还是不错的</p><p>以15分钟为英语学习单位的方式，感觉不错</p><p>不带今天，还有十天假期</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假期余量尽管不多，收货还是不错的&lt;/p&gt;
&lt;p&gt;以15分钟为英语学习单位的方式，感觉不错&lt;/p&gt;
&lt;p&gt;不带今天，还有十天假期&lt;/p&gt;

      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log013</title>
    <link href="http://yoursite.com/2018/02/20/log013/"/>
    <id>http://yoursite.com/2018/02/20/log013/</id>
    <published>2018-02-20T02:17:43.000Z</published>
    <updated>2018-02-20T02:18:22.689Z</updated>
    
    <content type="html"><![CDATA[<p>这几天大部分时间都花在陪家人身上，对于一些项目时间难免有些不够，但依然会做，</p><p>log 已经中断了几天，还包括英语。</p><p>只能说自己的时间安排不恰当，有很大的调整空间</p><p>计划到开学之前，基本学完20小时的go语言</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天大部分时间都花在陪家人身上，对于一些项目时间难免有些不够，但依然会做，&lt;/p&gt;
&lt;p&gt;log 已经中断了几天，还包括英语。&lt;/p&gt;
&lt;p&gt;只能说自己的时间安排不恰当，有很大的调整空间&lt;/p&gt;
&lt;p&gt;计划到开学之前，基本学完20小时的go语言&lt;/p&gt;

      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>SharedPreferences</title>
    <link href="http://yoursite.com/2018/02/17/SharedPreferences/"/>
    <id>http://yoursite.com/2018/02/17/SharedPreferences/</id>
    <published>2018-02-17T02:47:31.000Z</published>
    <updated>2018-02-17T02:50:01.376Z</updated>
    
    <content type="html"><![CDATA[<p>如果想保存相对较小键值对集合，应该使用SharedPerference</p><h2 id="获取共享首选项句柄"><a href="#获取共享首选项句柄" class="headerlink" title="获取共享首选项句柄"></a><strong>获取共享首选项句柄</strong></h2><ul><li><p>getSharedPerferences() –如果需要指定文件名称，应该使用这个方法,第一个参数指定文件名称，第二个阐述文件权限。MODE_PRIVATE(Defalut)，仅能被创建者访问。还有MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Context context = getActivity(); </div><div class="line">SharedPreferences sharedPreference =    context.getSharedPreferences(</div><div class="line">       getString(R.string.preference_file_key), Context.MODE_PRIVATE);</div></pre></td></tr></table></figure></li><li><p>getPreferences() – 如果您只需使用 Activity 的一个共享首选项，请从 Activity 中使用此方法。 因为此方法会检索属于该 Activity 的默认共享首选项文件，您无需提供名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);</div></pre></td></tr></table></figure></li></ul><h2 id="写入共享首选项"><a href="#写入共享首选项" class="headerlink" title="写入共享首选项"></a><strong>写入共享首选项</strong></h2><p>通过SharedPreferences引用调用edit() 来创建一个 SharedPreferences.Editor。使用putXXX() 来写入键和值，然后，调用 commit() 以保存所做的更改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);</div><div class="line">SharedPreferences.Editor editor = sharedPref.edit();</div><div class="line">editor.putInt(getString(R.string.saved_high_score), newHighScore);</div><div class="line">editor.commit();</div></pre></td></tr></table></figure></p><h2 id="读取信息"><a href="#读取信息" class="headerlink" title="读取信息"></a><strong>读取信息</strong></h2><p>通过SharedPreferences引用的getXXX() 方法，去获取你想要减的值，并且根据需要提空，在键不存在的情况下返回默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);</div><div class="line">int defaultValue = getResources().getInteger(R.string.saved_high_score_default);</div><div class="line">long highScore = sharedPref.getInt(getString(R.string.saved_high_score), defaultValue);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果想保存相对较小键值对集合，应该使用SharedPerference&lt;/p&gt;
&lt;h2 id=&quot;获取共享首选项句柄&quot;&gt;&lt;a href=&quot;#获取共享首选项句柄&quot; class=&quot;headerlink&quot; title=&quot;获取共享首选项句柄&quot;&gt;&lt;/a&gt;&lt;strong&gt;获取共享首选项句
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>log012</title>
    <link href="http://yoursite.com/2018/02/15/log012/"/>
    <id>http://yoursite.com/2018/02/15/log012/</id>
    <published>2018-02-14T16:05:15.000Z</published>
    <updated>2018-02-14T16:11:30.674Z</updated>
    
    <content type="html"><![CDATA[<p>对于英语的学习，将会专注于英语流利说</p><p>意识到自己欠缺一些金融知识</p><p>从自己很久不看的一个专栏中又学会一些东西</p><p>技术应该继续下去，但是重要性在持续走低</p><p>重新定义技术的意义：技术将会成为我的谋生工具</p><p>但真正要成为精英还需很多其他的东西</p><p>非常需要再次重新去规划自己</p><p>此刻应该立刻睡觉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于英语的学习，将会专注于英语流利说&lt;/p&gt;
&lt;p&gt;意识到自己欠缺一些金融知识&lt;/p&gt;
&lt;p&gt;从自己很久不看的一个专栏中又学会一些东西&lt;/p&gt;
&lt;p&gt;技术应该继续下去，但是重要性在持续走低&lt;/p&gt;
&lt;p&gt;重新定义技术的意义：技术将会成为我的谋生工具&lt;/p&gt;
&lt;p&gt;但真正要成
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log011</title>
    <link href="http://yoursite.com/2018/02/13/log011/"/>
    <id>http://yoursite.com/2018/02/13/log011/</id>
    <published>2018-02-13T00:43:34.000Z</published>
    <updated>2018-02-13T00:44:06.430Z</updated>
    
    <content type="html"><![CDATA[<p>重新确定英语的学习方式，应该渗透到每天的生活中。学习计划将要重新安排，一切以两个小时为单位， 每过两小时就学半个小时英语。其实就是以2.5小时为一个单位。</p><p>确定未来一定会考人类的最高学历</p><p>10点过后，不再学习<strong>英语流利说</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重新确定英语的学习方式，应该渗透到每天的生活中。学习计划将要重新安排，一切以两个小时为单位， 每过两小时就学半个小时英语。其实就是以2.5小时为一个单位。&lt;/p&gt;
&lt;p&gt;确定未来一定会考人类的最高学历&lt;/p&gt;
&lt;p&gt;10点过后，不再学习&lt;strong&gt;英语流利说&lt;/stro
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
</feed>
