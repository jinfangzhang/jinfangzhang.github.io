<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JianRan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-01T09:53:38.300Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JianRan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>log000</title>
    <link href="http://yoursite.com/2018/02/01/log000/"/>
    <id>http://yoursite.com/2018/02/01/log000/</id>
    <published>2018-02-01T09:49:04.000Z</published>
    <updated>2018-02-01T09:53:38.300Z</updated>
    
    <content type="html"><![CDATA[<p>起源是在Yotube上面看到有很多人在拍<code>vlog</code>，于是乎，就联想到现在的状况。订阅了三个按年付费的知识付费栏目，基本上都是日更，刚开始可能会觉的很新鲜，但是随着时间的推移，自己每天需要的做的事情，也慢慢开始变得多起来。有时，真的只能记住一些花一天绝大部分时间z在做的事情。现在每天要干的事情，有学英语、学技术、写项目、练太极、看书、看日常订阅的专栏。如果你稍微偷懒或者不注意，时间就悄悄的溜走了。索性，直接给自己开一个活动，用来记录一天自己的成长与发生的事情～。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;起源是在Yotube上面看到有很多人在拍&lt;code&gt;vlog&lt;/code&gt;，于是乎，就联想到现在的状况。订阅了三个按年付费的知识付费栏目，基本上都是日更，刚开始可能会觉的很新鲜，但是随着时间的推移，自己每天需要的做的事情，也慢慢开始变得多起来。有时，真的只能记住一些花一天绝
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>计划</title>
    <link href="http://yoursite.com/2018/02/01/Splan/"/>
    <id>http://yoursite.com/2018/02/01/Splan/</id>
    <published>2018-02-01T03:33:27.000Z</published>
    <updated>2018-02-01T09:52:05.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="曾经"><a href="#曾经" class="headerlink" title="曾经"></a><strong>曾经</strong></h2><p>刚开始自己主动制定计划还是因为在那段时间，事情多到用脑子经常发生冲突,只能简单用笔和纸记录一下接下来要做的事情。对于计划的固有映象还保留在，想去依靠一个死的计划，来约束一个随时充满变数的人，根本就是一个笑话。但，当我渐渐习惯之后，开始有些意识到，通过它好像得到了些很不错的东西。</p><ol><li><p>更好的理解自己</p></li><li><p>拿回时间的控制权</p></li></ol><p>它的收获抽象的超乎想象，但除此以外，我想，自己还学会了些许坚持。</p><h2 id="开始的开始"><a href="#开始的开始" class="headerlink" title="开始的开始"></a><strong>开始的开始</strong></h2><p><strong>只在你下定决心并且迈出第一步时，才会真正的开始。仅仅从单纯的做规划来说，其本身意义并不大，一定要找到这件事属于自己的那唯一的意义。</strong>这两句话，应该是在做任何想做成的事情上面，都应该遵守的。</p><p>制定规划，效果并没有想象中的那么的快，要不，也不会有那么多人认为无用。任何需要努力才会得到的东西都已经不属于<strong>低垂的果实</strong>。当你们把它定义为这么一件事情时，成功摘取它的收获就不仅仅限于那颗果实了。想得到它并不容易，但是想轻而易举的得到，那根本就是一个无稽之谈。这一切都应该是你应该意识到的东西，通往优秀之路，并不是仅仅是你想象中的那么难而已，你为此你也应该付出足够多的代价。</p><p>给自己一个明确的规划，是你最应该的完成的，同时它也是使你变得优秀的第一步。</p><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a><strong>规划</strong></h2><p>对于计划，实施起来你所需要的工具，一个根笔和一张纸，并且还是一个正在想此刻这件事情的大脑就够了。接下来开动你的双手和大脑在纸上面写入如下类似的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">7:00            起床</div><div class="line">7:05 -- 8:05    早饭，洗漱，看早报</div><div class="line">...</div><div class="line">...</div><div class="line">...</div><div class="line">24:00           睡觉</div></pre></td></tr></table></figure></p><p>顺带写上分析和为什么要做计划也是不错的。到这里，我的计划就算完成，接着开始执行就可以了。下面我们来简单总结一下。</p><p>开个玩笑～，但是在这里就结束的人，你们根本就没有做好任何准备，或许，你们想去做一个让自己心灵得到安慰的事情仅仅而已，除此以外我真的为你们找不到其他理由。</p><p>在这就结束的人，我想你们应该缺乏一些认知。如果你在一张白纸上随意点一个点，并看不出什么，但随着你点点数量的增加，你会在某块区域聚集，到此这张纸你才能看出一点规律。这张纸才有了它的价值。对于现在这个大数据时代，只要拥有足够的信息，你会得到对于一个社会群体很多具有预测性的知识，进而去使用它们，例如广告，视频推送等。如果把它落到一个人身上，表面上你可以很大几率预测你的行为，本质上，你会得到你生活中那些恒定不变的东西。</p><p>在基于这样认知的前提的下，你需要的就不仅仅是一张计划表了，你需要随着时间推移，不断的去修正你的计划，只要你在执行计划的过程中，意识到这个计划已经不太适合自己，就应该去调整计划并且调整自己。这是一个不断自我了解，自我提高的一个过程。我常常说一句话：<strong>要常立志，而不能立常志</strong>，只有你不断的检省，你才会不断在这个过程中认识到自己不足，进而去不断的提高。最后你将会得到的东西就让你去感受吧。</p><p>所以你应该不断的重复下面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">制定计划</div><div class="line">执行计划</div><div class="line">反思计划</div></pre></td></tr></table></figure></p><h2 id="坚持"><a href="#坚持" class="headerlink" title="坚持"></a><strong>坚持</strong></h2><p>坚持是一种能力，而能力是可以后期培养的。如果你还认为自己并不具备这种能力，那么接下来的事情很简单，Just do it。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a><strong>结束语</strong></h2><p>我也是一名不断在这条通往更优秀的路上前进的人，希望我的一些话可以帮助到你。并且我也十分愿意去结交正在变得更优秀的你们。在这里并不会留联系方式，如果咱们彼此足够优秀，那我们迟早会见面的，所以在这里提前说一句：”你好，我的朋友”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;曾经&quot;&gt;&lt;a href=&quot;#曾经&quot; class=&quot;headerlink&quot; title=&quot;曾经&quot;&gt;&lt;/a&gt;&lt;strong&gt;曾经&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;刚开始自己主动制定计划还是因为在那段时间，事情多到用脑子经常发生冲突,只能简单用笔和纸记录一下接下来要做的
      
    
    </summary>
    
      <category term="2018-02" scheme="http://yoursite.com/categories/2018-02/"/>
    
    
      <category term="JianRan" scheme="http://yoursite.com/tags/JianRan/"/>
    
  </entry>
  
  <entry>
    <title>感谢我前进路上所有帮助过我的人以及我自己</title>
    <link href="http://yoursite.com/2017/12/14/%E6%84%9F%E8%B0%A2%E6%88%91%E5%89%8D%E8%BF%9B%E8%B7%AF%E4%B8%8A%E6%89%80%E6%9C%89%E5%B8%AE%E5%8A%A9%E8%BF%87%E6%88%91%E7%9A%84%E4%BA%BA%E4%BB%A5%E5%8F%8A%E6%88%91%E8%87%AA%E5%B7%B1/"/>
    <id>http://yoursite.com/2017/12/14/感谢我前进路上所有帮助过我的人以及我自己/</id>
    <published>2017-12-14T09:24:28.000Z</published>
    <updated>2017-12-14T09:26:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017年后半年我升大三以后，紧接是三门专业课，都算是重量级的——操作系统、计算机网络、数据库。因为自从大二开始以来，到现在，基本所有的专业课已经适应了自学，感觉在课堂上效率确实有那么一点低。好吧，不仅仅是有点低～。之后，就一门课一门课的去和代课老师谈，好让老师们同意，我想自学的这个想法。在自己的圈子中，我建议很多人都这样做，无奈不知道是什么原因，所有拥有我这样想法的人都碰了一鼻子灰，但自己去做的时候，反而一帆风顺，无论是班主任还是代课老师，经过几次沟通之后，都得到了许可。</p><p>说实话，当时的心情是真的开心。好像世界总是在眷顾我一样，从最初的班干部，到后来尝试着接一些项目来做，再到之后的已经历时一年的不上课计划，每一次当我想要什么样的资源的时候，总是十分自然的就得到了。而在大学开始之前，凡是个坎我都能摔的，前仰后翻的。</p><p>这么巧合的事情，刚开始时，落到谁身上，谁能不乱想。相信只要你认知以内的可能性，保证都去想过了，妖魔鬼怪, 风水，运势，星座等肯定都在脑子里面浮想联翩。</p><hr><blockquote><p>时间是任何人的老师，他会教会你，在人生路上所有的事情。</p></blockquote><p>渐渐我意识到，所有的这些都是在我努力提升自己之后的发生的，这里并不单单想说，努力可以改变人生之类的话，对努力而言，我抱着和知识基本一致的看法，「 纯粹的知识是没有任何意义的，同样的，努力同样也基本如此 」 。而更想表达，这个世界真的会让正确的人出现在正确的地点，彼此相同的人会相互吸引。这些某种特质相同的人，会更好的理解你的想法，进而认同并且给予我资源，我想感谢的恰恰是这是这些人，当然还有我的亲人，尽管我的很多做法，都是在做异类，已经超出一般人的限度，但他们还是一如既往的支持我。</p><p>在我前进路上，帮助过我的人，真的太多，虽然仅仅是发生在大学两年半的时间里面，但恰恰就是因为在如此短的时间内，有这么多人帮助过我，我能做的也仅仅是以我当时的能力来最大限度的感谢你们了。未来的路还很长，我也必然被很多人帮助，但是凡是帮助过我的，无论大小，我都会牢牢记在心里。</p><hr><p>大三上半学期即将结束，这个学期唯一的遗憾就是，自己太过于忙碌，忙的甚至没有片刻时间，让自己回头来看看和驻足思考。</p><p>除了技术外，这学期收货的更多的感恩。</p><p>最后希望自己在下一个半年，自己可以找到一个平衡点。</p><p>#That’s All</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017年后半年我升大三以后，紧接是三门专业课，都算是重量级的——操作系统、计算机网络、数据库。因为自从大二开始以来，到现在，基本所有的专业课已经适应了自学，感觉在课堂上效率确实有那么一点低。好吧，不仅仅是有点低～。之后，就一门课一门课的去和代课老师谈，好让老师们同意，我想
      
    
    </summary>
    
      <category term="2017-12" scheme="http://yoursite.com/categories/2017-12/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>心态前言</title>
    <link href="http://yoursite.com/2017/10/13/%E5%BF%83%E6%80%81%E5%89%8D%E8%A8%80/"/>
    <id>http://yoursite.com/2017/10/13/心态前言/</id>
    <published>2017-10-12T17:44:56.000Z</published>
    <updated>2017-10-12T17:46:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>唯有冷静去接收一切，才会真正的持久。激情背后的浮躁往往是使一件事情变的糟糕的源头。学会在激情中冷静是恰当的进步之道</p></blockquote><p>深入呼吸 3min …</p><hr><p>哪怕是跟着前人的脚印，写懂一个操作系统都绝非易事。无论你的平台是什么，你的每一个脚印务必踏的坚实。你的前进才是真正的前进。</p><p>在写操作系统的时候，必须处在一个冷静的状态下去完成。何为冷静？遇事不慌不乱，有条不紊。不在乎时间成本，只求写一点懂一点（这是针对当前计划来说的）。</p><p>在接下来的工作中，将会接触到很多工具，而且这些工具很多将会是没有接触过得，同时也包括很多新的知识点。当我们遇到的时候应该兴平气和的看懂之后才可以前进，遇到不会的地方及时停止去解决掉，在必要的时候要写文档总结记录。每一篇文章力求 <strong>只字不差</strong> 的冷静阅读。</p><hr><p>当然这里的「不在乎时间成本」实际是节约时间，不过实际怎么样无所谓，它的结果会导致计划周期变长，为了不让他变得不可控，我们来简单计算一下，首先这个目标计划在12月底完成，距离现在还有77天时间，这本书的总页数469，还有大概450页，平均每天大概要看6页，我们每天花费的时间大概是 90min，平均下来每页15分钟看完。</p><p>这么算下来时间是很充足的，更不用说，这本书讲的会很明白很好懂，另外书中有很大一部分实在聊天。</p><p>时间很充足，请耐心的学习</p><h1 id="That’s-All"><a href="#That’s-All" class="headerlink" title="That’s All"></a>That’s All</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;唯有冷静去接收一切，才会真正的持久。激情背后的浮躁往往是使一件事情变的糟糕的源头。学会在激情中冷静是恰当的进步之道&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;深入呼吸 3min …&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;哪怕是跟着前人的脚印，写懂一个操作系统都绝
      
    
    </summary>
    
      <category term="2017-10" scheme="http://yoursite.com/categories/2017-10/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Adapter设计模式与 ListView 和 RecylerView</title>
    <link href="http://yoursite.com/2017/09/05/Adapter%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E-ListView-%E5%92%8C-RecylerView/"/>
    <id>http://yoursite.com/2017/09/05/Adapter设计模式与-ListView-和-RecylerView/</id>
    <published>2017-09-05T12:09:08.000Z</published>
    <updated>2017-09-05T12:11:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>永远不做超出当前认知的事情</p></blockquote><p>简单谈谈 Adapter设计模式，及其在 Android 中的简单应用，尝试着去理解这些设计。</p><p> Adapter模式的<strong>定义：</strong>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配的问题而无法一起工作的两个类能够一起工作。</p><p> Adapter模式 换句话说，就像条想要给手机充电的USB线，光有USB插头是无法插到插座上给手机充电的，需要连接个充电头才可以实现。那么这个充电头就是 Adapter。提供了一个转换接头，让USB接口与插座完全解耦，两者之间没有任何联系。在代码中实现其实就是在这二者中间加入了一个类获取其他可以实现这种功能的代码。</p><p> 比较经典的是 ListView 和 RecylerView 的 Adapter 类，两者的结构完全相同。</p><p> 首先，ListView 和 RecylerView 直接需要View的引用，及其View的数量等信息，但是我们能提供的只能是什么信息都没有的View 和 独立的一堆信息，这个工作如果直接传给 ListView 和 RecylerView 他们来做，就会直接耦合在一起，ListView 和 RecylerView 将会过于臃肿，结构混乱。</p><p> 我们做的事情是把对于他们而言，他们所需要的信息由Adapter直接提供。而 Adapter的具体细节他们不需要知道了。我们把 信息全部传递给 Adapter，让它进行内部的组合，组合处合理的信息即可。</p><blockquote><p>说白了就是USB接口和充电头之间的关系</p></blockquote><h2 id="两种不同的实现方式"><a href="#两种不同的实现方式" class="headerlink" title="两种不同的实现方式"></a>两种不同的实现方式</h2><p><strong>类适配器模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//USB</div><div class="line">public class USB&#123;</div><div class="line"></div><div class="line">    //使用USB传输电能</div><div class="line">    public void usbEnergy()&#123;&#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">//转换头</div><div class="line">public  interface TransHead&#123;</div><div class="line"></div><div class="line">    //使用插头传输电能</div><div class="line">    public void usbEnergy;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class EnergyAdapter extends USB implements TransHead&#123;</div><div class="line"></div><div class="line">    public void usbEnergy()&#123;</div><div class="line">        usbEnergy()&#123;&#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>对象适配器模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class EnergyAdapter implements TransHead&#123;</div><div class="line">    USB usb;</div><div class="line">    </div><div class="line">    EnergyAdapter(USB usb)&#123;</div><div class="line">        this.usb = usb;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void usbEnergy()&#123;</div><div class="line">        usb.usbEnergy();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="That’s-All"><a href="#That’s-All" class="headerlink" title="That’s All"></a>That’s All</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;永远不做超出当前认知的事情&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单谈谈 Adapter设计模式，及其在 Android 中的简单应用，尝试着去理解这些设计。&lt;/p&gt;
&lt;p&gt; Adapter模式的&lt;strong&gt;定义：&lt;/strong&gt;适配器
      
    
    </summary>
    
      <category term="2017-9" scheme="http://yoursite.com/categories/2017-9/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Fragment详解——管理Fragment</title>
    <link href="http://yoursite.com/2017/09/04/Fragment%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E7%AE%A1%E7%90%86Fragment/"/>
    <id>http://yoursite.com/2017/09/04/Fragment详解——管理Fragment/</id>
    <published>2017-09-04T12:09:14.000Z</published>
    <updated>2017-09-04T12:13:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章当中，我们总览性的了解到 Fragment 的基本使用和用途。一些最为基础的知识已经学习完毕。接下来我们就要深入到更加具体的内容来进行学习。</p><p>##FragmentManager</p><p>它的作用是对Fragment的状态进行保存与恢复。对 Fragment 的一些管理操作都被封装到这个类当中，最让我们熟知的用法，想必是获取一个 FragmentManager 实例，进而开启一个事务对 Fragment 进行相关操作。获取 FragmentManager 是 Activity 本身的一个方法的结果（getFragmentManager）。仔细思考其中的道理，不难想清楚，对于 Activity 而言它本身是可以依赖多个 Fragment，如果对于每个Fragment单独操作，不免费事费力，不如提供一个统一的一个接口来进行使用。</p><p>常用的方法如下：</p><ol><li>findFragmentById()<br>根据 ID 来获取对应的 Fragment 实例，主要使用在静态绑定中</li><li>findFragmentByTag()<br>意思基本和上面相同</li><li>beginTransaction()<br>开启一个事务</li></ol><p>##FragmentTransaction</p><p>常用方法如下：</p><ol><li><p>add(int containerViewId, Fragment fragment, String tag)<br>将一个fragment实例添加到Activity的最上层 </p></li><li><p>remove(Fragment fragment)<br>将一个fragment实例从Activity的fragment队列中删除  </p></li><li><p>replace(int containerViewId, Fragment fragment)<br>替换 containerViewId 中的 fragment 实例，注意，它首先把 containerViewId 中所有 fragment 删除，然后再 add 进去当前的 fragment  </p></li></ol><p>##有关回滚——FragmentTransaction</p><p>上面简单记录了一个相关的主要方法，现在我们来简单说一个回滚功能。要实现回滚只需要 commit() 和 addToBackStack(String tag)这个两个方法，每次在commit()之前，使用<strong>addToBackStack()</strong>将其添加到回退栈中。需要回退的时候只需要使用 popBackStack() 方法即可，回退的单位是以一次 commit() 为主。</p><blockquote><p>另外补充说明一下，FragmentManager 还提供了监听回退栈的方法<br>FragmentManager::addOnBackStackChangedListener(listener);//添加监听器<br>FragmentManager::removeOnBackStackChangedListener(listener);//移除监听器 </p><p>不过,这里你们要注意理解为什么 FragmentManager 提供监听回退栈的方法。</p></blockquote><p>##That’s All</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在之前的文章当中，我们总览性的了解到 Fragment 的基本使用和用途。一些最为基础的知识已经学习完毕。接下来我们就要深入到更加具体的内容来进行学习。&lt;/p&gt;
&lt;p&gt;##FragmentManager&lt;/p&gt;
&lt;p&gt;它的作用是对Fragment的状态进行保存与恢复。对 F
      
    
    </summary>
    
      <category term="2017-9" scheme="http://yoursite.com/categories/2017-9/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Fragment详解——基本使用</title>
    <link href="http://yoursite.com/2017/07/21/Fragment%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/07/21/Fragment详解——基本使用/</id>
    <published>2017-07-21T10:38:04.000Z</published>
    <updated>2017-07-21T10:38:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们先从一个总览的角度去理解什么是「 静态 」添加 Fragment 和「 动态 」添加 Fragment？</p><p>先让我们来看一个图片，关系显然易见，对于 Fragment 来说他是 Activity 与 View 中间用来衔接的。 Activity 使用 Fragment 的形式是通过控件的形式来进行使用的，对于静和动态两种不同的形式，是对于 Activity 与 Fragment 之间这一层关系来说。写死了，那就说明是「 静态 」，运行时添加的，那就说明是「 动态 」。关系理清楚了，对于 Fragment 的使用方式也容易记忆并且使用了，具体的一些其他细节会在下面写出并且说明。<br><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fhrlstqlzkj30ks0bq74c.jpg" alt=""></p><p>##公共资源的准备</p><p>上面说了，对于静态和动态两种方式使用 Fragment，主要差别在于 Activity 与 Fragment的关系是否是可以活动的。而 Fragment 与 View 的关系自然是一一对应的。一个 Fragment 操作一个 View 的业务逻辑。</p><p>在这里我们可以简单思考一下，因为 Fragment 的存在 Activity 与 View 彻底解耦，任何 View 可以随意结合任何一个 Activty，使用更加灵活。并且一个好消息是  创建一个 Fragment 的消耗很小，虽然 Fragment 本身也有很多的 Bug 存在，但是与之也有对应的解决方案，同时 Google 也在慢慢修改中。</p><p><strong>让我们开始:</strong><br>1、创建第一个 fragmeng_1.xml, 代码如下:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    android:layout_width="match_parent"</div><div class="line">    android:layout_height="match_parent"</div><div class="line">    android:background="#00ff00" &gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width="wrap_content"</div><div class="line">        android:layout_height="wrap_content"</div><div class="line">        android:text="This is fragment 1"</div><div class="line">        android:textColor="#000000"</div><div class="line">        android:textSize="25sp" /&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>2、创建第二个 fragment_2.xml，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  </div><div class="line">    android:layout_width=&quot;match_parent&quot;  </div><div class="line">    android:layout_height=&quot;match_parent&quot;  </div><div class="line">    android:background=&quot;#ffff00&quot; &gt;  </div><div class="line">  </div><div class="line">    &lt;TextView  </div><div class="line">        android:layout_width=&quot;wrap_content&quot;  </div><div class="line">        android:layout_height=&quot;wrap_content&quot;  </div><div class="line">        android:text=&quot;This is fragment 2&quot;  </div><div class="line">        android:textColor=&quot;#000000&quot;  </div><div class="line">        android:textSize=&quot;25sp&quot; /&gt;  </div><div class="line">  </div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure><p>3、连续创建两个 Fragment 类，并且将 fragment_1.xml 和 fragment_2.xml与之进行绑定。<br>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Fragment1 extends Fragment &#123;  </div><div class="line">    @Override  </div><div class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;  </div><div class="line">        return inflater.inflate(R.layout.fragment_1, container, false);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Fragment2 extends Fragment &#123;  </div><div class="line">    @Override  </div><div class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;  </div><div class="line">        return inflater.inflate(R.layout.fragment2_, container, false);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>到此我们已经将xml 与 Fragment 一一对应。</p><p>##静态绑定</p><p>这个是直接把 Activity 与 Fragment 固定，通过 fragment 控件写死的，在之下的代码中需要注意的是，name 属性代表的是与这个控件进行绑定的 Fragment 的全类名。同时必须要有唯一标识符，这个用属性 id 或者 tag 来进行表示即可。<br>代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;--!activity_main.xml--&gt;</div><div class="line"></div><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    tools:context=&quot;jinfangzhang.github.fragmentdemo.MainActivity&quot;&gt;</div><div class="line"></div><div class="line">    &lt;fragment</div><div class="line">        android:tag=&quot;@+id/fragment1&quot;</div><div class="line">        android:name=&quot;jinfangzhang.github.fragmentdemo.Fragment_1&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_weight=&quot;1&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        /&gt;</div><div class="line">    &lt;fragment</div><div class="line">        android:id=&quot;@+id/fragment2&quot;</div><div class="line">        android:name=&quot;jinfangzhang.github.fragmentdemo.Fragment_2&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_weight=&quot;1&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        /&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure><p>Activity中onCreate函数什么都没有写。</p><p>##动态绑定</p><p>activity_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/button_1&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/button_2&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;FrameLayout</div><div class="line">        android:id=&quot;@+id/fragment_container&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>对于 Activity 中的方法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main_2);</div><div class="line">    Log.e(&quot;Activity&quot;,&quot;Activity---onCreate()&quot;);</div><div class="line">    Button btnLoadFrag1 = (Button)findViewById(R.id.button_1);</div><div class="line">    btnLoadFrag1.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onClick(View v) &#123;</div><div class="line">            FragmentManager manager = getFragmentManager();</div><div class="line">            FragmentTransaction transaction = manager.beginTransaction();</div><div class="line">            Fragment_1 fragment1 = new Fragment_1();</div><div class="line"></div><div class="line">            transaction.replace(R.id.fragment_container,fragment1);</div><div class="line">            transaction.commit();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    Button btnLoagFrag2 = (Button)findViewById(R.id.button_2);</div><div class="line">    btnLoagFrag2.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onClick(View v) &#123;</div><div class="line">            FragmentManager manager = getFragmentManager();</div><div class="line">            FragmentTransaction transaction = manager.beginTransaction();</div><div class="line">            Fragment_2 fragment2 = new Fragment_2();</div><div class="line">            transaction.replace(R.id.fragment_container, fragment2);</div><div class="line">            transaction.commit();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里主要分为四步：<br>1、获取 FragmentManager 对象，在 v4 包里面使用的是 getSupportFragmentManager() 获得，原生使用 getFragmentManager().</p><blockquote><p>对于原生和 v4 的使用，其实差别就在 Activity 继承是什么，如果你的 Fragment 继承来自 v4，那么 Activity 应该继承 FragmentActivity，而如果是原生，就什么都不要动了</p></blockquote><p>2、通过 Manager 对象获取并且开启一个事务。<br>3、向容器内加入Fragment，一般使用add或者replace方法实现，需要传入容器的id和Fragment的实例。<br>4、提交事务，调用commit方法提交。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们先从一个总览的角度去理解什么是「 静态 」添加 Fragment 和「 动态 」添加 Fragment？&lt;/p&gt;
&lt;p&gt;先让我们来看一个图片，关系显然易见，对于 Fragment 来说他是 Activity 与 View 中间用来衔接的。 Activity 使用 Fra
      
    
    </summary>
    
      <category term="2017-7" scheme="http://yoursite.com/categories/2017-7/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Fragment详解——生命周期</title>
    <link href="http://yoursite.com/2017/07/21/Fragment%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/07/21/Fragment详解（一）/</id>
    <published>2017-07-21T03:38:23.000Z</published>
    <updated>2017-07-21T08:12:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是关于Fragment的生命周期图，简单理解下，同时下面是Fragment与Activity生命周期对比</p><p><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fhrbuh1lqfj30k10npq52.jpg" alt=""></p><hr><p>接下来我们逐个对方法解释：<br><strong>onAttach:</strong> onAttach()方法与Activity关联之后调用，也就是在执行了 「setContentView（）」这个方法之后，就和 fragment 建立了联系。</p><p><strong>onCreate:</strong> fragment 初次创建时调用，尽管他看起来非常像 Activty 的 onCreate 。此时 Activity 还没有建立完成，因为我们的 Fragment 也是 Activity 的一部分，所以在这里你想获取一些关于 Activity 中的一些资源，将会获取不到。</p><p><strong>onCreateView:</strong> 在这个 fragment构造它的布局时进行调用。在这里返回此Fragment的一个视图层次结构。同时使用 LayoutInflater 的 inflater() 方法来构造实图，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public View onCreateView(LayoutInflater inflater, ViewGroup container,  </div><div class="line">                         Bundle savedInstanceState) &#123;  </div><div class="line">    return inflater.inflate(R.layout.fragment3, container, false);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>onActivityCreated:</strong>在 Activity 的 onCreate 完成之后会调用这个函数，所以这个时候 Activity 已经创建完毕，在这个方法当中可以获取 Activity 的所有资源的。 </p><p><strong>onStart:</strong>当到 onStart() 时, Fragment 对用户就是可见的了，但是这个时候用户还没有和 Fragment 交互。在生命周期中也可以看到，Fragment 的 onStart 与 Activity 的 onStart 是绑定着的。</p><p><strong>onResume:</strong>这是 Fragment 与用户交互之前进行的最后一个回调。这个方法执行结束之后，就可以与 Fragment 进行交互了</p><p>onPause：此回调与 Activity 的 onPause() 相绑定，与 Activity 的 onPause() 意义一样。</p><p><strong>onStop:</strong>这个也和 onPause 相同就不解释了。</p><p><strong>onDestroyView:</strong> 如果 Fragment 即将被结束或者保存，那么撤销方向上面的下一个回调将会是该方法。这个方法会将在 onCreateView 中创建的视图与这个 Fragment 分离。下次这个 Fragment 若要显示，那么将会重新创建视图。</p><p><strong>onDestroy:</strong>当这个fragment不再使用时调用。需要注意的是，它即使经过了onDestroy()阶段，但仍然能从Activity中找到，因为它还没有Detach。</p><p><strong>onDetach:</strong>Fragment生命周期中最后一个回调是onDetach()。调用它以后，Fragment就不再与Activity相绑定，它也不再拥有视图层次结构，它的所有资源都将被释放。</p><hr><p>总结:<br>在这里简单总结以下 Fragment 过程。<br>大概可以分为两类: 第一类是 Fragment 与 Activity 建立联系，第二类是 Fragment 与 View 建立联系。<br>过程总结如下:<br>1、与 Activyt 建立联系<br>2、与 View 建立联系<br>3、与 用户 进行交互<br>4、与 View 失去联系<br>5、与 Activity 失去联系</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是关于Fragment的生命周期图，简单理解下，同时下面是Fragment与Activity生命周期对比&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006o5OgAly1fhrbuh1lqfj30k10npq52.jpg&quot; 
      
    
    </summary>
    
      <category term="2017-7" scheme="http://yoursite.com/categories/2017-7/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>共享库</title>
    <link href="http://yoursite.com/2017/06/08/%E5%85%B1%E4%BA%AB%E5%BA%93/"/>
    <id>http://yoursite.com/2017/06/08/共享库/</id>
    <published>2017-06-08T11:36:48.000Z</published>
    <updated>2017-06-08T11:38:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>前一篇我们讲了静态库，我们来到了 链接阶段的最后一部分，事不宜迟继续我们今天的战斗。</p><hr><p>组成共享库的目标文件和一般的目标文件是有所不同的，在编译时要加 -fPIC 选项</p><p>例如</p><pre><code>gcc -c -fPIC stack/stack.c stack/push.c stack/pop.c stack/is_empty.c</code></pre><p>由于接下来要用 objdump -dS 把反汇编指令和源代码穿插起来分析，所以用 -g 选项来加调试信息。注意，必须在编译每个文件时都要加 -g 选项，而不能只在最后链接时加 -g 选项，如果目标文件中没有调试信息，链接生成的可执行文件也不会有的。我们反汇编查看下 push.o </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ objdump -dS push.o</div><div class="line"></div><div class="line">push.o：     文件格式 elf64-x86-64</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">0000000000000000 &lt;push&gt;:</div><div class="line">extern char stack[512];</div><div class="line">extern int top;</div><div class="line"></div><div class="line">void push(char c)&#123;</div><div class="line">   0:   55                      push   %rbp</div><div class="line">   1:   48 89 e5                mov    %rsp,%rbp</div><div class="line">   4:   89 f8                   mov    %edi,%eax</div><div class="line">   6:   88 45 fc                mov    %al,-0x4(%rbp)</div><div class="line">    stack[++top] = c;</div><div class="line">   9:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # f &lt;push+0xf&gt;</div><div class="line">   f:   83 c0 01                add    $0x1,%eax</div><div class="line">  12:   89 05 00 00 00 00       mov    %eax,0x0(%rip)        # 18 &lt;push+0x18&gt;</div><div class="line">  18:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 1e &lt;push+0x1e&gt;</div><div class="line">  1e:   48 63 d0                movslq %eax,%rdx</div><div class="line">  21:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 28 &lt;push+0x28&gt;</div><div class="line">  28:   0f b6 4d fc             movzbl -0x4(%rbp),%ecx</div><div class="line">  2c:   88 0c 02                mov    %cl,(%rdx,%rax,1)</div><div class="line">  2f:   90                      nop</div><div class="line">  30:   5d                      pop    %rbp</div><div class="line">  31:   c3                      retq</div></pre></td></tr></table></figure><p>指令中方式用到 stack 和 top 的地址都用 0x0 表示，以备在重定向时修改。再看 readelf 的 .rel.text 段的信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">重定位节 &apos;.rela.text&apos; 位于偏移量 0x488 含有 4 个条目：</div><div class="line">  偏移量          信息           类型           符号值        符号名称 + 加数</div><div class="line">00000000000b  000e00000002 R_X86_64_PC32     0000000000000000 top - 4</div><div class="line">000000000014  000e00000002 R_X86_64_PC32     0000000000000000 top - 4</div><div class="line">00000000001a  000e00000002 R_X86_64_PC32     0000000000000000 top - 4</div><div class="line">000000000024  000f00000002 R_X86_64_PC32     0000000000000000 stack - 4</div></pre></td></tr></table></figure><p>上述信息指出了指令中有四处需要在重定位时修改。编译连接成可执行文件之后，再做反编译分析:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">0000000000000675 &lt;push&gt;:</div><div class="line">extern char stack[512];</div><div class="line">extern int top;</div><div class="line"></div><div class="line">void push(char c)&#123;</div><div class="line"> 675:   55                      push   %rbp</div><div class="line"> 676:   48 89 e5                mov    %rsp,%rbp</div><div class="line"> 679:   89 f8                   mov    %edi,%eax</div><div class="line"> 67b:   88 45 fc                mov    %al,-0x4(%rbp)</div><div class="line">    stack[++top] = c;</div><div class="line"> 67e:   8b 05 8c 09 20 00       mov    0x20098c(%rip),%eax        # 201010 &lt;top&gt;</div><div class="line"> 684:   83 c0 01                add    $0x1,%eax</div><div class="line"> 687:   89 05 83 09 20 00       mov    %eax,0x200983(%rip)        # 201010 &lt;top&gt;</div><div class="line"> 68d:   8b 05 7d 09 20 00       mov    0x20097d(%rip),%eax        # 201010 &lt;top&gt;</div><div class="line"> 693:   48 63 d0                movslq %eax,%rdx</div><div class="line"> 696:   48 8d 05 a3 09 20 00    lea    0x2009a3(%rip),%rax        # 201040 &lt;stack&gt;</div><div class="line"> 69d:   0f b6 4d fc             movzbl -0x4(%rbp),%ecx</div><div class="line"> 6a1:   88 0c 02                mov    %cl,(%rdx,%rax,1)</div><div class="line"> 6a4:   90                      nop</div><div class="line"> 6a5:   5d                      pop    %rbp</div><div class="line"> 6a6:   c3                      retq</div></pre></td></tr></table></figure><p>原来指令中 0x0 被改成了正经的地址，这样做了重定位之后，各段的加载就定死了，因为在指令使用了绝对地址。</p><p>我们来看看用了 -fPIC 选项编译生成的目标文件有什么不同:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ objdump -dS push.o</div><div class="line"></div><div class="line">push.o：     文件格式 elf64-x86-64</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">0000000000000000 &lt;push&gt;:</div><div class="line">extern char stack[512];</div><div class="line">extern int top;</div><div class="line"></div><div class="line">void push(char c)&#123;</div><div class="line">   0:   55                      push   %rbp</div><div class="line">   1:   48 89 e5                mov    %rsp,%rbp</div><div class="line">   4:   89 f8                   mov    %edi,%eax</div><div class="line">   6:   88 45 fc                mov    %al,-0x4(%rbp)</div><div class="line">    stack[++top] = c;</div><div class="line">   9:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # 10 &lt;push+0x10&gt;</div><div class="line">  10:   8b 00                   mov    (%rax),%eax</div><div class="line">  12:   8d 50 01                lea    0x1(%rax),%edx</div><div class="line">  15:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # 1c &lt;push+0x1c&gt;</div><div class="line">  1c:   89 10                   mov    %edx,(%rax)</div><div class="line">  1e:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # 25 &lt;push+0x25&gt;</div><div class="line">  25:   8b 00                   mov    (%rax),%eax</div><div class="line">  27:   48 8b 15 00 00 00 00    mov    0x0(%rip),%rdx        # 2e &lt;push+0x2e&gt;</div><div class="line">  2e:   48 98                   cltq</div><div class="line">  30:   0f b6 4d fc             movzbl -0x4(%rbp),%ecx</div><div class="line">  34:   88 0c 02                mov    %cl,(%rdx,%rax,1)</div><div class="line">  37:   90                      nop</div><div class="line">  38:   5d                      pop    %rbp</div><div class="line">  39:   c3                      retq</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> 重定位节 &apos;.rela.text&apos; 位于偏移量 0x4c8 含有 4 个条目：</div><div class="line">  偏移量          信息           类型           符号值        符号名称 + 加数</div><div class="line">00000000000c  000f0000002a R_X86_64_REX_GOTP 0000000000000000 top - 4</div><div class="line">000000000018  000f0000002a R_X86_64_REX_GOTP 0000000000000000 top - 4</div><div class="line">000000000021  000f0000002a R_X86_64_REX_GOTP 0000000000000000 top - 4</div><div class="line">00000000002a  00100000002a R_X86_64_REX_GOTP 0000000000000000 stack - 4</div></pre></td></tr></table></figure><p>push.o 的代码几乎完全和 之前的不相同，.rela.text 表中的类型也不相同。</p><p>下来我们编译生成共享库再反汇编分析:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">00000000000006f0 &lt;push&gt;:</div><div class="line">extern char stack[512];</div><div class="line">extern int top;</div><div class="line"></div><div class="line">void push(char c)&#123;</div><div class="line"> 6f0:   55                      push   %rbp</div><div class="line"> 6f1:   48 89 e5                mov    %rsp,%rbp</div><div class="line"> 6f4:   89 f8                   mov    %edi,%eax</div><div class="line"> 6f6:   88 45 fc                mov    %al,-0x4(%rbp)</div><div class="line">    stack[++top] = c;</div><div class="line"> 6f9:   48 8b 05 d8 08 20 00    mov    0x2008d8(%rip),%rax        # 200fd8 &lt;top@@Base-0x48&gt;</div><div class="line"> 700:   8b 00                   mov    (%rax),%eax</div><div class="line"> 702:   8d 50 01                lea    0x1(%rax),%edx</div><div class="line"> 705:   48 8b 05 cc 08 20 00    mov    0x2008cc(%rip),%rax        # 200fd8 &lt;top@@Base-0x48&gt;</div><div class="line"> 70c:   89 10                   mov    %edx,(%rax)</div><div class="line"> 70e:   48 8b 05 c3 08 20 00    mov    0x2008c3(%rip),%rax        # 200fd8 &lt;top@@Base-0x48&gt;</div><div class="line"> 715:   8b 00                   mov    (%rax),%eax</div><div class="line"> 717:   48 8b 15 ca 08 20 00    mov    0x2008ca(%rip),%rdx        # 200fe8 &lt;stack@@Base-0x78&gt;</div><div class="line"> 71e:   48 98                   cltq</div><div class="line"> 720:   0f b6 4d fc             movzbl -0x4(%rbp),%ecx</div><div class="line"> 724:   88 0c 02                mov    %cl,(%rdx,%rax,1)</div><div class="line"> 727:   90                      nop</div><div class="line"> 728:   5d                      pop    %rbp</div><div class="line"> 729:   c3                      retq</div></pre></td></tr></table></figure><p>在这台机器里面看的不是那么明显，主要还是看背后注释的差距。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">201010 &lt;top&gt; 变成了 # 200fd8 &lt;top@@Base-0x48&gt;</div></pre></td></tr></table></figure><p>通过注释我们意识到，我们这个不是一个绝对地址。所以共享库各段的加载地址并没有被定死，可以加载到任意的位置，因为指令中的地址都是相对于 top@@Base 的，这就是位置无关代码的特点。</p><p>接下来我们把 main.c 与共享库编译链接在一起，然后运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ gcc main.c -g -L. lstack -Istack -o main</div><div class="line">jianran@jianran:~/桌面/x86HB$ ./main</div><div class="line">./main: error while loading shared libraries: libstack.so: cannot open shared object file: No such file or directory</div></pre></td></tr></table></figure><p>结果十分的令人神奇，编译的时候没有问题，然后在执行的时候，报错说找不到 libstack.so。 那么运行时在那些路径下来找共享库呢？</p><p>我们先用 ldd 命令查看可执行文件依赖于那些共享库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ ldd main</div><div class="line">        linux-vdso.so.1 =&gt;  (0x00007ffcd41ab000)</div><div class="line">        libstack.so =&gt; not found</div><div class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd788704000)</div><div class="line">        /lib64/ld-linux-x86-64.so.2 (0x00005569c3f91000)</div></pre></td></tr></table></figure></p><p>ldd 模拟运行一遍 main程序 ，在运行过程中做动态链接，从而得知这个程序依赖于哪些共享库以及这些共享库都在声明路径下。我们在之前说到过 gcc 调用 ld 做链接时用 -dynamic-linker … 选项指定动态链接器的路径，动态链接器也像其他共享库一样加载到进程的地址空间中。而另一个 -lc 只说明需要链接 libc 却没有指出 libc 库的完整路径，-lstack 也是如此，共享库的路径需要在运行时由动态链接器进行查找。在上面的代码当中，动态链接器找到libc.so.6，而 libstack 的路径没有找到，无法完成链接。</p><p>那么动态链接库会到哪些目录下搜索共享库呢？<br>路径搜索顺序如下:</p><ol><li><p>首先在环境变量 LD_LIBRARY_PATH 保存的路径中查找</p></li><li><p>然后从缓存文件 /etc/ld.so.cache 中查找。这个缓存文件是由 ldconfig 命令读取配置文件 /etc/ld.so.conf 生成的</p></li></ol><p>3.如果上述步骤没有找到，则到默认的系统库文件目录查找。</p><p>知道了搜索顺序，也就算知道了解决方案了:</p><p><strong>第一种解决方案</strong>，在运行程序时设置环境变量 LD_LIBRARY_PATH 把共享库所在的目录添加到搜索路径,这种方式，只适合开发调试中临时使用一下，但是不建议使用</p><pre><code>export LD_LIBRARY_PATH=~/桌面/x86HB./main</code></pre><p>第一条命令在当前 Shell 进程中设置一个环境变量 LD_LIBRARY_PATH，一旦在 Shell 进程当中设置了环境变量，以后每次执行命令时 Shell 进程都会把自己的环境变量传给新创建的进程，所以第二条指令就得以运行成功了。</p><p><strong>第二种解决方案</strong>，这是最常用的方法。把 libstack.so 所在的目录的绝对路径添加到配置文件 /etc/ld.so.conf（该文件当中每个路径占一行），然后运行 ldconfig 命令。</p><p>ldconfig 命令除了处理 /etc/ld.so.conf 中配置的目录之外，还处理一些默认目录，处理的过程主要是建立索引以便快速查找，处理之后生成 /etc/ld.so.cache 缓存文件，动态链接库就从这个缓存文件中搜索共享库，配置之后通过 ldd 就可以找到了</p><p><strong>第三种方法</strong>，就是把 libstack.so 复制到 /usr/lib或者/lib 目录之下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前一篇我们讲了静态库，我们来到了 链接阶段的最后一部分，事不宜迟继续我们今天的战斗。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;组成共享库的目标文件和一般的目标文件是有所不同的，在编译时要加 -fPIC 选项&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc -c -fPIC sta
      
    
    </summary>
    
      <category term="2017-6" scheme="http://yoursite.com/categories/2017-6/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言剖析————静态库</title>
    <link href="http://yoursite.com/2017/06/08/C%E8%AF%AD%E8%A8%80%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <id>http://yoursite.com/2017/06/08/C语言剖析————静态库/</id>
    <published>2017-06-08T11:34:40.000Z</published>
    <updated>2017-06-08T11:36:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候需要把一组代码编译成一个库，这个库在很多项目都要用到，例如 libc 就是这样一个库，我们在不同的程序中都会用到 libc 中定义的库函数（例如 printf（3）和全局变量 （例如 environ（3））。接下来的两篇的重点介绍如何创建这样的库，同时通过这样的方式，让我们来理解进一步理解</p><p>我们继续用 stack.c 的例子。为了便于理解，我们把 stack.c 拆分为是个 .c  文件（虽然实际情况下，这么做没有太大的必要），我们接下来用到的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/* stack.c */</div><div class="line">char stack[512];</div><div class="line">int top = -1;</div><div class="line"></div><div class="line">/* push.c */</div><div class="line">extern char stack[512];</div><div class="line">extern int top;</div><div class="line"></div><div class="line">void push(char c)&#123;</div><div class="line">    stack[++top] = c;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* pop.c */</div><div class="line">extern char stack[512];</div><div class="line">extern int top;</div><div class="line"></div><div class="line">char pop(void)&#123;</div><div class="line">    return stack[top--];</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* is_empty.c */</div><div class="line">extern int top;</div><div class="line">int is_empty(void)&#123;</div><div class="line">    return top == -1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* stack.h*/</div><div class="line"></div><div class="line">#ifndef STACK_H</div><div class="line">#define STACK_H</div><div class="line">extern void push(char);</div><div class="line">extern char pop(void);</div><div class="line">extern int is_empty(void);</div><div class="line">#endif</div><div class="line"></div><div class="line">/* main.c */</div><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &quot;stack.h&quot;</div><div class="line"></div><div class="line">int main(void)&#123;</div><div class="line">    push(&apos;a&apos;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>目录结构如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ tree</div><div class="line">.</div><div class="line">├── main.c</div><div class="line">└── stack</div><div class="line">    ├── is_empty.c</div><div class="line">    ├── pop.c</div><div class="line">    ├── push.c</div><div class="line">    ├── stack.c</div><div class="line">    └── stack.h</div><div class="line"></div><div class="line">1 directory, 6 files</div></pre></td></tr></table></figure></p><p>我们把 stack.c、push.c、pop.c、is_empty.c 编译成目标文件:</p><blockquote><p>$ gcc -c stack/stack.c stack/push.c stack/pop.c stack/is_empty.c</p></blockquote><p>然后打包成一个静态库 「 libstack.a 」</p><blockquote><p>$ ar rs libstack.a stack.o push.o pop.o is_empty.o<br>ar: 正在创建 libstack.a</p></blockquote><p>库文件都是以 lib 开头的，静态库以 .a 作为后缀，表示 Archive。ar命令类似于 tar 命令，也是用来打包的，但是把目标文件打成静态库的格式只能用 ar 命令而不能用 tar 命令。<br><strong>r 选项表示将后面的目标文件列表添加到文件包 libstack.a 中，如果 libstack.a 不存在就创建它，如果 libstack.a 中已有同名的目标文件就替换成新的。</strong><br><strong>s 选项表示为静态库创建索引。这个索引被链接器使用</strong></p><p>然后我们把 libstack.a 和 main.c 编译链接在一起</p><blockquote><p>$ gcc main.c -L. -lstack -Istack -o main</p></blockquote><p>-L 选项告诉编译器去哪里找需要的库文件，「 -L. 」表示在当前目录找。<br>-lstack 选项告诉编译器要链接 libstack 库， -I 选项告诉编译器去哪里找头文件。</p><p>注意，即使库文件就在当前目录，编译器默认也不会去找的，所以 「 -L. 」选项是不能少的。编译器默认去哪里找呢？可以使用 -print-search-dirs 选项查看一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ gcc -print-search-dirs</div><div class="line">install: /usr/lib/gcc/x86_64-linux-gnu/6/</div><div class="line">programs: =/usr/lib/gcc/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc</div><div class="line">/x86_64-linux-gnu/6/../../../../x86_64-linux-gnu/bin/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../../x86_64-linux-gnu/bin/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gn</div><div class="line">u/6/../../../../x86_64-linux-gnu/bin/</div><div class="line">libraries: =/usr/lib/gcc/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../../x86_64-linux-gnu/lib/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../../x86_64-lin</div><div class="line">ux-gnu/lib/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../../x86_64-linux-gnu/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-l</div><div class="line">inux-gnu/6/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../../lib/:/lib/x86_64-linux-gnu/6/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/6/:/usr/li</div><div class="line">b/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../../x86_64-linux-gnu/lib/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../:/lib/:/usr/lib/</div></pre></td></tr></table></figure><p>其中的 <strong>libraries</strong> 就是库文件的搜索路径列表，各路径之间用冒号隔开。在处理 -lstack 选项时， gcc 首先到 -L 选项指定的目录下查找，看有没有<strong>共享库</strong> libstack.so, 如果有就链接它，否则再找有没有<strong>静态库</strong> libstack.a 如果有链接它，如果还是没有，就到默认搜索路径下按同样的步骤查找。gcc 在链接时优先考虑共享库，其次才是静态库，如果希望 gcc 只考虑静态库，可以指定 -static 选项</p><h2 id="那么链接共享库和静态库有什么区别？"><a href="#那么链接共享库和静态库有什么区别？" class="headerlink" title="那么链接共享库和静态库有什么区别？"></a>那么链接共享库和静态库有什么区别？</h2><p>在之前我们说过，链接 libc 共享库时，链接器只是确认可执行 main 引用的某些符号在 libc 中有定义，并没有最终确定这些符号的地址，这些符号在可执行文件 main 中仍然是未定义符号，要在运行时做动态链接。而链接静态库时，链接器会把静态库中的目标文件取出来和可执行文件真正链接到一起。我们反汇编查看上一步生成的可执行文件 main</p><pre><code> 0000000000000660 &lt;main&gt;: 660:   55                      push   %rbp 661:   48 89 e5                mov    %rsp,%rbp 664:   bf 61 00 00 00          mov    $0x61,%edi 669:   e8 07 00 00 00          callq  675 &lt;push&gt; 66e:   b8 00 00 00 00          mov    $0x0,%eax 673:   5d                      pop    %rbp 674:   c3                      retq0000000000000675 &lt;push&gt;: 675:   55                      push   %rbp 676:   48 89 e5                mov    %rsp,%rbp 679:   89 f8                   mov    %edi,%eax 67b:   88 45 fc                mov    %al,-0x4(%rbp) 67e:   8b 05 8c 09 20 00       mov    0x20098c(%rip),%eax        # 201010 &lt;top&gt; 684:   83 c0 01                add    $0x1,%eax 687:   89 05 83 09 20 00       mov    %eax,0x200983(%rip)        # 201010 &lt;top&gt; 68d:   8b 05 7d 09 20 00       mov    0x20097d(%rip),%eax        # 201010 &lt;top&gt; 693:   48 63 d0                movslq %eax,%rdx 696:   48 8d 05 a3 09 20 00    lea    0x2009a3(%rip),%rax        # 201040 &lt;stack&gt; 69d:   0f b6 4d fc             movzbl -0x4(%rbp),%ecx 6a1:   88 0c 02                mov    %cl,(%rdx,%rax,1) 6a4:   90                      nop 6a5:   5d                      pop    %rbp 6a6:   c3                      retq 6a7:   66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1) 6ae:   00 0000000000000006b0 &lt;__libc_csu_init&gt;: 6b0:   41 57                   push   %r15 6b2:   41 56                   push   %r14 6b4:   41 89 ff                mov    %edi,%r15d ...</code></pre><p>有趣的是，main.c 只调用了 push 这个函数，所以链接生成的可执行文件中也只有 push 而没有 pop 和 is_empty。<strong>这是使用静态库的一个好处</strong>，链接器从静态库中只取出需要的目标文件来做链接，不需要的目标文件可不链接，如果直接把目标文件和 main.c 编译链接在一起，则没有用到的也会链接进来。另一个静态库的好处是只需要写一个库文件，而不需要写一长串目标文件名。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候需要把一组代码编译成一个库，这个库在很多项目都要用到，例如 libc 就是这样一个库，我们在不同的程序中都会用到 libc 中定义的库函数（例如 printf（3）和全局变量 （例如 environ（3））。接下来的两篇的重点介绍如何创建这样的库，同时通过这样的方式，
      
    
    </summary>
    
      <category term="2017-6" scheme="http://yoursite.com/categories/2017-6/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言剖析————头文件</title>
    <link href="http://yoursite.com/2017/06/08/C%E8%AF%AD%E8%A8%80%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/06/08/C语言剖析————头文件/</id>
    <published>2017-06-08T11:32:47.000Z</published>
    <updated>2017-06-08T11:33:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们这一篇继续讨论，前面关于 stack.c 和 main.c 的讨论。stack.c 这个模块封装了 top 和 stack 两个变量，导出了 push、pop、pop、is_empty 三个函数接口，已经设计的比较完善。但是使用这个模块的每一个 .c 文件都要写三个函数声明，如果要用的文件中方法再多一点的话 或者 要有多个文件使用这个的话，我们应该尽量避免重复代码的出现。在这里我们可以使用「 头文件 」来进行解决。</p><p>我们来自己写一个头文件 stack.h:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* stack.h */</div><div class="line">#ifndef STACK_H</div><div class="line">#define STACK_H</div><div class="line"></div><div class="line">extern void push(char);</div><div class="line">extern char pop(void);</div><div class="line">extern int is_empty(void);</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure></p><p>然后我们在 main.c 函数当中包含我们的 stack.h ，我们就可以不用写那三个声明了，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/* main.c */</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &quot;stack.h&quot;</div><div class="line"></div><div class="line">extern void push(char);</div><div class="line">extern char pop(void);</div><div class="line">extern int is_empty(void);</div><div class="line"></div><div class="line">int main(void)&#123;</div><div class="line">    push(&apos;a&apos;);</div><div class="line">    push(&apos;b&apos;);</div><div class="line">    push(&apos;c&apos;);</div><div class="line"></div><div class="line">    while(!is_empty())</div><div class="line">    putchar(pop());</div><div class="line">    putchar(&apos;\n&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>无形当中，我们又抛出了几个问题，不过下面我会一一进行解答。</p><p>首先说为什么 #include <stdio.h> 是用角括号，而 #include “stack.h” 用引号？</stdio.h></p><p>对于用角括号包含的头文件来说，gcc 首先查找 -I 选项指定的目录，然后查找系统的头文件目录，而对于 引号 包含的头文件，gcc 首先<strong>查找这个头文件的当前文件所在的目录</strong>，然后<strong>查找 -I 选项指定的目录，然后查找系统的头文件目录</strong></p><p>比如说，我们三个文件都放在同一个目录下面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> jianran@jianran:~/桌面/x86HB$ tree</div><div class="line">.</div><div class="line">├── main.c</div><div class="line">├── stack.c</div><div class="line">└── stack.h</div><div class="line">0 directories, 3 files</div></pre></td></tr></table></figure></p><p>则可以用 gcc -c main.c 编译，gcc 会自动在 main.c 所在的目录中找到 stack.h。加入我们把 stack.h 和 stack.h 移动到一个子目录下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ tree</div><div class="line">.</div><div class="line">├── main.c</div><div class="line">└── stack</div><div class="line">    ├── stack.c</div><div class="line">    └── stack.h</div><div class="line">1 directory, 3 files</div></pre></td></tr></table></figure></p><p>如果像这样一样，我们就必须给 -I 指定参数 gcc -c main.c -Istack, 让我们去告诉 gcc 头文件要到子目录 stack 中找。</p><p>在 #include 预处理指示中可以使用相对路径，比如 #include “stack/stack.h”，那么就不需要加 -Istack 选项了，同时我们应该注意的是，相对路径是相对与当前工作目录的路径，而不是当前文件所在路径</p><p>接着我们继续来回到 stack.h 中我们又看到两个新的预处理命令 #ifndef STACK_H 和 #endif，意思是说，如果 STACK_H  这个宏没有定义过，那么从 #ifndef 到 #endif 之间的代码就包含在预处理的输出结果中，否则这段代码就不会出现在预处理的结果当中。如果在包含这个头文件时 STACK_H 这个宏已经定义了，则相当于这个头文件里面什么都没有，只是包含了一个空文件。这个有什么用呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &quot;stack.h&quot;</div><div class="line">#include &quot;stack.h&quot;</div><div class="line"> </div><div class="line">int main(void)&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第一次包含 stack.h 时并没有定义 STACK_H 这个宏，因此头文件的内容包含在预处理的输出结果中，处理完的结果就像如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#define STACK_H</div><div class="line"></div><div class="line">extern void push(char);</div><div class="line">extern char pop(void);</div><div class="line">extern int is_empty(void);</div><div class="line">#include &quot;stack.h&quot;</div><div class="line"></div><div class="line"></div><div class="line">int main(void)&#123;</div><div class="line">    push(&apos;a&apos;);</div><div class="line">    push(&apos;b&apos;);</div><div class="line">    push(&apos;c&apos;);</div><div class="line"></div><div class="line">    while(!is_empty())</div><div class="line">    putchar(pop());</div><div class="line">    putchar(&apos;\n&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当我们继续处理 第二个 #include “stack.h” 的时候，因为我们已经定义过了 STACK_H, stack.h 在这一次就被看成了一个空文件。这种保护头文件的写法称为 Header Guard 以后我们写的每个头文件都要加上 Header Guard</p><hr><p>接下来我们总结一下包含头文件主要有的问题：</p><ol><li>预处理编译的速度变慢，要处理很多本来不需要处理的代码。</li><li>如果不小心出现 foo.h 包含 bar.h 、 bar.h 又包含 foo.h 的情况，就陷入死循环。一般编译器都会规定一个包含层次的上限，超过这个上限就会报错</li><li>头文件里面有些代码是不允许被重复出现的，虽然变量和函数允许被多次声明，但是头文件中一些代码是不允许多次出现的，比如用 teypef 定义一个类型名，在一个编译单元只允许定义一次。</li></ol><p>还有一个问题，既然要 #include 头文件，那我不如直接在 main.c 中 #include “stack.h” 得了。这样 stack.c 和 main.c 合并成一个编译单元了，就算我们用 gcc main.c -o main 命令也是可以编译通过了，这样岂不是更加简单吗？</p><p>假如又有一个 foo.c（main.c 要用到 foo.c) 也要用 stack.c 这个模块怎么办？如果再让 foo.c 也 #include “stack.c” 就相当与 push、pop、is_empty 这三个函数 在 main.c 和 foo.c 都有了定义，那么mian.c 和 foo.c 在一起 就不能编译通过, 如果采用头文件的方法，只需要定义一次就全部搞定了。</p><hr><p>写 .c 文件和 头文件时应该遵循以下原则:</p><ul><li><p>.c 文件中可以有变量或函数定义，而 .h 文件中应该只有函数或变量声明而没有定义</p></li><li><p>不要把一个 .c 文件包含到另外一个 .c 文件中</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们这一篇继续讨论，前面关于 stack.c 和 main.c 的讨论。stack.c 这个模块封装了 top 和 stack 两个变量，导出了 push、pop、pop、is_empty 三个函数接口，已经设计的比较完善。但是使用这个模块的每一个 .c 文件都要写三个函数
      
    
    </summary>
    
      <category term="2017-6" scheme="http://yoursite.com/categories/2017-6/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言剖析————标识符的链接属性</title>
    <link href="http://yoursite.com/2017/06/08/C%E8%AF%AD%E8%A8%80%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2017/06/08/C语言剖析————标识符的链接属性/</id>
    <published>2017-06-08T09:35:13.000Z</published>
    <updated>2017-06-08T09:35:49.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>外部链接（External Linkage），一个标识符在不同的编译单元中可能被声明多次，当这些编译单元链接到可执行时，如果这些声明都代表同一个变量或函数（即代表同一个内存地址），则这个标识符具有 External Linkage。具有 External Linkage 的标识符编译后在目标文件中是全局符号。</p></li><li><p>内部链接（Internal Linkage），一个标识符在某个编译单元中可能被声明多次，这些声明都代表同一个内存地址，但如果这个标识符在不同的编译单元中被声明多次，在链接时这些声明就不代表同一个内存地址，这样的标示具有 Internal Linkage。也就是说在链接时不做符号解析</p></li><li><p>无链接属性（No Linkage）。除以上情况之外的标识符都属于 No Linkage， 例如函数的局部变量，以及不表示变量和函数的其他标示符。除了函数、全局变量、静态变量之外的标识符在编译时不会变成符号，所以没有链接属性</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;外部链接（External Linkage），一个标识符在不同的编译单元中可能被声明多次，当这些编译单元链接到可执行时，如果这些声明都代表同一个变量或函数（即代表同一个内存地址），则这个标识符具有 External Linkage。具有 External 
      
    
    </summary>
    
      <category term="2017-6" scheme="http://yoursite.com/categories/2017-6/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言剖析————定义与声明</title>
    <link href="http://yoursite.com/2017/06/06/C%E8%AF%AD%E8%A8%80%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E/"/>
    <id>http://yoursite.com/2017/06/06/C语言剖析————定义与声明/</id>
    <published>2017-06-06T12:03:55.000Z</published>
    <updated>2017-06-06T12:04:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>#extern 和 static 关键字</p><p>在前面一篇当中我们把两个 .c 文件（main.c 和 stack.c)放在一起编译, mian.c 用到的函数 push、pop 和 is_empty 由 stack.c 提供，虽然可以运行但是他会报告处出三个警告。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">W</div><div class="line">jianran@jianran:~/桌面/x86HB$ gcc main.c stack.c</div><div class="line">main.c: In function ‘main’:</div><div class="line">main.c:6:5: warning: implicit declaration of function ‘push’ [-Wimplicit-function-declaration]</div><div class="line">     push(&apos;a&apos;);</div><div class="line">     ^~~~</div><div class="line">main.c:10:12: warning: implicit declaration of function ‘is_empty’ [-Wimplicit-function-declaration]</div><div class="line">     while(!is_empty())</div><div class="line">            ^~~~~~~~</div><div class="line">main.c:11:13: warning: implicit declaration of function ‘pop’ [-Wimplicit-function-declaration]</div><div class="line">     putchar(pop());</div><div class="line">             ^~~</div></pre></td></tr></table></figure><p>警告的原因是：「编译器在处理 main.c 中的函数调用时找不到函数原型」，也就不知道函数的参数和返回值类型，而只能根据函数调用的实参做隐式的声明，并假定返回值是 int 型。编译器把这三个函数隐式声明为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int push(char);</div><div class="line">int pop(void);</div><div class="line">int is_empty(void);</div></pre></td></tr></table></figure></p><p>为什么编译器在处理函数调用时需要知道函数原型？<br>因为必须知道参数的类型和个数以及返回值类型才能知道应该生成应该生成什么样的指令。</p><p>如果光使用 隐式声明 是靠不住的。因为 隐式声明是根据函数调用代码推测的，<br>    第一，函数的形参类型可能跟实参类型不一样；<br>    第二，如果函数定义带有可变参数（例如：printf), 从函数调用代码也看不出它带可变参数；<br>    第三，从函数调用看不出返回值应该是什么类型，隐式声明只能假定返回值都是 int 类型的。</p><p>既然隐式声明靠不住，那编译器为什么不自己去找函数定义，而非要我们在调用前提供函数原型呢？因为编译压根不知道去哪里找函数定义。</p><p>现在我们来在 mian.c 中声明这几个函数的原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* main.c */</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line"></div><div class="line">extern void push(char);</div><div class="line">extern char pop(void);</div><div class="line">extern int is_empty(void);</div><div class="line"></div><div class="line">int main(void)&#123;</div><div class="line">    push(&apos;a&apos;);</div><div class="line">    push(&apos;b&apos;);</div><div class="line">    push(&apos;c&apos;);</div><div class="line"></div><div class="line">    while(!is_empty())</div><div class="line">    putchar(pop());</div><div class="line">    putchar(&apos;\n&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样编译器就不会报警了。用 extern 关键字修饰的函数名具有 External Linkage。push 这个标示符具有 External Linkage 指的是：push 在 main.c 和 stack.c 中都有声明（stack.c 中的声明同时也是定义），如果把 main.c 和 stack.c 链接在一起，那么这些声明指的是同一个函数，在链接时，各目标文件中的全局符号 push 代表 同一个地址，函数声明中的 extern 关键字也可以省略不写。</p><p>用 static 关键字修饰的函数名具有 Internal Linkage。例如 有以下两个 .c 文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* foo.c */</div><div class="line">static void foo(void)&#123;&#125;</div><div class="line">/* main.c */</div><div class="line">void foo(void);</div><div class="line">int main(void)&#123; foo(); return 0; &#125;</div></pre></td></tr></table></figure></p><p>编译链接在一起会出错。虽然 foo.c 中定义了函数 foo 。 但是这个函数名只有 Internal Linkage，只有在 foo.c 中引用这个函数名才表示同一个函数，而在 main.c 中声明的哪个 foo.c 应该表示一个具有 External Linkage 的函数名。如果把 foo.c 编译成目标文件，函数名 foo 在其中是一个局部符号，在链接时不参与「 符号解析 」。所以，在 main.c 中引用了一个具有 External Linkage 的函数名 foo，但是链接器却找不到它的定义在哪，无法确定它的地址，只好报错。凡是被多次声明的变量或函数，必须有且只有一个声明是定义，如果有多个定义，或者一个定义都没有，链接器就无法完成链接。</p><p>以上讲了用 static 和 extern 修饰函数声明的情况，现在来看用它们修饰变量声明的情况，仍然用 stack.c 和 main.c 的例子，如果我想在 main.c 中直接访问 stack.c 定义的变量 top，可以用 extern 声明它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/* main.c */</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line"></div><div class="line">void push(char);</div><div class="line">char pop(void);</div><div class="line">int is_empty(void);</div><div class="line">extern int top;</div><div class="line"></div><div class="line">int main(void)&#123;</div><div class="line">    push(&apos;a&apos;);</div><div class="line">    push(&apos;b&apos;);</div><div class="line">    push(&apos;c&apos;);</div><div class="line"></div><div class="line">    while(!is_empty())</div><div class="line">    putchar(pop());</div><div class="line">    putchar(&apos;\n&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>变量 top 具有 External Linkage，extern int top 只是一个声明而不是定义，因为 它 不在 main.c 中分配存储空间，而是在 stack.c 中定义和分配存储空间， main.c 只是引用 这个变量名。以上这些函数和变量名也可以写在 main 函数体当中，使得声明的标识符具有块作用域。</p><blockquote><p>变量声明和函数声明有一点不同，函数声明的 extern 关键字可以被省去而变量声明没有写 extern 意思就完全变了，如果 extertn int top 没有了 extern 那么就相当与定义了一个局部变量 top。另外，变量定义可以初始化而声明却不可以</p></blockquote><p>在 main.c 中可以通过 extern 声明来访问 stack.c 中的变量 top ，但是从 实现 stack.c这个模板来看，top 这个变量是不希望被外界访问到的，变量 top 和 stack 都属于这个模块的内部状态，外界应该只允许通过 push、pop函数来改变模块的内部状态，这样才能保证 堆栈 的特性，那么应该怎么样来阻止外界来访问 top 和 stack 呢？ 答案就是用static 关键字把他们声明为 Internal Linkage</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/* stack.c */</div><div class="line">static char stack[512];</div><div class="line">static int top = -1;</div><div class="line"></div><div class="line">void push(char c)&#123;</div><div class="line">stack[++top] = c;</div><div class="line">&#125;</div><div class="line"></div><div class="line">char pop(void)&#123;</div><div class="line">return stack[top--];</div><div class="line">&#125;</div><div class="line"></div><div class="line">int is_empty(void)&#123;</div><div class="line">return top == -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样，即使在 main.c 中用 extern 声明也访问不到 stack.c 的变量 top 和 stack，从而保护了 stack.c 模块的内部状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#extern 和 static 关键字&lt;/p&gt;
&lt;p&gt;在前面一篇当中我们把两个 .c 文件（main.c 和 stack.c)放在一起编译, mian.c 用到的函数 push、pop 和 is_empty 由 stack.c 提供，虽然可以运行但是他会报告处出三个警告。
      
    
    </summary>
    
      <category term="2017-6" scheme="http://yoursite.com/categories/2017-6/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言剖析————多目标文件的链接</title>
    <link href="http://yoursite.com/2017/06/04/C%E8%AF%AD%E8%A8%80%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%A4%9A%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2017/06/04/C语言剖析————多目标文件的链接/</id>
    <published>2017-06-04T02:55:22.000Z</published>
    <updated>2017-06-04T03:00:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>正如题目，多文件～，我们需要自己创造一些多文件，同时这些文件在未来几天文章当中都会使用，以后我就直接引用不进行说明了。</p><hr><p>目前我们在同一个文件夹下创建 stack.c 和 main.c 文件，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* stack.c */</div><div class="line">char stack[512];</div><div class="line">int top = -1;</div><div class="line"></div><div class="line">void push(char c)&#123;</div><div class="line">    stack[++top] = c;</div><div class="line">&#125;</div><div class="line"></div><div class="line">char pop(void)&#123;</div><div class="line">    return stack[top--];</div><div class="line">&#125;</div><div class="line"></div><div class="line">int is_empty(void)&#123;</div><div class="line">    return top == -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/* main.c */</div><div class="line">#include&lt;stdio.h&gt;</div><div class="line"></div><div class="line">int a,b = 1;</div><div class="line"></div><div class="line">int main(void)&#123;</div><div class="line">    push(&apos;a&apos;);</div><div class="line">    push(&apos;b&apos;);</div><div class="line">    push(&apos;c&apos;);</div><div class="line"></div><div class="line">    while(!is_empty())</div><div class="line">    putchar(pop());</div><div class="line">    putchar(&apos;\n&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>a 和 b 两个变量没有用到，这个只是在未来说明链接过程才加上的。编译过程和以前一样，可以一步编译也可以多步编译，这里我们选择多步（都是一样的）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ gcc -c main.c</div><div class="line">$ gcc -c stack.c</div><div class="line">$ gcc main.o stack.o -o main</div><div class="line">```  </div><div class="line">如果用 nm 命令查看目标文件的符号表，会发现 main.o，中会有未定义的符号 push、pop、is_empty、putchar。前三个符号在 stack.o 中定义了，在链接时做符号解析：而 putchar 是 libc 的库函数，在可执行文件 main 中仍然是未定义的。要在程序运行时做**动态链接**</div><div class="line"></div><div class="line">通过 readelf -a main 命令可以看到 main 的 .bss段 合并了 main.o 和 stack.o 的 .bss段，其中包含了变量 a 和 stack; main 的 .data段合并了 main.o 和 stack.o 的 .data段，其中包含了变量 b 和 top; main 的 .text段 合并了 main.o 和 stack.o 的 .text段，包含了各函数的指令。多个目标文件的链接如下图所示:</div><div class="line">![](http://ww1.sinaimg.cn/large/b36c7eebgy1fg6xf7vn2jj20ig0ld41d.jpg)</div><div class="line"></div><div class="line">为什么在可执行文件 main 的每一段中来自 main.o 的变量或函数都在前面，而来自 stack.o 的变量或函数都在后面呢？我们可以试着把 gcc 命令中 两个目标文件反过来写:</div><div class="line"></div><div class="line">    gcc stack.o main.o -o main</div><div class="line">    </div><div class="line">可执行文件 main 的每一段中来自 main.o 的变量或者函数 都排在后面了。实际上，**链接过程是由一个链接脚本控制的，链接脚本决定了给每个段分配什么地址，如何对齐、哪个段在前哪个在后、哪些段合并到同一个 Segment。**另外链接脚本还要把一些特殊地址定义为符号，例如 _bss_start 代表 .bss 段的起始地址，_end 代表 _bss段 的结束地址，这些符号会出现**在可执行文件**的符号表中，加载器可以由这些符号得知 .bss 段的地址范围，以便把它清零，如果用 ld 进行链接时没有通过 -T 选项指定链接脚本，则使用 ld 的默认链接脚本，默认链接脚本可以使用 **ld --verbose**</div><div class="line">查看：</div></pre></td></tr></table></figure></p><p>$ ld –verbose<br>…<br>/<em> Script for -z combreloc: combine and sort reloc sections </em>/<br>/<em> Copyright (C) 2014-2017 Free Software Foundation, Inc.<br>   Copying and distribution of this script, with or without modification,<br>   are permitted in any medium without royalty provided the copyright<br>   notice and this notice are preserved.  </em>/<br>OUTPUT_FORMAT(“elf64-x86-64”, “elf64-x86-64”,<br>          “elf64-x86-64”)<br>OUTPUT_ARCH(i386:x86-64)<br>ENTRY(_start)<br>SEARCH_DIR(“=/usr/local/lib/x86_64-linux-gnu”); SEARCH_DIR(“=/lib/x86_64-linux-gnu”); SEARCH_DIR(“=/usr/lib/x86_64-linux-gnu”); SEARCH_DIR(“=/usr/local/lib64”); SEARCH_DIR(“=/lib64”); SEARCH_DIR(“=/usr/lib64”); SEARCH_DIR(“=/usr/local/lib”); SEARCH_DIR(“=/lib”); SEARCH_DIR(“=/usr/lib”); SEARCH_DIR(“=/usr/x86_64-linux-gnu/lib64”); SEARCH_DIR(“=/usr/x86_64-linux-gnu/lib”);<br>SECTIONS<br>{<br>  /<em> Read-only sections, merged into text segment: </em>/<br>  PROVIDE (<strong>executable_start = SEGMENT_START(“text-segment”, 0x400000)); . = SEGMENT_START(“text-segment”, 0x400000) + SIZEOF_HEADERS;<br>  .interp         : { <em>(.interp) }<br>  .note.gnu.build-id : { </em>(.note.gnu.build-id) }<br>  .hash           : { <em>(.hash) }<br>  .gnu.hash       : { </em>(.gnu.hash) }<br>  .dynsym         : { <em>(.dynsym) }<br>  .dynstr         : { </em>(.dynstr) }<br>  .gnu.version    : { <em>(.gnu.version) }<br>  .gnu.version_d  : { </em>(.gnu.version_d) }<br>  .gnu.version_r  : { <em>(.gnu.version_r) }<br>  .rela.dyn       :<br>    {      </em>(.rela.init)<br>      <em>(.rela.text .rela.text.</em> .rela.gnu.linkonce.t.<em>)      </em>(.rela.fini)<br>      <em>(.rela.rodata .rela.rodata.</em> .rela.gnu.linkonce.r.<em>)      </em>(.rela.data .rela.data.<em> .rela.gnu.linkonce.d.</em>)<br>      <em>(.rela.tdata .rela.tdata.</em> .rela.gnu.linkonce.td.<em>)      </em>(.rela.tbss .rela.tbss.<em> .rela.gnu.linkonce.tb.</em>)<br>      <em>(.rela.ctors)      </em>(.rela.dtors)<br>      <em>(.rela.got)      </em>(.rela.bss .rela.bss.<em> .rela.gnu.linkonce.b.</em>)<br>      <em>(.rela.ldata .rela.ldata.</em> .rela.gnu.linkonce.l.<em>)      </em>(.rela.lbss .rela.lbss.<em> .rela.gnu.linkonce.lb.</em>)<br>      <em>(.rela.lrodata .rela.lrodata.</em> .rela.gnu.linkonce.lr.<em>)      </em>(.rela.ifunc)<br>    }<br>  .rela.plt       :<br>    {<br>      *(.rela.plt)<br>      PROVIDE_HIDDEN (</strong>rela_iplt_start = .);<br>      <em>(.rela.iplt)<br>      PROVIDE_HIDDEN (__rela_iplt_end = .);<br>    }<br>  .init           :<br>  {<br>    KEEP (</em>(SORT_NONE(.init)))<br>  }<br>  .plt            : { <em>(.plt) </em>(.iplt) }<br>.plt.got        : { <em>(.plt.got) }<br>.plt.bnd        : { </em>(.plt.bnd) }<br>  .text           :<br>  {<br>    <em>(.text.unlikely .text.</em>_unlikely .text.unlikely.<em>)    </em>(.text.exit .text.exit.<em>)    </em>(.text.startup .text.startup.<em>)    </em>(.text.hot .text.hot.<em>)    </em>(.text .stub .text.<em> .gnu.linkonce.t.</em>)<br>    /<em> .gnu.warning sections are handled specially by elf32.em.  </em>/<br>    <em>(.gnu.warning)<br>  }<br>  .fini           :<br>  {<br>    KEEP (</em>(SORT_NONE(.fini)))<br>  }<br>  PROVIDE (<strong>etext = .);<br>  PROVIDE (_etext = .);<br>  PROVIDE (etext = .);<br>  .rodata         : { <em>(.rodata .rodata.</em> .gnu.linkonce.r.<em>) }<br>  .rodata1        : { </em>(.rodata1) }<br>  .eh_frame_hdr : { <em>(.eh_frame_hdr) </em>(.eh_frame_entry .eh_frame_entry.<em>) }<br>  .eh_frame       : ONLY_IF_RO { KEEP (</em>(.eh_frame)) <em>(.eh_frame.</em>) }<br>  .gcc_except_table   : ONLY_IF_RO { <em>(.gcc_except_table<br>  .gcc_except_table.</em>) }<br>  .gnu_extab   : ONLY_IF_RO { <em>(.gnu_extab</em>) }<br>  /<em> These sections are generated by the Sun/Oracle C++ compiler.  </em>/<br>  .exception_ranges   : ONLY_IF_RO { <em>(.exception_ranges<br>  .exception_ranges</em>) }<br>  /<em> Adjust the address for the data segment.  We want to adjust up to<br>     the same address within the page on the next page up.  </em>/<br>  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));<br>  /<em> Exception handling  </em>/<br>  .eh_frame       : ONLY_IF_RW { KEEP (<em>(.eh_frame)) </em>(.eh_frame.<em>) }<br>  .gnu_extab      : ONLY_IF_RW { </em>(.gnu_extab) }<br>  .gcc_except_table   : ONLY_IF_RW { <em>(.gcc_except_table .gcc_except_table.</em>) }<br>  .exception_ranges   : ONLY_IF_RW { <em>(.exception_ranges .exception_ranges</em>) }<br>  /<em> Thread Local Storage sections  </em>/<br>  .tdata      : { <em>(.tdata .tdata.</em> .gnu.linkonce.td.<em>) }<br>  .tbss          : { </em>(.tbss .tbss.<em> .gnu.linkonce.tb.</em>) *(.tcommon) }<br>  .preinit_array     :<br>  {<br>    PROVIDE_HIDDEN (</strong>preinit_array_start = .);<br>    KEEP (<em>(.preinit_array))<br>    PROVIDE_HIDDEN (<strong>preinit_array_end = .);<br>  }<br>  .init_array     :<br>  {<br>    PROVIDE_HIDDEN (</strong>init_array_start = .);<br>    KEEP (</em>(SORT_BY_INIT_PRIORITY(.init_array.<em>) SORT_BY_INIT_PRIORITY(.ctors.</em>)))<br>    KEEP (<em>(.init_array EXCLUDE_FILE (</em>crtbegin.o <em>crtbegin?.o </em>crtend.o <em>crtend?.o ) .ctors))<br>    PROVIDE_HIDDEN (<strong>init_array_end = .);<br>  }<br>  .fini_array     :<br>  {<br>    PROVIDE_HIDDEN (</strong>fini_array_start = .);<br>    KEEP (</em>(SORT_BY_INIT_PRIORITY(.fini_array.<em>) SORT_BY_INIT_PRIORITY(.dtors.</em>)))<br>    KEEP (<em>(.fini_array EXCLUDE_FILE (</em>crtbegin.o <em>crtbegin?.o </em>crtend.o <em>crtend?.o ) .dtors))<br>    PROVIDE_HIDDEN (__fini_array_end = .);<br>  }<br>  .ctors          :<br>  {<br>    /</em> gcc uses crtbegin.o to find the start of<br>       the constructors, so we make sure it is<br>       first.  Because this is a wildcard, it<br>       doesn’t matter if the user does not<br>       actually link against crtbegin.o; the<br>       linker won’t look for a file to match a<br>       wildcard.  The wildcard also means that it<br>       doesn’t matter which directory crtbegin.o<br>       is in.  <em>/<br>    KEEP (</em>crtbegin.o(.ctors))<br>    KEEP (<em>crtbegin?.o(.ctors))<br>    /</em> We don’t want to include the .ctor section from<br>       the crtend.o file until after the sorted ctors.<br>       The .ctor section from the crtend file contains the<br>       end of ctors marker and it must be last <em>/<br>    KEEP (</em>(EXCLUDE_FILE (<em>crtend.o </em>crtend?.o ) .ctors))<br>    KEEP (<em>(SORT(.ctors.</em>)))<br>    KEEP (<em>(.ctors))<br>  }<br>  .dtors          :<br>  {<br>    KEEP (</em>crtbegin.o(.dtors))<br>    KEEP (<em>crtbegin?.o(.dtors))<br>    KEEP (</em>(EXCLUDE_FILE (<em>crtend.o </em>crtend?.o ) .dtors))<br>    KEEP (<em>(SORT(.dtors.</em>)))<br>    KEEP (<em>(.dtors))<br>  }<br>  .jcr            : { KEEP (</em>(.jcr)) }<br>  .data.rel.ro : { <em>(.data.rel.ro.local</em> .gnu.linkonce.d.rel.ro.local.<em>) </em>(.data.rel.ro .data.rel.ro.<em> .gnu.linkonce.d.rel.ro.</em>) }<br>  .dynamic        : { <em>(.dynamic) }<br>  .got            : { </em>(.got) <em>(.igot) }<br>  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) &gt;= 24 ? 24 : 0, .);<br>  .got.plt        : { </em>(.got.plt)  <em>(.igot.plt) }<br>  .data           :<br>  {    </em>(.data .data.<em> .gnu.linkonce.d.</em>)<br>    SORT(CONSTRUCTORS)<br>  }<br>  .data1          : { <em>(.data1) }<br>  _edata = .; PROVIDE (edata = .);<br>  . = .;<br>  __bss_start = .;<br>  .bss            :<br>  {   </em>(.dynbss)<br>   <em>(.bss .bss.</em> .gnu.linkonce.b.<em>)   </em>(COMMON)<br>   /<em> Align here to ensure that the .bss section occupies space up to<br>      _end.  Align after .bss to ensure correct alignment even if the<br>      .bss section disappears because there are no input sections.<br>      FIXME: Why do we need it? When there is no .bss section, we don’t<br>      pad the .data section.  </em>/<br>   . = ALIGN(. != 0 ? 64 / 8 : 1);<br>  }<br>  .lbss   :<br>  {<br>    <em>(.dynlbss)    </em>(.lbss .lbss.<em> .gnu.linkonce.lb.</em>)<br>    <em>(LARGE_COMMON)<br>  }<br>  . = ALIGN(64 / 8);<br>  . = SEGMENT_START(“ldata-segment”, .);<br>  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. &amp; (CONSTANT (MAXPAGESIZE) - 1)) :<br>  {    </em>(.lrodata .lrodata.<em> .gnu.linkonce.lr.</em>)<br>  }<br>  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. &amp; (CONSTANT (MAXPAGESIZE) - 1)) :<br>  {<br>    <em>(.ldata .ldata.</em> .gnu.linkonce.l.<em>)<br>    . = ALIGN(. != 0 ? 64 / 8 : 1);<br>  }<br>  . = ALIGN(64 / 8);<br>  _end = .; PROVIDE (end = .);<br>  . = DATA_SEGMENT_END (.);<br>  /</em> Stabs debugging sections.  <em>/<br>  .stab          0 : { </em>(.stab) }<br>  .stabstr       0 : { <em>(.stabstr) }<br>  .stab.excl     0 : { </em>(.stab.excl) }<br>  .stab.exclstr  0 : { <em>(.stab.exclstr) }<br>  .stab.index    0 : { </em>(.stab.index) }<br>  .stab.indexstr 0 : { <em>(.stab.indexstr) }<br>  .comment       0 : { </em>(.comment) }<br>  /<em> DWARF debug sections.<br>     Symbols in the DWARF debugging sections are relative to the beginning<br>     of the section so we begin them at 0.  </em>/<br>  /<em> DWARF 1 </em>/<br>  .debug          0 : { <em>(.debug) }<br>  .line           0 : { </em>(.line) }<br>  /<em> GNU DWARF 1 extensions </em>/<br>  .debug_srcinfo  0 : { <em>(.debug_srcinfo) }<br>  .debug_sfnames  0 : { </em>(.debug_sfnames) }<br>  /<em> DWARF 1.1 and DWARF 2 </em>/<br>  .debug_aranges  0 : { <em>(.debug_aranges) }<br>  .debug_pubnames 0 : { </em>(.debug_pubnames) }<br>  /<em> DWARF 2 </em>/<br>  .debug_info     0 : { <em>(.debug_info .gnu.linkonce.wi.</em>) }<br>  .debug_abbrev   0 : { <em>(.debug_abbrev) }<br>  .debug_line     0 : { </em>(.debug_line .debug_line.<em> .debug_line_end ) }<br>  .debug_frame    0 : { </em>(.debug_frame) }<br>  .debug_str      0 : { <em>(.debug_str) }<br>  .debug_loc      0 : { </em>(.debug_loc) }<br>  .debug_macinfo  0 : { <em>(.debug_macinfo) }<br>  /</em> SGI/MIPS DWARF 2 extensions <em>/<br>  .debug_weaknames 0 : { </em>(.debug_weaknames) }<br>  .debug_funcnames 0 : { <em>(.debug_funcnames) }<br>  .debug_typenames 0 : { </em>(.debug_typenames) }<br>  .debug_varnames  0 : { <em>(.debug_varnames) }<br>  /</em> DWARF 3 <em>/<br>  .debug_pubtypes 0 : { </em>(.debug_pubtypes) }<br>  .debug_ranges   0 : { <em>(.debug_ranges) }<br>  /</em> DWARF Extension.  <em>/<br>  .debug_macro    0 : { </em>(.debug_macro) }<br>  .debug_addr     0 : { <em>(.debug_addr) }<br>  .gnu.attributes 0 : { KEEP (</em>(.gnu.attributes)) }<br>  /DISCARD/ : { <em>(.note.GNU-stack) </em>(.gnu<em>debuglink) *(.gnu.lto</em>*) }<br>}</p><p>==================================================</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ENTRY(_start) 指明整个程序的入口点是 _start,这并不是规定是的，修改链接脚本就可以改用其他符号做入口点。</div></pre></td></tr></table></figure><p>/<em> Read-only sections, merged into text segment: </em>/<br>  PROVIDE (__executable_start = SEGMENT_START(“text-segment”, 0x400000)); . = SEGMENT_START(“text-segment”, 0x400000) + SIZEOF_HEADERS;<br>  .interp         : { <em>(.interp) }<br>  .note.gnu.build-id : { </em>(.note.gnu.build-id) }<br>  .hash           : { *(.hash) }<br>  …<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0x400000 是 Text Segment的其实地址，开头有 SIZEOF_HEADERS 个字节是文件头，「 . 」表示链接器处理的当前地址，「 . = SEGMENT_START(&quot;text-segment&quot;, 0x400000) + SIZEOF_HEADERS 」表示把当前地址改成 Text Segment 中文件头之后的地址，接下来的几行指示链接器从这个地址开始组装几个段，依次是 .interp段、 .note.gnu.build-id段 等等，其中包含我们熟悉的 .plt段、.text段、.rodata段，这些段的描述格式都是 段名 ： &#123; 组成 &#125;</div></pre></td></tr></table></figure></p><p> /<em> Adjust the address for the data segment.  We want to adjust up to<br>     the same address within the page on the next page up.  </em>/<br>  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));</p><p>```<br> 通过这个计算处 Data Segment 的地址，从这个地址开始组装后面链接脚本列出的几个段, 例如 .data段和 .bss 段</p><p> 在 Data Segment 后面还有其他的 Segment ,主要是调试信息，关于链接脚本就简单介绍到这里，以上内容了解即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正如题目，多文件～，我们需要自己创造一些多文件，同时这些文件在未来几天文章当中都会使用，以后我就直接引用不进行说明了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;目前我们在同一个文件夹下创建 stack.c 和 main.c 文件，内容如下&lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="2017-6" scheme="http://yoursite.com/categories/2017-6/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言剖析————main函数、启动历程和退出状态</title>
    <link href="http://yoursite.com/2017/06/03/C%E8%AF%AD%E8%A8%80%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E2%80%94%E2%80%94main%E5%87%BD%E6%95%B0%E3%80%81%E5%90%AF%E5%8A%A8%E5%8E%86%E7%A8%8B%E5%92%8C%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2017/06/03/C语言剖析————main函数、启动历程和退出状态/</id>
    <published>2017-06-03T12:22:41.000Z</published>
    <updated>2017-06-04T01:09:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>为什么汇编程序入口是 _start 而 C程序 的入口是 main函数 呢？ 要弄清楚这个问题，首先要理解 gcc 的编译步骤。以前我们常用 gcc main.c -o main 命令编译一个程序，其实也可以分三步来走：<strong>第一步生成 汇编代码，第二步 生成目标文件，第三步 生成可执行文件</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ gcc -S main.c       #生成汇编文件</div><div class="line">$ gcc -c main.s       #生成目标文件</div><div class="line">$ gcc main.o          #生成可执行文件</div></pre></td></tr></table></figure><p>-S 生成 汇编代码，-c 生成目标文件，-E 只做预处理而不进行编译，如果这些选项都不加，则 gcc 执行完成的编译步骤，直到最后链接生成可执行文件。</p><p>这些选项都可以和 -o 搭配使用，给输出文件重新命名而不使用 gcc 默认的输出文件名。</p><pre><code>gcc main.c -o main</code></pre><p>在 gcc 内部也要分三步来走，同时 gcc 是一个外壳，在具体细节里面， gcc 调用了 C编译器、 汇编器、 链接器完成 C 代码的编译链接工作</p><ol><li>main.c 被 C编译器 编译成 汇编程序</li><li>这个汇编程序被 as 汇编成目标文件 </li><li>这个目标文件连同另外几个目标文件（crtl.o、crti.o、crtbegin.o、crtend.o、crtn.o)一起链接成可执行文件 mian。在链接过程中还使用 -l 选项选定了一些库文件，有 libc、libgcc、libgcc_s，其中有些库是共享库，需要动态链接，所以用 -dynamic-linker 选项指定动态链接是 /lib64/ld-linux-x86-64.so.2。这个随后我们会说到，<strong>这里我们只要理解可执行文件 mian 是由 mian.c 生成的目标文件和编译器提供的另外几个目标文件链接到一起生成的</strong></li></ol><p>现在让我们看看编译器提供的目标文件里面有些什么东西，我们只看符号表，这里主要看 crt1.o</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:/usr/lib/gcc/x86_64-linux-gnu/6$ nm /usr/lib/x86_64-linux-gnu/crt1.o</div><div class="line">0000000000000000 D __data_start</div><div class="line">0000000000000000 W data_start</div><div class="line">                 U _GLOBAL_OFFSET_TABLE_</div><div class="line">0000000000000000 R _IO_stdin_used</div><div class="line">                 U __libc_csu_fini</div><div class="line">                 U __libc_csu_init</div><div class="line">                 U __libc_start_main</div><div class="line">                 U main</div><div class="line">0000000000000000 T _start</div></pre></td></tr></table></figure><p>符号表的每一行由地址、符号类型和符号名组成。目标文件中的地址是待定的，所以是 0000000000000000.符号类型用一个字母表示，大写字母是全局符号，小写字母是局部符号,<br>U main 这一行表示 这个符号在 crtl.o 中已经被应用，但没有被定义（U 表示 Undefinded),因此需要别的目标文件提供一个定义和 crt1.o 链接在一起。T _start 这一行表示 _start 这个符号在 crtl.o 中提供了定义，这个符号的类型是 代码（T 表示 Text）</p><p>C程序的入口其实是 crt1.o 提供的 _start, 它首先做一些初始化工作（以下称为 启动例程），然后调用我们的 main函数。所以，以前我们说的 main函数 是程序的入口其实不够准确，_start 才是真正的入口点，而 main函数 是被 _start 调用的。下面我们反汇编查看以下 _start 的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">jianran@jianran:/usr/lib/gcc/x86_64-linux-gnu/6$ objdump -d /usr/lib/x86_64-linux-gnu/crt1.o</div><div class="line"></div><div class="line">/usr/lib/x86_64-linux-gnu/crt1.o：     文件格式 elf64-x86-64</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">0000000000000000 &lt;_start&gt;:</div><div class="line">   0:   31 ed                   xor    %ebp,%ebp</div><div class="line">   2:   49 89 d1                mov    %rdx,%r9</div><div class="line">   5:   5e                      pop    %rsi</div><div class="line">   6:   48 89 e2                mov    %rsp,%rdx</div><div class="line">   9:   48 83 e4 f0             and    $0xfffffffffffffff0,%rsp</div><div class="line">   d:   50                      push   %rax</div><div class="line">   e:   54                      push   %rsp</div><div class="line">   f:   49 c7 c0 00 00 00 00    mov    $0x0,%r8</div><div class="line">  16:   48 c7 c1 00 00 00 00    mov    $0x0,%rcx</div><div class="line">  1d:   48 c7 c7 00 00 00 00    mov    $0x0,%rdi</div><div class="line">  24:   ff 15 00 00 00 00       callq  *0x0(%rip)        # 2a &lt;_start+0x2a&gt;</div><div class="line">  2a:   f4                      hlt</div></pre></td></tr></table></figure></p><p>callq 指令前面的 push 指令其实想把 main 这个符号所代表的地址压栈，但是这里还不到具体地址多少，这里只能先用 0x0 代替。现在我们对 main.c 编译成目标文件 main.o，然后和链接器提供的目标文件链接，对生成的可执行文件 main 做反汇编：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">0000000000000530 &lt;_start&gt;:</div><div class="line"> 530:   31 ed                   xor    %ebp,%ebp</div><div class="line"> 532:   49 89 d1                mov    %rdx,%r9</div><div class="line"> 535:   5e                      pop    %rsi</div><div class="line"> 536:   48 89 e2                mov    %rsp,%rdx</div><div class="line"> 539:   48 83 e4 f0             and    $0xfffffffffffffff0,%rsp</div><div class="line"> 53d:   50                      push   %rax</div><div class="line"> 53e:   54                      push   %rsp</div><div class="line"> 53f:   4c 8d 05 ea 01 00 00    lea    0x1ea(%rip),%r8        # 730 &lt;__libc_csu_fini&gt;</div><div class="line"> 546:   48 8d 0d 73 01 00 00    lea    0x173(%rip),%rcx        # 6c0 &lt;__libc_csu_init&gt;</div><div class="line"> 54d:   48 8d 3d 45 01 00 00    lea    0x145(%rip),%rdi        # 699 &lt;main&gt;</div><div class="line"> 554:   ff 15 7e 0a 20 00       callq  *0x200a7e(%rip)        # 200fd8 &lt;__libc_start_main@GLIBC_2.2.5&gt;</div><div class="line"> 55a:   f4                      hlt</div><div class="line"> 55b:   0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</div></pre></td></tr></table></figure></p><p>crt1.o 中定义的 符号 _start 和 main.o 中定义的符号 main、foo、bar都合成到可执行文件的 .text 段中。符号 main 的 地址 变成 0x 699，原先的 0x0 被具体地址替代，一个目标文件中引用了某个符号，链接器在另一个目标文件中找到这个符号的定义并确定它的地址，这个过程叫做符号解析。</p><p>其实在 crt1.o 中还有一个 U __libc_start_main 这个符号在其他文件中没有定义，事实上这个符号在 libc 中定义，libc 是一个共享库，它并不像其他目标文件一样链接到可执行文件而是在运行时链接到的</p><p>1、操作系统在加载执行 main 这个程序时，首先查看它有没有需要动态链接的未定义符号<br>2、如果需要动态链接，就查看这个程序制定了哪些共享库，以及用什么动态链接器来做动态链接。我们在链接时用 -lc 指定了 共享库 libc ，用 -dynamic-linker /lib64/ld-linux-x86-64.so.2 指定了动态链接器，这些信息都会写到可执行文件中。<br>3、动态链接器加载共享库，在其中查找这些未定义符号的定义，完成链接过程。</p><p>我们回头看 _start 的反汇编过程，首先将一系列参数压栈，然后通过 callq 的命令调用库函数 <strong>libc_start_main 进行初始化工作，其中最后一个压栈是 main函数 的地址，</strong>libc_start_main做完初始化工作之后会根据这个参数调用 main函数。由于 __libc_start_main 需要做动态链接，所以这个库函数 的指令在 main 的反汇编中肯定找不到，这些指令 会在 一个 .plt 段中而不是 .text 段中找到， .plt段协助完成动态链接。</p><p>main 函数最标准的原型是 int main(int agrc，char *argv[]),也就是说启动例程会传两个参数给 main函数，到目前为止我们基本都把 main 函数写成 int main（void） 这是 C 代码允许的。</p><p>由于 main 函数是被启动例程调用，所以 main函数 return 时就返回到启动例程中，main函数的返回值会被启动例程得到，如果将启动例程表示成等价的 C代码，则它调用 main函数的 形式如下</p><pre><code>exit(main（argc，argc))</code></pre><p>也就是说，启动例程得到 main函数 返回值之后，会立刻用它做参数调用 exit函数。exit 也是 libc 的库函数，它首先做一些清理工作，然后调用 _exit系统终止进程，main 函数最终的返回值传给了 _exit 系统调用，成为进程的退出状态。我们也可以在 main函数中直接 调用 exit 终止进程而不返回启动进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为什么汇编程序入口是 _start 而 C程序 的入口是 main函数 呢？ 要弄清楚这个问题，首先要理解 gcc 的编译步骤。以前我们常用 gcc main.c -o main 命令编译一个程序，其实也可以分三步来走：&lt;strong&gt;第一步生成 汇编代码，第二步 生成目标
      
    
    </summary>
    
      <category term="2017-6" scheme="http://yoursite.com/categories/2017-6/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言剖析————函数调用</title>
    <link href="http://yoursite.com/2017/06/02/C%E8%AF%AD%E8%A8%80%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2017/06/02/C语言剖析————函数调用/</id>
    <published>2017-06-02T01:14:57.000Z</published>
    <updated>2017-06-02T01:15:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前我们从汇编语言入手，从编译，链接再到执行，了解了一些基本内容，接下来，我们要从 C语言 出发从汇编角度来理解，相信系列完成之后，对于 C语言会有一个更加深入的认识。</p><hr><p>我们将使用下面的代码来研究函数调用过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> e = c + d;</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> bar(a, b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">    foo(<span class="number">2</span>, <span class="number">3</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们使用反汇编来看一下具体的代码，代码比较多，我们截取一些必要的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="number">0000000000000660</span> &lt;bar&gt;:</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span>&#123;</div><div class="line"> <span class="number">660</span>:<span class="number">55</span>                   push   %rbp</div><div class="line"> <span class="number">661</span>:<span class="number">48</span> <span class="number">89</span> e5             mov    %rsp,%rbp</div><div class="line"> <span class="number">664</span>:<span class="number">89</span> <span class="number">7</span>d ec             mov    %edi,<span class="number">-0x14</span>(%rbp)</div><div class="line"> <span class="number">667</span>:<span class="number">89</span> <span class="number">75</span> e8             mov    %esi,<span class="number">-0x18</span>(%rbp)</div><div class="line">    <span class="keyword">int</span> e = c + d;</div><div class="line"> <span class="number">66</span>a:<span class="number">8b</span> <span class="number">55</span> ec             mov    <span class="number">-0x14</span>(%rbp),%edx</div><div class="line"> <span class="number">66</span>d:<span class="number">8b</span> <span class="number">45</span> e8             mov    <span class="number">-0x18</span>(%rbp),%eax</div><div class="line"> <span class="number">670</span>:<span class="number">01</span> d0                add    %edx,%eax</div><div class="line"> <span class="number">672</span>:<span class="number">89</span> <span class="number">45</span> fc             mov    %eax,<span class="number">-0x4</span>(%rbp)</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line"> <span class="number">675</span>:<span class="number">8b</span> <span class="number">45</span> fc             mov    <span class="number">-0x4</span>(%rbp),%eax</div><div class="line">&#125;</div><div class="line"> <span class="number">678</span>:<span class="number">5</span>d                   pop    %rbp</div><div class="line"> <span class="number">679</span>:c3                   retq   </div><div class="line"></div><div class="line"><span class="number">000000000000067</span>a &lt;foo&gt;:</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</div><div class="line"> <span class="number">67</span>a:<span class="number">55</span>                   push   %rbp</div><div class="line"> <span class="number">67b</span>:<span class="number">48</span> <span class="number">89</span> e5             mov    %rsp,%rbp</div><div class="line"> <span class="number">67</span>e:<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>          sub    $<span class="number">0x8</span>,%rsp</div><div class="line"> <span class="number">682</span>:<span class="number">89</span> <span class="number">7</span>d fc             mov    %edi,<span class="number">-0x4</span>(%rbp)</div><div class="line"> <span class="number">685</span>:<span class="number">89</span> <span class="number">75</span> f8             mov    %esi,<span class="number">-0x8</span>(%rbp)</div><div class="line">    <span class="keyword">return</span> bar(a, b);</div><div class="line"> <span class="number">688</span>:<span class="number">8b</span> <span class="number">55</span> f8             mov    <span class="number">-0x8</span>(%rbp),%edx</div><div class="line"> <span class="number">68b</span>:<span class="number">8b</span> <span class="number">45</span> fc             mov    <span class="number">-0x4</span>(%rbp),%eax</div><div class="line"> <span class="number">68</span>e:<span class="number">89</span> d6                mov    %edx,%esi</div><div class="line"> <span class="number">690</span>:<span class="number">89</span> c7                mov    %eax,%edi</div><div class="line"> <span class="number">692</span>:e8 c9 ff ff ff       callq  <span class="number">660</span> &lt;bar&gt;</div><div class="line">&#125;</div><div class="line"> <span class="number">697</span>:c9                   leaveq </div><div class="line"> <span class="number">698</span>:c3                   retq   </div><div class="line"></div><div class="line"><span class="number">0000000000000699</span> &lt;main&gt;:</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line"> <span class="number">699</span>:<span class="number">55</span>                   push   %rbp</div><div class="line"> <span class="number">69</span>a:<span class="number">48</span> <span class="number">89</span> e5             mov    %rsp,%<span class="function">rbp</span></div><div class="line">    <span class="title">foo</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span>;</div><div class="line"> <span class="number">69</span>d:be <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    $<span class="number">0x3</span>,%esi</div><div class="line"> <span class="number">6</span>a2:bf <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    $<span class="number">0x2</span>,%edi</div><div class="line"> <span class="number">6</span>a7:e8 ce ff ff ff       callq  <span class="number">67</span>a &lt;foo&gt;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> <span class="number">6</span>ac:b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    $<span class="number">0x0</span>,%eax</div><div class="line"> <span class="number">6b</span>1:<span class="number">5</span>d                   pop    %rbp</div><div class="line"> <span class="number">6b</span>2:c3                   retq   </div><div class="line"> <span class="number">6b</span>3:<span class="number">66</span> <span class="number">2</span>e <span class="number">0f</span> <span class="number">1f</span> <span class="number">84</span> <span class="number">00</span> <span class="number">00</span> nopw   %cs:<span class="number">0x0</span>(%rax,%rax,<span class="number">1</span>)</div><div class="line"> <span class="number">6b</span>a:<span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </div><div class="line"> <span class="number">6b</span>d:<span class="number">0f</span> <span class="number">1f</span> <span class="number">00</span>             nopl   (%rax)</div></pre></td></tr></table></figure></p><p>接下来我们分段来分析，先从 main方法里面看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  foo(<span class="number">2</span>, <span class="number">3</span>);</div><div class="line"><span class="number">69</span>d:   be <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x3</span>,%esi</div><div class="line"><span class="number">6</span>a2:bf <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    $<span class="number">0x2</span>,%edi</div><div class="line"><span class="number">6</span>a7:   e8 ce ff ff ff          callq  <span class="number">67</span>a &lt;foo&gt;</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="number">6</span>ac:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</div></pre></td></tr></table></figure><p>要调用函数 foo 之前 先要把参数准备好，它先将 3 存放到 esi 寄存器中， 2 存放到 edi寄存器中，可见参数是从右向左开始加载数据，准备好数据之后，我们调用 callq 函数跳转到存放 foo 函数的地方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</div><div class="line"> <span class="number">67</span>a:   <span class="number">55</span>                      push   %rbp</div><div class="line"> <span class="number">67b</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</div><div class="line"> <span class="number">67</span>e:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>             sub    $<span class="number">0x8</span>,%rsp</div><div class="line"> <span class="number">682</span>:   <span class="number">89</span> <span class="number">7</span>d fc                mov    %edi,<span class="number">-0x4</span>(%rbp)</div><div class="line"> <span class="number">685</span>:   <span class="number">89</span> <span class="number">75</span> f8                mov    %esi,<span class="number">-0x8</span>(%rbp)</div><div class="line">    <span class="keyword">return</span> bar(a, b);</div><div class="line"> <span class="number">688</span>:   <span class="number">8b</span> <span class="number">55</span> f8                mov    <span class="number">-0x8</span>(%rbp),%edx</div><div class="line"> <span class="number">68b</span>:   <span class="number">8b</span> <span class="number">45</span> fc                mov    <span class="number">-0x4</span>(%rbp),%eax</div><div class="line"> <span class="number">68</span>e:   <span class="number">89</span> d6                   mov    %edx,%esi</div><div class="line"> <span class="number">690</span>:   <span class="number">89</span> c7                   mov    %eax,%edi</div><div class="line"> <span class="number">692</span>:   e8 c9 ff ff ff          callq  <span class="number">660</span> &lt;bar&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们把寄存器 rbp 压栈，把 rsp 的值送到 rbp 中，把存放的数据，重新放置到相对 rbp 的 -4 和 -8 的位置。接下来到 重新放置好数据然后跳转到 bar 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">int bar(int c, int d)&#123;</div><div class="line"> 660:   55                      push   %rbp</div><div class="line"> 661:   48 89 e5                mov    %rsp,%rbp</div><div class="line"> 664:   89 7d ec                mov    %edi,-0x14(%rbp)</div><div class="line"> 667:   89 75 e8                mov    %esi,-0x18(%rbp)</div><div class="line">    int e = c + d;</div><div class="line"> 66a:   8b 55 ec                mov    -0x14(%rbp),%edx</div><div class="line"> 66d:   8b 45 e8                mov    -0x18(%rbp),%eax</div><div class="line"> 670:   01 d0                   add    %edx,%eax</div><div class="line"> 672:   89 45 fc                mov    %eax,-0x4(%rbp)</div><div class="line">    return e;</div><div class="line"> 675:   8b 45 fc                mov    -0x4(%rbp),%eax</div><div class="line">&#125;</div><div class="line"> 678:   5d                      pop    %rbp</div><div class="line"> 679:   c3                      retq</div></pre></td></tr></table></figure><p>在函数开头，重新放置数据到当前函数区域当中，执行完相应的加法操作，然后将计算出来的值放到 eax 寄存器当中，然后 rbp 弹栈，弹会 foo 函数，最终跳回 main 函数，执行完毕。</p><hr><p>从上面也可以理解什么叫按值传递，每一个块函数有每一块函数的空间，然后这块函数在它这块空间上施展拳脚。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在之前我们从汇编语言入手，从编译，链接再到执行，了解了一些基本内容，接下来，我们要从 C语言 出发从汇编角度来理解，相信系列完成之后，对于 C语言会有一个更加深入的认识。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们将使用下面的代码来研究函数调用过程&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="2017-6" scheme="http://yoursite.com/categories/2017-6/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言剖析————可执行文件</title>
    <link href="http://yoursite.com/2017/06/01/C%E8%AF%AD%E8%A8%80%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/06/01/C语言剖析————可执行文件/</id>
    <published>2017-06-01T08:19:21.000Z</published>
    <updated>2017-06-01T08:20:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>经过前一轮分析目标文件，现在开始该分析可执行文件了，汇编源码就不贴了。</p><hr><p>让我们看看 通过链接器生成的可执行文件，做了些什么改动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ readelf -a max</div><div class="line">ELF Header:</div><div class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </div><div class="line">  Class:                             ELF64</div><div class="line">  Data:                              2&apos;s complement, little endian</div><div class="line">  Version:                           1 (current)</div><div class="line">  OS/ABI:                            UNIX - System V</div><div class="line">  ABI Version:                       0</div><div class="line">  Type:                              EXEC (Executable file)</div><div class="line">  Machine:                           Advanced Micro Devices X86-64</div><div class="line">  Version:                           0x1</div><div class="line">  Entry point address:               0x4000b0</div><div class="line">  Start of program headers:          64 (bytes into file)</div><div class="line">  Start of section headers:          648 (bytes into file)</div><div class="line">  Flags:                             0x0</div><div class="line">  Size of this header:               64 (bytes)</div><div class="line">  Size of program headers:           56 (bytes)</div><div class="line">  Number of program headers:         2</div><div class="line">  Size of section headers:           64 (bytes)</div><div class="line">  Number of section headers:         6</div><div class="line">  Section header string table index: 5</div><div class="line"></div><div class="line">Section Headers:</div><div class="line">  [Nr] Name              Type             Address           Offset</div><div class="line">       Size              EntSize          Flags  Link  Info  Align</div><div class="line">  [ 0]                   NULL             0000000000000000  00000000</div><div class="line">       0000000000000000  0000000000000000           0     0     0</div><div class="line">  [ 1] .text             PROGBITS         00000000004000b0  000000b0</div><div class="line">       000000000000002d  0000000000000000  AX       0     0     1</div><div class="line">  [ 2] .data             PROGBITS         00000000006000dd  000000dd</div><div class="line">       0000000000000038  0000000000000000  WA       0     0     1</div><div class="line">  [ 3] .symtab           SYMTAB           0000000000000000  00000118</div><div class="line">       0000000000000108  0000000000000018           4     7     8</div><div class="line">  [ 4] .strtab           STRTAB           0000000000000000  00000220</div><div class="line">       000000000000003f  0000000000000000           0     0     1</div><div class="line">  [ 5] .shstrtab         STRTAB           0000000000000000  0000025f</div><div class="line">       0000000000000027  0000000000000000           0     0     1</div><div class="line">Key to Flags:</div><div class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</div><div class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</div><div class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</div><div class="line">  l (large), p (processor specific)</div><div class="line"></div><div class="line">There are no section groups in this file.</div><div class="line"></div><div class="line">Program Headers:</div><div class="line">  Type           Offset             VirtAddr           PhysAddr</div><div class="line">                 FileSiz            MemSiz              Flags  Align</div><div class="line">  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000</div><div class="line">                 0x00000000000000dd 0x00000000000000dd  R E    0x200000</div><div class="line">  LOAD           0x00000000000000dd 0x00000000006000dd 0x00000000006000dd</div><div class="line">                 0x0000000000000038 0x0000000000000038  RW     0x200000</div><div class="line"></div><div class="line"> Section to Segment mapping:</div><div class="line">  Segment Sections...</div><div class="line">   00     .text </div><div class="line">   01     .data </div><div class="line"></div><div class="line">There is no dynamic section in this file.</div><div class="line"></div><div class="line">There are no relocations in this file.</div><div class="line"></div><div class="line">The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.</div><div class="line"></div><div class="line">Symbol table &apos;.symtab&apos; contains 11 entries:</div><div class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</div><div class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </div><div class="line">     1: 00000000004000b0     0 SECTION LOCAL  DEFAULT    1 </div><div class="line">     2: 00000000006000dd     0 SECTION LOCAL  DEFAULT    2 </div><div class="line">     3: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS max.o</div><div class="line">     4: 00000000006000dd     0 NOTYPE  LOCAL  DEFAULT    2 data_items</div><div class="line">     5: 00000000004000bf     0 NOTYPE  LOCAL  DEFAULT    1 start_loop</div><div class="line">     6: 00000000004000d6     0 NOTYPE  LOCAL  DEFAULT    1 loop_exit</div><div class="line">     7: 00000000004000b0     0 NOTYPE  GLOBAL DEFAULT    1 _start</div><div class="line">     8: 0000000000600115     0 NOTYPE  GLOBAL DEFAULT    2 __bss_start</div><div class="line">     9: 0000000000600115     0 NOTYPE  GLOBAL DEFAULT    2 _edata</div><div class="line">    10: 0000000000600118     0 NOTYPE  GLOBAL DEFAULT    2 _end</div><div class="line"></div><div class="line">No version information found in this file.</div></pre></td></tr></table></figure></p><p>在 ELF Header Table 中 改成了 EXEC，由目标文件变成了可执行文件，Entry point address(入口点地址）改成了 0x4000b0（这是 _start 符号的地址），还可以看出多了两个 Program Header，少了两个 Section Header。</p><p>在 Section Header Table 中的 .text 和 .data段的加载地址分别改成了00000000004000b0 和 00000000006000dd 。 .bss段没有用到，所以被删除了。.rel.text段就是用于链接器过程的，做完链接也就没有用，被删除了</p><p>多出的 Program Header Table 描述了两个 Segment 的信息。.text段和前面的 ELF Header、Program Header Table 一起组成一个 Segment，.data段组成另一个 Segment，以后我们就把这两个 Segment 分别叫做 Text Segment 和 Data Segment。VirtAddr 列出了 Text Segment 加载到虚拟地址 0x0000000000400000，Data Segment 加载到地址 0x00000000006000dd，Flg列指出了 Text Segment 的访问权限是「可读可执行」，Align 的值 0x200000，是该平台下内存页面大小。在加载时文件也要按页面大小分成若干页，文件中的一页对内存中的一页。</p><p>这个可执行文件很小，总共也不超过一页大小，但是两个 Segment 必须加载到内存中两个不同的页面，因为 MMU 的权限保护机制是以页为单位的，一个页面只能设置一种权限。同时为了简化链接器和加载器的实现，还规定每个 Segement 在文件页面偏移多少，加载到内存页面就要偏移多少。</p><p>原来目标文件符号表中的 Value 都是相对地址，现在都变成了绝对地址。此外还多了三个符号 _bss_start 、_endta 和 _end，这些符号在链接脚本中定义被链接器添加到可执行程序了。</p><p>再来看一个返回的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ objdump -d max</div><div class="line"></div><div class="line">max:     file format elf64-x86-64</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">00000000004000b0 &lt;_start&gt;:</div><div class="line">  4000b0:bf 00 00 00 00       mov    $0x0,%edi</div><div class="line">  4000b5:67 8b 04 bd dd 00 60 mov    0x6000dd(,%edi,4),%eax</div><div class="line">  4000bc:00 </div><div class="line">  4000bd:89 c3                mov    %eax,%ebx</div><div class="line"></div><div class="line">00000000004000bf &lt;start_loop&gt;:</div><div class="line">  4000bf:83 f8 00             cmp    $0x0,%eax</div><div class="line">  4000c2:74 12                je     4000d6 &lt;loop_exit&gt;</div><div class="line">  4000c4:ff c7                inc    %edi</div><div class="line">  4000c6:67 8b 04 bd dd 00 60 mov    0x6000dd(,%edi,4),%eax</div><div class="line">  4000cd:00 </div><div class="line">  4000ce:39 d8                cmp    %ebx,%eax</div><div class="line">  4000d0:7e ed                jle    4000bf &lt;start_loop&gt;</div><div class="line">  4000d2:89 c3                mov    %eax,%ebx</div><div class="line">  4000d4:eb e9                jmp    4000bf &lt;start_loop&gt;</div><div class="line"></div><div class="line">00000000004000d6 &lt;loop_exit&gt;:</div><div class="line">  4000d6:b8 01 00 00 00       mov    $0x1,%eax</div><div class="line">  4000db:cd 80                int    $0x80</div></pre></td></tr></table></figure></p><p>指令中的相对地址都变成了绝对地址。同时为什么链接器怎么知道要改这两处？是根据目标文件中 .rel.text 提供的重定位信息修改的。</p><hr><p>前奏终于干完，接下来撸起袖子，让我们正式开把～～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过前一轮分析目标文件，现在开始该分析可执行文件了，汇编源码就不贴了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;让我们看看 通过链接器生成的可执行文件，做了些什么改动。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
      <category term="2017-6" scheme="http://yoursite.com/categories/2017-6/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言剖析————目标文件</title>
    <link href="http://yoursite.com/2017/06/01/C%E8%AF%AD%E8%A8%80%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/06/01/C语言剖析————目标文件/</id>
    <published>2017-06-01T02:43:51.000Z</published>
    <updated>2017-06-04T07:33:23.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#max.s</div><div class="line"></div><div class="line">.section .data</div><div class="line">data_items:</div><div class="line">.long 3,67,34,222,45,75,54,34,44,33,22,11,66,0</div><div class="line">.section .text</div><div class="line">.globl _start</div><div class="line">_start:</div><div class="line">movl $0, %edi</div><div class="line">movl data_items(,%edi,4), %eax # load the first byte of data</div><div class="line">movl %eax, %ebx</div><div class="line">start_loop:</div><div class="line">cmpl $0, %eax</div><div class="line">je loop_exit</div><div class="line">incl %edi</div><div class="line">movl data_items(,%edi,4), %eax</div><div class="line">cmpl %ebx, %eax</div><div class="line">jle start_loop</div><div class="line">movl %eax, %ebx</div><div class="line">jmp start_loop</div><div class="line">loop_exit:</div><div class="line">movl $1, %eax</div><div class="line">int $0x80</div></pre></td></tr></table></figure><p>以下几篇文章都会采用这个例子，这段程序的主要功能是在 data_items 选出最大值，并且当做终止状态返回。</p><p>下面用 readelf 工具读出目标文件 max.o 的 ELF Header 和 Section Header Table，然后我们 逐段分析 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ELF Header:</div><div class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </div><div class="line">  Class:                             ELF64</div><div class="line">  Data:                              2&apos;s complement, little endian</div><div class="line">  Version:                           1 (current)</div><div class="line">  OS/ABI:                            UNIX - System V</div><div class="line">  ABI Version:                       0</div><div class="line">  Type:                              REL (Relocatable file)</div><div class="line">  Machine:                           Advanced Micro Devices X86-64</div><div class="line">  Version:                           0x1</div><div class="line">  Entry point address:               0x0</div><div class="line">  Start of program headers:          0 (bytes into file)</div><div class="line">  Start of section headers:          504 (bytes into file)</div><div class="line">  Flags:                             0x0</div><div class="line">  Size of this header:               64 (bytes)</div><div class="line">  Size of program headers:           0 (bytes)</div><div class="line">  Number of program headers:         0</div><div class="line">  Size of section headers:           64 (bytes)</div><div class="line">  Number of section headers:         8</div><div class="line">  Section header string table index: 7</div></pre></td></tr></table></figure><p>ELF Header 中描述了操作系统 是 UNIX 体系结构是 Advanced Micro Devices X86-64，Section Header Table 中有 8 个 Setion Header,从文件地址 504 开始，每个 Section Header 占 64 个字节。这个目标文件没有 Program Header<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Section Headers:</div><div class="line">  [Nr] Name              Type             Address           Offset</div><div class="line">       Size              EntSize          Flags  Link  Info  Align</div><div class="line">  [ 0]                   NULL             0000000000000000  00000000</div><div class="line">       0000000000000000  0000000000000000           0     0     0</div><div class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</div><div class="line">       000000000000002d  0000000000000000  AX       0     0     1</div><div class="line">  [ 2] .rela.text        RELA             0000000000000000  00000190</div><div class="line">       0000000000000030  0000000000000018   I       5     1     8</div><div class="line">  [ 3] .data             PROGBITS         0000000000000000  0000006d</div><div class="line">       0000000000000038  0000000000000000  WA       0     0     1</div><div class="line">  [ 4] .bss              NOBITS           0000000000000000  000000a5</div><div class="line">       0000000000000000  0000000000000000  WA       0     0     1</div><div class="line">  [ 5] .symtab           SYMTAB           0000000000000000  000000a8</div><div class="line">       00000000000000c0  0000000000000018           6     7     8</div><div class="line">  [ 6] .strtab           STRTAB           0000000000000000  00000168</div><div class="line">       0000000000000028  0000000000000000           0     0     1</div><div class="line">  [ 7] .shstrtab         STRTAB           0000000000000000  000001c0</div><div class="line">       0000000000000031  0000000000000000           0     0     1</div><div class="line">Key to Flags:</div><div class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</div><div class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</div><div class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</div><div class="line">  l (large), p (processor specific)</div><div class="line"></div><div class="line">There are no section groups in this file.</div><div class="line"></div><div class="line">There are no program headers in this file.</div></pre></td></tr></table></figure></p><p>从 Section Header 中读取各Section 的描述信息，其中 .text 和 .data 是我们在汇编程序中声明的 Section ，而其他 Section 是汇编器自动添加的。Address 列指出了这些 Section 加载到内存中的地址（虚拟地址），目标文件中各 Section 的加载地址都是待定的，所以是 0000000000000000，到链接时再确定这些地址。 Offset 和 Size 列出了起始文件地址和长度。例如 .data段 从文件地址 0x6d 开始，一共 0x38。</p><p>使用 hexdump 打印出目标文件的全部字节<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ hexdump -C max.o</div><div class="line">00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|</div><div class="line">00000010  01 00 3e 00 01 00 00 00  00 00 00 00 00 00 00 00  |..&gt;.............|</div><div class="line">00000020  00 00 00 00 00 00 00 00  f8 01 00 00 00 00 00 00  |................|</div><div class="line">00000030  00 00 00 00 40 00 00 00  00 00 40 00 08 00 07 00  |....@.....@.....|</div><div class="line">00000040  bf 00 00 00 00 67 8b 04  bd 00 00 00 00 89 c3 83  |.....g..........|</div><div class="line">00000050  f8 00 74 12 ff c7 67 8b  04 bd 00 00 00 00 39 d8  |..t...g.......9.|</div><div class="line">00000060  7e ed 89 c3 eb e9 b8 01  00 00 00 cd 80 03 00 00  |~...............|</div><div class="line">00000070  00 43 00 00 00 22 00 00  00 de 00 00 00 2d 00 00  |.C...&quot;.......-..|</div><div class="line">00000080  00 4b 00 00 00 36 00 00  00 22 00 00 00 2c 00 00  |.K...6...&quot;...,..|</div><div class="line">00000090  00 21 00 00 00 16 00 00  00 0b 00 00 00 42 00 00  |.!...........B..|</div><div class="line">000000a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</div><div class="line">*</div><div class="line">000000c0  00 00 00 00 03 00 01 00  00 00 00 00 00 00 00 00  |................|</div><div class="line">000000d0  00 00 00 00 00 00 00 00  00 00 00 00 03 00 03 00  |................|</div><div class="line">000000e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</div><div class="line">000000f0  00 00 00 00 03 00 04 00  00 00 00 00 00 00 00 00  |................|</div><div class="line">00000100  00 00 00 00 00 00 00 00  01 00 00 00 00 00 03 00  |................|</div><div class="line">00000110  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</div><div class="line">00000120  0c 00 00 00 00 00 01 00  0f 00 00 00 00 00 00 00  |................|</div><div class="line">00000130  00 00 00 00 00 00 00 00  17 00 00 00 00 00 01 00  |................|</div><div class="line">00000140  26 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |&amp;...............|</div><div class="line">00000150  21 00 00 00 10 00 01 00  00 00 00 00 00 00 00 00  |!...............|</div><div class="line">00000160  00 00 00 00 00 00 00 00  00 64 61 74 61 5f 69 74  |.........data_it|</div><div class="line">00000170  65 6d 73 00 73 74 61 72  74 5f 6c 6f 6f 70 00 6c  |ems.start_loop.l|</div><div class="line">00000180  6f 6f 70 5f 65 78 69 74  00 5f 73 74 61 72 74 00  |oop_exit._start.|</div><div class="line">00000190  09 00 00 00 00 00 00 00  0b 00 00 00 02 00 00 00  |................|</div><div class="line">000001a0  00 00 00 00 00 00 00 00  1a 00 00 00 00 00 00 00  |................|</div><div class="line">000001b0  0b 00 00 00 02 00 00 00  00 00 00 00 00 00 00 00  |................|</div><div class="line">000001c0  00 2e 73 79 6d 74 61 62  00 2e 73 74 72 74 61 62  |..symtab..strtab|</div><div class="line">000001d0  00 2e 73 68 73 74 72 74  61 62 00 2e 72 65 6c 61  |..shstrtab..rela|</div><div class="line">000001e0  2e 74 65 78 74 00 2e 64  61 74 61 00 2e 62 73 73  |.text..data..bss|</div><div class="line">000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</div><div class="line">*</div><div class="line">00000230  00 00 00 00 00 00 00 00  20 00 00 00 01 00 00 00  |........ .......|</div><div class="line">00000240  06 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</div><div class="line">00000250  40 00 00 00 00 00 00 00  2d 00 00 00 00 00 00 00  |@.......-.......|</div><div class="line">00000260  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|</div><div class="line">00000270  00 00 00 00 00 00 00 00  1b 00 00 00 04 00 00 00  |................|</div><div class="line">00000280  40 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |@...............|</div><div class="line">00000290  90 01 00 00 00 00 00 00  30 00 00 00 00 00 00 00  |........0.......|</div><div class="line">000002a0  05 00 00 00 01 00 00 00  08 00 00 00 00 00 00 00  |................|</div><div class="line">000002b0  18 00 00 00 00 00 00 00  26 00 00 00 01 00 00 00  |........&amp;.......|</div><div class="line">000002c0  03 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</div><div class="line">000002d0  6d 00 00 00 00 00 00 00  38 00 00 00 00 00 00 00  |m.......8.......|</div><div class="line">000002e0  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|</div><div class="line">000002f0  00 00 00 00 00 00 00 00  2c 00 00 00 08 00 00 00  |........,.......|</div><div class="line">00000300  03 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</div><div class="line">00000310  a5 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</div><div class="line">00000320  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|</div><div class="line">00000330  00 00 00 00 00 00 00 00  01 00 00 00 02 00 00 00  |................|</div><div class="line">00000340  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</div><div class="line">00000350  a8 00 00 00 00 00 00 00  c0 00 00 00 00 00 00 00  |................|</div><div class="line">00000360  06 00 00 00 07 00 00 00  08 00 00 00 00 00 00 00  |................|</div><div class="line">00000370  18 00 00 00 00 00 00 00  09 00 00 00 03 00 00 00  |................|</div><div class="line">00000380  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</div><div class="line">00000390  68 01 00 00 00 00 00 00  28 00 00 00 00 00 00 00  |h.......(.......|</div><div class="line">000003a0  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|</div><div class="line">000003b0  00 00 00 00 00 00 00 00  11 00 00 00 03 00 00 00  |................|</div><div class="line">000003c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</div><div class="line">000003d0  c0 01 00 00 00 00 00 00  31 00 00 00 00 00 00 00  |........1.......|</div><div class="line">000003e0  00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00  |................|</div></pre></td></tr></table></figure></p><p>.data段被原封不动的加载到内存中了<br>.shstrtab 和 .strtab 这两个 Section 存放都是 ASCII 码，<br>.shstrtab段保存着各 Section 的名字，.strtab 保存着程序需要用到的符号名字。</p><p>我们知道， C语言的全局变量如果代码没有初始化，就会在程序加载时用 0 初始化。这种数据属于 .bss段，在加载它和 .data段一样都是可读可写的数据，但是在 ELF文件中 .data段需要占用一部分空间保存初始化值，而 .bss段 则不需要。也就是说，.bss段 在文件中只占一个 Section Header 而没有对应的 Section，程序加载时，.bss段占用多大内存空间在 Section Header 中描述。在我们这个例子中没有用到 .bss段 </p><p>我们继续分析 readelf 输出的最后一部分，是从 .rel.test 和 .symtab 这两个 Section 读出的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Relocation section &apos;.rela.text&apos; at offset 0x190 contains 2 entries:</div><div class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</div><div class="line">000000000009  00020000000b R_X86_64_32S      0000000000000000 .data + 0</div><div class="line">00000000001a  00020000000b R_X86_64_32S      0000000000000000 .data + 0</div><div class="line"></div><div class="line">The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.</div><div class="line"></div><div class="line">Symbol table &apos;.symtab&apos; contains 8 entries:</div><div class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</div><div class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </div><div class="line">     1: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </div><div class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </div><div class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </div><div class="line">     4: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    3 data_items</div><div class="line">     5: 000000000000000f     0 NOTYPE  LOCAL  DEFAULT    1 start_loop</div><div class="line">     6: 0000000000000026     0 NOTYPE  LOCAL  DEFAULT    1 loop_exit</div><div class="line">     7: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT    1 _start</div><div class="line"></div><div class="line">No version information found in this file.</div></pre></td></tr></table></figure><p>.rel.text 告诉链接器指令中哪些地方需要重定位<br>.symtab 是符号表。 Ndx 列是每个符号所在的 Section 编号，例如data_items 在第三个 Section 里（也就是 .data段），各 Section 的编号见 Section Header Table。Value 列是每个符号 所代表的地址，在目标文件中，符号地址都是相对于该符号所在 Section 的相对地址。Bind 这一列描述是全局还是局部，其中我们使用「 .globl 」声明的 _start 是全局，其他都是局部的</p><p>现在我们使用 objdump 工具把程序中的机器指令反汇编，那么反汇编的结果时候时候和原来一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ objdump -d max.o</div><div class="line"></div><div class="line">max.o:     file format elf64-x86-64</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">0000000000000000 &lt;_start&gt;:</div><div class="line">   0:bf 00 00 00 00       mov    $0x0,%edi</div><div class="line">   5:67 8b 04 bd 00 00 00 mov    0x0(,%edi,4),%eax</div><div class="line">   c:00 </div><div class="line">   d:89 c3                mov    %eax,%ebx</div><div class="line"></div><div class="line">000000000000000f &lt;start_loop&gt;:</div><div class="line">   f:83 f8 00             cmp    $0x0,%eax</div><div class="line">  12:74 12                je     26 &lt;loop_exit&gt;</div><div class="line">  14:ff c7                inc    %edi</div><div class="line">  16:67 8b 04 bd 00 00 00 mov    0x0(,%edi,4),%eax</div><div class="line">  1d:00 </div><div class="line">  1e:39 d8                cmp    %ebx,%eax</div><div class="line">  20:7e ed                jle    f &lt;start_loop&gt;</div><div class="line">  22:89 c3                mov    %eax,%ebx</div><div class="line">  24:eb e9                jmp    f &lt;start_loop&gt;</div><div class="line"></div><div class="line">0000000000000026 &lt;loop_exit&gt;:</div><div class="line">  26:b8 01 00 00 00       mov    $0x1,%eax</div><div class="line">  2b:cd 80                int    $0x80</div></pre></td></tr></table></figure></p><p>在这里我们展示了 .text 的内容<br>非常显然，所有的符号都被替换成地址，比如 je 26，注意没有加 $ 的数字表示内存地址，而不表示立即数。在这里所有的类似 <_start> 的符号，不是指令的一部分，而是反汇编器从 .symtab 和 .strtab 查到的符号名称，卸载后面增加可读性，目前所有指令中用到的符号地址都是相对地址，等到下一步链接器要修改这些指令，把其中的地址都改成加载时的内存地址，这些指令才能正确执行</_start></p><hr><p>相信阅读完成，你心里大概有个底了，为什么目标文件不可以执行？<br>因为没有真正映射到物理内存上面，无法获取真正的数据，当然还有其他没有说明的理由，在接下来几篇文章中，我将会说到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
      
    
    </summary>
    
      <category term="2017-6" scheme="http://yoursite.com/categories/2017-6/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言剖析————ELF文件</title>
    <link href="http://yoursite.com/2017/06/01/C%E8%AF%AD%E8%A8%80%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E2%80%94%E2%80%94ELF%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/06/01/C语言剖析————ELF文件/</id>
    <published>2017-06-01T00:46:04.000Z</published>
    <updated>2017-06-04T07:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>ELF 文件格式是一个开放标准，各种 UNIX 系统的<strong>可执行文件</strong>都采用 ELF 格式，它有以下三种不同的类型。</p><ul><li>可重定位的目标文件</li><li>可执行文件</li><li>共享库</li></ul><p>共享库留着以后慢慢说。</p><hr><p>现在解释一下程序的汇编、链接、运行过程</p><p>1、写一个汇编程序并且保存成<strong>文本文件</strong> </p><p>2、汇编器读取这个文本文件并将其转换成目标文件。目标文件由若干个 Section 组成，我们在汇编程序中声明 .section 会成为目标文件中的 Section ，此外汇编器还会自动添加 Section</p><p>3、然后链接器把目标文件中的 Section 合并成几个 Segment ，生成可执行文件</p><p>4、最后 加载器 根据 可执行文件中的 Segment 信息加载运行这个程序。</p><p>所以 ELF 格式提供了两种不同的视角，从 链接器 把 ELF文件 看成 Section 的集合。而从 加载器 把 ELF文件 看成 Segment 的集合</p><p><img src="http://ww1.sinaimg.cn/large/b36c7eebly1fg5e81iptfj209p07mab5.jpg" alt=""></p><p>图的左边是从 链接器 角度看， 开头的 ELF header 描述了 体系结构 和 操作系统等基本信息，并指出 Section Header Table 和 Program Header Table 文件中的位置，Program Header Table 在链接过程用不到，所以可有可无，Section Header Table 可以找到每个 Section 在文件中的位置。右边是从 加载器 的角度看 ELF文件，开头是 ELF Header, Program Header Table 中保存了所有 Segment 的描述信息，相反 Section Header Table 是用了不到的，从图中可以看出，一个 Segment 由 一个或多个 Section 组成，这些 Section 加载到内存是具有 相同的访问权限，有些 Section 只对 链接器 有意义，在运行时用不到，也不需要加载到内存，那么就不属于 任何 Segment </p><p>注：这里 Section Header Table 和 Program Header Table只是为了清晰，真实的两个表并不一定要位于文件开头和结尾</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ELF 文件格式是一个开放标准，各种 UNIX 系统的&lt;strong&gt;可执行文件&lt;/strong&gt;都采用 ELF 格式，它有以下三种不同的类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可重定位的目标文件&lt;/li&gt;
&lt;li&gt;可执行文件&lt;/li&gt;
&lt;li&gt;共享库&lt;/li&gt;
&lt;/ul&gt;
&lt;p
      
    
    </summary>
    
      <category term="2017-6" scheme="http://yoursite.com/categories/2017-6/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>寻址方式</title>
    <link href="http://yoursite.com/2017/05/31/%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/05/31/寻址方式/</id>
    <published>2017-05-31T15:19:08.000Z</published>
    <updated>2017-06-04T07:09:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>常用的几种寻址方式。内存寻址在指令中可以表示成如下的通用格式：</p><pre><code>ADDRESS_OR(%BASE_OR_OFFSET,%INDEX,MULTIPLIER)</code></pre><p>他所表示的地址可以这样计算出来<br>FINAL ADDRESS = ADDRESS_OR_OFFEST + BASE_OR_OFFSET + MULTIPLIER x INDEX</p><p>其中 ADDRESS_OR_OFFSET 和 MULTIPLIER 必须是常数，BASE_OR_OFFSET 和 INDEX 必须是寄存器</p><ul><li><p><strong>直接寻址</strong>。只使用 ADDRESS_OR_OFFEST 寻址，例如 movl ADDRESS，%eax 把 ADDRESS 地址处的32位数传送到 eax 寄存器</p></li><li><p><strong>变址寻址</strong>。 movl data_items（，%edi，4），%eax 就属于这种寻址，用于访问数组元素比较方便</p></li><li><p><strong>间接寻址</strong>。只是用 BASE_OR_OFFSET 寻址，例如 movl （%eax），%ebx，把 eax 寄存器的值看做地址，把内存中这个地址处的 32 位数传送到 ebx 寄存器。</p></li><li><p><strong>基址寻址</strong>。只使用 ADDRESS_OR_OFFSET 和 BASE_OR_OFFSET 寻址，<br>例如： movl 4（%eax），%ebx，用于访问结构体成员比较方便，例如一个结构体的基地址保存在 寄存器eax 中，其中一个成员在结构体中的偏移量是 4 字节，要把这个成员读上来就可以使用这条指令</p></li><li><p><strong>立即数寻址</strong>。就是指令中有一个操作数是立即数，例如：movl $12, %eax</p></li><li><p><strong>寄存器寻址</strong>。就是指令中一个操作数是寄存器</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常用的几种寻址方式。内存寻址在指令中可以表示成如下的通用格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ADDRESS_OR(%BASE_OR_OFFSET,%INDEX,MULTIPLIER)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;他所表示的地址可以这样计算出来&lt;br&gt;FINAL ADD
      
    
    </summary>
    
      <category term="2017-5" scheme="http://yoursite.com/categories/2017-5/"/>
    
    
      <category term="汇编语言基础" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
