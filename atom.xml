<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JianRan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-06T15:57:36.336Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JianRan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>log005</title>
    <link href="http://yoursite.com/2018/02/06/log005/"/>
    <id>http://yoursite.com/2018/02/06/log005/</id>
    <published>2018-02-06T15:56:48.000Z</published>
    <updated>2018-02-06T15:57:36.336Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚的关于优化ss的问题，让我熬到凌晨3点，严重影响了今天的计划。坏事情总是接连发生，我在本该做这个事情的时间段，做了其他。对于一个难题的解决，对问题的坚持固然重要，但这并不是延误其他事情的一个好理由。</p><p>每天的任务是定量的，所有的行为，应该把每天的任务放在首位。在明知，无法全部完成时，应该尽可能多的完成。</p><p>我想要的不仅仅是进步，而是高效的进步。你应该集中注意力的去做每一件事情。</p><p>我无法做到十全十美，但是应该将自己可以做到完成。</p><p>我要竭尽全力，而不是尽力。不要让自己变成自己所拒绝的人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨晚的关于优化ss的问题，让我熬到凌晨3点，严重影响了今天的计划。坏事情总是接连发生，我在本该做这个事情的时间段，做了其他。对于一个难题的解决，对问题的坚持固然重要，但这并不是延误其他事情的一个好理由。&lt;/p&gt;
&lt;p&gt;每天的任务是定量的，所有的行为，应该把每天的任务放在首位
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log004</title>
    <link href="http://yoursite.com/2018/02/06/log004/"/>
    <id>http://yoursite.com/2018/02/06/log004/</id>
    <published>2018-02-05T16:48:37.000Z</published>
    <updated>2018-02-05T16:49:20.082Z</updated>
    
    <content type="html"><![CDATA[<p>别的我倒不认为有什么优势，但唯独可以坚持下来。</p><p>和最近任务有关系，没有很明确的一个目标，现在每天过得可以说自我感觉十分糟糕，虽然每天都有在提</p><p>高，但我想要更高的效率。</p><p>也谈不上匆忙，总而言之，这件事情必须睡觉之前做完。</p><hr><p>明天任务：</p><ul><li>英语学习两小时，完成英语流利说的任务，其余时间看英文视频</li><li>完成归并和快速排序的算法，并且写一篇文章</li><li>看完Android网络框架，记录并且解决部分问题</li><li>学习一种新的设计模式</li></ul><hr><p>起床： 7:00</p><p>算法的战斗： 8:00 – 12:00</p><p>Android的战斗： 14:00 – 17:00</p><p>英语的战斗：    17:00 – 18:00</p><p>设计模式的战斗：20:00 – 22:00 </p><p>其余时间自由安排。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;别的我倒不认为有什么优势，但唯独可以坚持下来。&lt;/p&gt;
&lt;p&gt;和最近任务有关系，没有很明确的一个目标，现在每天过得可以说自我感觉十分糟糕，虽然每天都有在提&lt;/p&gt;
&lt;p&gt;高，但我想要更高的效率。&lt;/p&gt;
&lt;p&gt;也谈不上匆忙，总而言之，这件事情必须睡觉之前做完。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log003</title>
    <link href="http://yoursite.com/2018/02/04/log003/"/>
    <id>http://yoursite.com/2018/02/04/log003/</id>
    <published>2018-02-04T15:47:37.000Z</published>
    <updated>2018-02-04T15:48:20.080Z</updated>
    
    <content type="html"><![CDATA[<p>节奏渐入佳境，无论是博客还是技术 。尽管所有的时间安排都在按照计划执行，但是在安排任务上面，从任务量来说并没有完成。过分纠结于一个问题，导致解决时间过长。</p><p>在资源已经充分利用的前提下，下来比拼的就是效率了。</p><p>在思考之后，决定继续学习太极拳。</p><p>假期本来是打算去静下来看会书，结果最终也成了战场。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;节奏渐入佳境，无论是博客还是技术 。尽管所有的时间安排都在按照计划执行，但是在安排任务上面，从任务量来说并没有完成。过分纠结于一个问题，导致解决时间过长。&lt;/p&gt;
&lt;p&gt;在资源已经充分利用的前提下，下来比拼的就是效率了。&lt;/p&gt;
&lt;p&gt;在思考之后，决定继续学习太极拳。&lt;/p
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>编写算法时一些思想与实践</title>
    <link href="http://yoursite.com/2018/02/04/%E7%BC%96%E5%86%99%E7%AE%97%E6%B3%95%E6%97%B6%E4%B8%80%E4%BA%9B%E6%80%9D%E6%83%B3%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/02/04/编写算法时一些思想与实践/</id>
    <published>2018-02-04T04:07:49.000Z</published>
    <updated>2018-02-04T04:09:10.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="明确定义"><a href="#明确定义" class="headerlink" title="明确定义"></a>明确定义</h2><p>在普通的排序问题上面，经常会因为在边界条件的角标越界而出错。或直接因为你代码逻辑问题而导致，究其原因是对于<strong>数据定义不明确</strong>或 <strong>不能始终维护定义的正确性</strong>。</p><p>大多数问题，相信都出自其手。反过来，应该时刻的注意并保持定义的正确性。对于我们理解别人的代码，还是看自己的代码都会顺畅很多。在这个系列中，我们同样会这一点，请同志们细细体会。</p><p>不要看文字简短，但是上面的这两句话是及其重要的。</p><h2 id="理解选择排序"><a href="#理解选择排序" class="headerlink" title="理解选择排序"></a><strong>理解选择排序</strong></h2><p>对于算法来说，最重要的是理解其思想，不是说实现不重要，但理解其思想是正确实现的重要前提。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a><strong>基本思想</strong></h3><blockquote><p>在一个未排序的序列中，选择最大或者最小的那个数据，去与未排序序列中的首个元素交换位置</p></blockquote><p>在排序问题上会分为已排序和未排序序列，所以我们先选择用 <strong>i</strong> 来定义未排序序列的首个元素的位置，在 <strong>[0, i-1]</strong> 区间内它是有序的，先不要管他们，在 <strong>[i, n -1]</strong> 的区间内是未排序的，我们应该不断的在未排序的区间中选择最大或最小的一个放到未排序队列的首部，然后收缩未排序序列直到没有元素为止。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a><strong>算法实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> minIndex = i;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</div><div class="line">            <span class="keyword">if</span>(arr[minIndex] &gt; arr[j])</div><div class="line">                minIndex = j;</div><div class="line"></div><div class="line">        swap(arr[i], arr[minIndex]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 <strong>[i, n-1]</strong> 这个未排序序列中，我们通过for循环来不断的缩减范围，直至未排序序列没有元素。在每次缩减范围之前，我们都要筛选出在未排序序列中的最小的元素，去放到未排序序列的首部。筛选出最小元素的想法是，先假定未排序序列的第一个元素是最小的，然后依次去和其他未排序的元素比较，j 指向的是未排序序列中，正在做比较的元素。最终会选出最小的那一个。</p><h2 id="理解插入排序"><a href="#理解插入排序" class="headerlink" title="理解插入排序"></a><strong>理解插入排序</strong></h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a><strong>基本思想</strong></h3><blockquote><p>每次从未排序序列中拿一个元素，去和放到已经有序序列的正确位置</p></blockquote><p>这回我们主要操作的是未排序序列，依然我们定义一个变量 <strong>i</strong> 去指向 <em>从未排序序列中拿出来的那个元素</em>。所以在<strong>[0, i-1]</strong> 这个区间代表着已经排序的序列。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a><strong>算法实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</div><div class="line"></div><div class="line">        T e = arr[i];</div><div class="line">        <span class="keyword">int</span> j ;</div><div class="line">        <span class="keyword">for</span>(j = i <span class="number">-1</span>; j&gt;=<span class="number">0</span> ;j--)</div><div class="line">            <span class="keyword">if</span>(e &lt; arr[j])</div><div class="line">                arr[j+<span class="number">1</span>] = arr[j];</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        arr[j+<span class="number">1</span>] = e;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当序列为一个元素时是有序的，所以初始无序序列的区间为<strong>[1, n-1]</strong>，我们不断的去缩小无序序列的范围，直至它一无所有～。在每次缩减之前，我们需要在有序序列中找到对于 <strong>arr[i]</strong> 来讲的恰当位置。并且把他放置到该放的位置。我们定义 <strong>j</strong> 在for循环内是指，当前 <strong>arr[i]</strong> 想去放置的位置，当确定 arr[i] 可以放置到某个位置时 退出for循环，但是因为最后for循环一定会执行<strong>j–</strong>，因此在for循环外，<strong>j</strong> 是指该放置位置的前一个， 所以在最后放置元素时候，应该进行 +1 操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>虽然二者属于$O(n^2)$的算法，但是插入排序，相比较选择排序来说，可以提前终止。插入排序还有一个优点，对于几乎有序的数组来说，他的速度几乎逼近$O(n)$的时间时间复杂度，正是因为这个特点，插入排序在很多排序过程中，会成为他们的子过程。</p><p>那下面通过之前实现的<a href="https://jinfangzhang.github.io/2018/02/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/" target="_blank" rel="external">工具</a>，去进一步感受的他们特点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> n = <span class="number">20000</span>;</div><div class="line">    </div><div class="line"><span class="comment">// 测试1 一般测试</span></div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Test for random array, size = "</span>&lt;&lt;n&lt;&lt;<span class="string">", random range [0, "</span>&lt;&lt;n&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="keyword">int</span> *arr1 = SortTestHelper::generateRandomArray(n,<span class="number">0</span>,n);</div><div class="line"><span class="keyword">int</span> *arr2 = SortTestHelper::copyIntArray(arr1, n);</div><div class="line">    </div><div class="line">SortTestHelper::testSort(<span class="string">"Insertion Sort"</span>, insertionSort,arr1,n);</div><div class="line">SortTestHelper::testSort(<span class="string">"Selection Sort"</span>, selectionSort,arr2,n);</div><div class="line">    </div><div class="line"><span class="keyword">delete</span>[] arr1;</div><div class="line"><span class="keyword">delete</span>[] arr2;</div><div class="line">    </div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="comment">// 测试3 测试近乎有序的数组</span></div><div class="line"><span class="keyword">int</span> swapTimes = <span class="number">100</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Test for nearly ordered array, size = "</span>&lt;&lt;n&lt;&lt;<span class="string">", swap time = "</span>&lt;&lt;swapTimes&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">arr1 = SortTestHelper::generateNearlyOrderArray(n,swapTimes);</div><div class="line">arr2 = SortTestHelper::copyIntArray(arr1, n);</div><div class="line">    </div><div class="line">SortTestHelper::testSort(<span class="string">"Insertion Sort"</span>, insertionSort,arr1,n);</div><div class="line">SortTestHelper::testSort(<span class="string">"Selection Sort"</span>, selectionSort,arr2,n);</div><div class="line">    </div><div class="line"><span class="keyword">delete</span>[] arr1;</div><div class="line"><span class="keyword">delete</span>[] arr2;</div><div class="line">    </div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Test for random array, size = 20000, random range [0, 20000]</div><div class="line">Insertion Sort : 0.268021 s</div><div class="line">Selection Sort : 0.46862 s</div><div class="line"></div><div class="line">Test for nearly ordered array, size = 20000, swap time = 100</div><div class="line">Insertion Sort : 0.003808 s</div><div class="line">Selection Sort : 0.468284 s</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;明确定义&quot;&gt;&lt;a href=&quot;#明确定义&quot; class=&quot;headerlink&quot; title=&quot;明确定义&quot;&gt;&lt;/a&gt;明确定义&lt;/h2&gt;&lt;p&gt;在普通的排序问题上面，经常会因为在边界条件的角标越界而出错。或直接因为你代码逻辑问题而导致，究其原因是对于&lt;strong&gt;数
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Log002</title>
    <link href="http://yoursite.com/2018/02/03/log002/"/>
    <id>http://yoursite.com/2018/02/03/log002/</id>
    <published>2018-02-03T14:27:47.000Z</published>
    <updated>2018-02-04T00:31:08.718Z</updated>
    
    <content type="html"><![CDATA[<p>今天可以说，最大的收获是听谷歌方法论，对于计算机思维的一些思考。同时也因为着迷漫画而打乱了一天的节奏。</p><p>并且重新发问一个新问题，我每天都在学习新知识，那么太极拳我是否有时间去思考和学习呢？可能这需要我严密的去组织时间。</p><p>中午的时间浪费的出奇的严重，这是需要改正的一点。</p><p>当然今天还有很多没有完成的事情。周遭环境的不适应，应该更加快快速的的调整。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天可以说，最大的收获是听谷歌方法论，对于计算机思维的一些思考。同时也因为着迷漫画而打乱了一天的节奏。&lt;/p&gt;
&lt;p&gt;并且重新发问一个新问题，我每天都在学习新知识，那么太极拳我是否有时间去思考和学习呢？可能这需要我严密的去组织时间。&lt;/p&gt;
&lt;p&gt;中午的时间浪费的出奇的严重
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法的一些准备工作</title>
    <link href="http://yoursite.com/2018/02/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/02/03/数据结构与算法的一些准备工作/</id>
    <published>2018-02-03T03:02:49.000Z</published>
    <updated>2018-02-03T03:40:33.294Z</updated>
    
    <content type="html"><![CDATA[<p>对于算法而言，虽然我们可以从理论上面分析该算法是时间复杂度，是$O(nlog^n)$,还是$O(n^2)$，这些难免有点过于抽象，难以理解。为此，我们应该准备一些必要的工具，去从正面直接理解和观察他们，是我们进一步理解和解决问题的基础</p><p>毕竟算法是一种思想，语言就是我们使用的一种工具。在语言上，我们选择<code>C++</code>，来进行实现。</p><h2 id="生成数据"><a href="#生成数据" class="headerlink" title="生成数据"></a><strong>生成数据</strong></h2><p>设计的问题主要是一些排序问题，数据源是最应该解决的，在生成数据上，我们应该至少生成两种数据组，一种是完全随机的，而另一种是几乎有序的数组。先不要管为什么，在之后的内容中会有说到。</p><p>选择在一个<strong>SortTestHelper</strong> 的命名空间之下（如果不知道的同学，可以简单去了解一下，还是比较容易理解的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> SortTestHelper&#123;</div><div class="line">    <span class="comment">//工具代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="生成无序数据源"><a href="#生成无序数据源" class="headerlink" title="生成无序数据源"></a><strong>生成无序数据源</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//生成一个大小为n的随机数组，每个元素的随机范围在[rangeL,rangeR]。</span></div><div class="line"><span class="function"><span class="keyword">int</span>* <span class="title">generateRandomArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> rangeL, <span class="keyword">int</span> rangeR)</span></span>&#123;</div><div class="line">    assert( rangeL &lt;= rangeR);</div><div class="line">    <span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">    srand(time(<span class="literal">NULL</span>));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">        arr[i] = rand() % (rangeL - rangeR + <span class="number">1</span>) + rangeL;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="生成几乎有序的数组"><a href="#生成几乎有序的数组" class="headerlink" title="生成几乎有序的数组"></a><strong>生成几乎有序的数组</strong></h3><p>先生成一个从1到n的完全有序的数据，然后在这个的基础之上交换几次，于是就形成了，几乎有序的数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span>* <span class="title">generateNearlyOrderArray</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">int</span> swapTimes)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">        arr[i] = i;</div><div class="line">    &#125;</div><div class="line">    srand(time(<span class="literal">NULL</span>));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;swapTimes;i++)&#123;</div><div class="line">        <span class="keyword">int</span> posx = rand()%n;</div><div class="line">        <span class="keyword">int</span> posy = rand()%n;</div><div class="line">        swap(arr[posx],arr[posy]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="打印数据"><a href="#打印数据" class="headerlink" title="打印数据"></a><strong>打印数据</strong></h2><p>能用模板，我们尽量会用到模板。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T arr[],<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="判断是否有序"><a href="#判断是否有序" class="headerlink" title="判断是否有序"></a><strong>判断是否有序</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSorted</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; n<span class="number">-1</span>;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(arr[i] &gt; arr[i + <span class="number">1</span>])</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="真正的测试"><a href="#真正的测试" class="headerlink" title="真正的测试"></a><strong>真正的测试</strong></h2><p>在这里我们会默认，我们之后的测试方法都是同一种声明顺序与结构 $$void(*sort)(T[\ ]\ arr, int\  size)$$</p><p>我们会测试整个排序完的数据是否有序，在这个前提下，我们会给出运行所需要的时间。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">template&lt;typename T&gt; </div><div class="line">void testSort( string sortName, void(*sort)(T[], int), T arr[], int n)&#123;</div><div class="line">    clock_t startTime = clock();</div><div class="line">    sort(arr,n);</div><div class="line">    clock_t endTime = clock();</div><div class="line">    </div><div class="line">    assert( isSorted(arr,n));</div><div class="line">    cout &lt;&lt; sortName &lt;&lt; " : " &lt;&lt; double(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; " s" &lt;&lt; endl;</div><div class="line"></div><div class="line">    return ;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a><strong>复制数组</strong></h2><pre><code class="cpp"><span class="function"><span class="keyword">int</span>* <span class="title">copyIntArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>{    <span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];    copy(a,a+n,arr);    <span class="keyword">return</span> arr;}</code></pre><p><strong>以上我们的数组是采用new的方式来开辟内存空间的，所以在使用完了之后需要delete，虽然不delete并不会影响什么，但你应该去养成这样的一个好习惯。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于算法而言，虽然我们可以从理论上面分析该算法是时间复杂度，是$O(nlog^n)$,还是$O(n^2)$，这些难免有点过于抽象，难以理解。为此，我们应该准备一些必要的工具，去从正面直接理解和观察他们，是我们进一步理解和解决问题的基础&lt;/p&gt;
&lt;p&gt;毕竟算法是一种思想，语言
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>对于是否选择进一步教育的的思考</title>
    <link href="http://yoursite.com/2018/02/03/%E5%AF%B9%E4%BA%8E%E6%98%AF%E5%90%A6%E9%80%89%E6%8B%A9%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%95%99%E8%82%B2%E7%9A%84%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2018/02/03/对于是否选择进一步教育的的思考/</id>
    <published>2018-02-03T00:56:27.000Z</published>
    <updated>2018-02-03T01:08:51.829Z</updated>
    
    <content type="html"><![CDATA[<p>对于这个问题，其实根本上可以理解为两个方面的问题。一种是自上而下的理解，这是一种高屋建瓴，俯视问题的一看法。而另一中则相反，就是自下而上的方式。</p><p>对于后者来说，在进一步普及到人们的生产生活当中，被叫做<strong>工匠式</strong>的方式。经过长期经验的积累从量变到质变的过程。或许一提及工匠两字会感觉不好，但他们在日常生活中依然起了很重要的作用。</p><p>但是在某些问题上面，想根本性的解决，或者解决一些用直觉无法解决的问题时，就必须用自上而下的思考方式去理解。</p><p>拿一道Google面试体来说：在一个房间里面可以容纳多少高尔夫球？如果拿常规思维，一听到这个题目估计就懵逼了，接下来的问题只能交给直接去解决，往往得到的是一种错误的。</p><p>如果想成，一个高尔夫球4厘米宽，在一个15平方米，高约3米的房间内，瞬间问题就可以被当做一个小学问题去解决。尽管最后没有一个明确的答案，但是在量级上面是不会错的。</p><p>进一步的例子，在创造计算机的过程中，常人想问题的方式是先做一两个能解决简单问题的计算机，然后越做越复杂。这种方式在设计出来的计算机中会不断的遇见问题，甚至有时候要推翻之前的重新来设计计算机。</p><p>实际上在图灵之前，计算机的发展都是沿袭这个思路来的。而图灵的思路与常人正好相反，它现在思考以下三个问题</p><p>第一个问题，世界上是否所有数学问题都有明确的答案？</p><p>第二个问题，如果有明确的答案，是否可以通过有限步骤的计算得到答案？</p><p>第三个问题，那些有可能在有限步骤计算出来的数学问题，是否有一种假象的机械，让他不断运行，最后当机器停下来的时候，那个数学问题就解决了。</p><p>经过时间的检验，以这样问题，去理解计算机，并且设计出来的计算机思想，直到现在都在沿用。这是一种从细节跳脱出来，就好比，你要观察一只蚂蚁的行进路线，跟在它屁股后面是办不到的，你必须从他头顶上观察。</p><p>但是要跳脱细节，把问题抽象出来的这种工程思维，是有前提的，你需要足够多的理论知识去丰富自己。</p><p>在设计一个东西之初，通过理论看到它的极限在哪里，从而不必要去为了一些不切实际的想法的去浪费努力。</p><p>同样对于进一步教育来说，如果你想去透彻的解决并理解某问题，必须拥有足够多的知识，从这个问题出发，无非就是一个复合型的数学问题。从下而上的思考方式，无非一点点递进，深陷细节到头来只能跟着别人的脚步来走。但只有从上而下，教育就不仅仅是知识的简单提升。</p><p>21世纪，计算机改变了整个世界，对于新时代的发展，这样从顶至下的思维方式，会是解决问题的前提。</p><p>回过头来，最终还是要明确你要成为怎么样的一个人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于这个问题，其实根本上可以理解为两个方面的问题。一种是自上而下的理解，这是一种高屋建瓴，俯视问题的一看法。而另一中则相反，就是自下而上的方式。&lt;/p&gt;
&lt;p&gt;对于后者来说，在进一步普及到人们的生产生活当中，被叫做&lt;strong&gt;工匠式&lt;/strong&gt;的方式。经过长期经验
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>log001</title>
    <link href="http://yoursite.com/2018/02/02/log001/"/>
    <id>http://yoursite.com/2018/02/02/log001/</id>
    <published>2018-02-02T14:13:27.000Z</published>
    <updated>2018-02-02T14:14:25.003Z</updated>
    
    <content type="html"><![CDATA[<p>订阅得到的专栏也有一年时间了，但他们多是碎片话的知识，我至今累计订阅的5个专栏，一个专栏一年至少365篇文章，5个就是将近1600篇文章，每一篇文章都具有一个观点，或者说几篇文章一个系列。庞大的知识，经过一次阅读也就一些产生共鸣的些许文章有影响，说收获的话还真说不上来，可能更过的是潜移默化的吧，曾今也计划逐步的开始整理这些文章，但终究成为曾今。</p><p>不过这件事情，不管结果怎样都是应该继续做下去的。不说结果有多好，但至少是对自己有帮助的事情。</p><hr><p>今天从新听了一遍VOA，竟然感觉他说的好慢，虽然它本来就是慢速英语，但对于半年前的我来说，依然理解吃力。</p><hr><p>TODO List</p><ul><li>[x] 学太极</li><li>[ ] 七点起床</li><li>[x] 早上起来学习英语</li><li>[x] 基础2小时</li><li>[x] 项目2-3小时</li><li>[x] 下午英语学习</li><li>[x] 10点开会总结</li><li>[x] 得到两篇文章</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;订阅得到的专栏也有一年时间了，但他们多是碎片话的知识，我至今累计订阅的5个专栏，一个专栏一年至少365篇文章，5个就是将近1600篇文章，每一篇文章都具有一个观点，或者说几篇文章一个系列。庞大的知识，经过一次阅读也就一些产生共鸣的些许文章有影响，说收获的话还真说不上来，可能
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log000</title>
    <link href="http://yoursite.com/2018/02/01/log000/"/>
    <id>http://yoursite.com/2018/02/01/log000/</id>
    <published>2018-02-01T09:49:04.000Z</published>
    <updated>2018-02-01T09:53:38.300Z</updated>
    
    <content type="html"><![CDATA[<p>起源是在Yotube上面看到有很多人在拍<code>vlog</code>，于是乎，就联想到现在的状况。订阅了三个按年付费的知识付费栏目，基本上都是日更，刚开始可能会觉的很新鲜，但是随着时间的推移，自己每天需要的做的事情，也慢慢开始变得多起来。有时，真的只能记住一些花一天绝大部分时间z在做的事情。现在每天要干的事情，有学英语、学技术、写项目、练太极、看书、看日常订阅的专栏。如果你稍微偷懒或者不注意，时间就悄悄的溜走了。索性，直接给自己开一个活动，用来记录一天自己的成长与发生的事情～。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;起源是在Yotube上面看到有很多人在拍&lt;code&gt;vlog&lt;/code&gt;，于是乎，就联想到现在的状况。订阅了三个按年付费的知识付费栏目，基本上都是日更，刚开始可能会觉的很新鲜，但是随着时间的推移，自己每天需要的做的事情，也慢慢开始变得多起来。有时，真的只能记住一些花一天绝
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>计划</title>
    <link href="http://yoursite.com/2018/02/01/Splan/"/>
    <id>http://yoursite.com/2018/02/01/Splan/</id>
    <published>2018-02-01T03:33:27.000Z</published>
    <updated>2018-02-01T09:52:05.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="曾经"><a href="#曾经" class="headerlink" title="曾经"></a><strong>曾经</strong></h2><p>刚开始自己主动制定计划还是因为在那段时间，事情多到用脑子经常发生冲突,只能简单用笔和纸记录一下接下来要做的事情。对于计划的固有映象还保留在，想去依靠一个死的计划，来约束一个随时充满变数的人，根本就是一个笑话。但，当我渐渐习惯之后，开始有些意识到，通过它好像得到了些很不错的东西。</p><ol><li><p>更好的理解自己</p></li><li><p>拿回时间的控制权</p></li></ol><p>它的收获抽象的超乎想象，但除此以外，我想，自己还学会了些许坚持。</p><h2 id="开始的开始"><a href="#开始的开始" class="headerlink" title="开始的开始"></a><strong>开始的开始</strong></h2><p><strong>只在你下定决心并且迈出第一步时，才会真正的开始。仅仅从单纯的做规划来说，其本身意义并不大，一定要找到这件事属于自己的那唯一的意义。</strong>这两句话，应该是在做任何想做成的事情上面，都应该遵守的。</p><p>制定规划，效果并没有想象中的那么的快，要不，也不会有那么多人认为无用。任何需要努力才会得到的东西都已经不属于<strong>低垂的果实</strong>。当你们把它定义为这么一件事情时，成功摘取它的收获就不仅仅限于那颗果实了。想得到它并不容易，但是想轻而易举的得到，那根本就是一个无稽之谈。这一切都应该是你应该意识到的东西，通往优秀之路，并不是仅仅是你想象中的那么难而已，你为此你也应该付出足够多的代价。</p><p>给自己一个明确的规划，是你最应该的完成的，同时它也是使你变得优秀的第一步。</p><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a><strong>规划</strong></h2><p>对于计划，实施起来你所需要的工具，一个根笔和一张纸，并且还是一个正在想此刻这件事情的大脑就够了。接下来开动你的双手和大脑在纸上面写入如下类似的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">7:00            起床</div><div class="line">7:05 -- 8:05    早饭，洗漱，看早报</div><div class="line">...</div><div class="line">...</div><div class="line">...</div><div class="line">24:00           睡觉</div></pre></td></tr></table></figure></p><p>顺带写上分析和为什么要做计划也是不错的。到这里，我的计划就算完成，接着开始执行就可以了。下面我们来简单总结一下。</p><p>开个玩笑～，但是在这里就结束的人，你们根本就没有做好任何准备，或许，你们想去做一个让自己心灵得到安慰的事情仅仅而已，除此以外我真的为你们找不到其他理由。</p><p>在这就结束的人，我想你们应该缺乏一些认知。如果你在一张白纸上随意点一个点，并看不出什么，但随着你点点数量的增加，你会在某块区域聚集，到此这张纸你才能看出一点规律。这张纸才有了它的价值。对于现在这个大数据时代，只要拥有足够的信息，你会得到对于一个社会群体很多具有预测性的知识，进而去使用它们，例如广告，视频推送等。如果把它落到一个人身上，表面上你可以很大几率预测你的行为，本质上，你会得到你生活中那些恒定不变的东西。</p><p>在基于这样认知的前提的下，你需要的就不仅仅是一张计划表了，你需要随着时间推移，不断的去修正你的计划，只要你在执行计划的过程中，意识到这个计划已经不太适合自己，就应该去调整计划并且调整自己。这是一个不断自我了解，自我提高的一个过程。我常常说一句话：<strong>要常立志，而不能立常志</strong>，只有你不断的检省，你才会不断在这个过程中认识到自己不足，进而去不断的提高。最后你将会得到的东西就让你去感受吧。</p><p>所以你应该不断的重复下面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">制定计划</div><div class="line">执行计划</div><div class="line">反思计划</div></pre></td></tr></table></figure></p><h2 id="坚持"><a href="#坚持" class="headerlink" title="坚持"></a><strong>坚持</strong></h2><p>坚持是一种能力，而能力是可以后期培养的。如果你还认为自己并不具备这种能力，那么接下来的事情很简单，Just do it。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a><strong>结束语</strong></h2><p>我也是一名不断在这条通往更优秀的路上前进的人，希望我的一些话可以帮助到你。并且我也十分愿意去结交正在变得更优秀的你们。在这里并不会留联系方式，如果咱们彼此足够优秀，那我们迟早会见面的，所以在这里提前说一句：”你好，我的朋友”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;曾经&quot;&gt;&lt;a href=&quot;#曾经&quot; class=&quot;headerlink&quot; title=&quot;曾经&quot;&gt;&lt;/a&gt;&lt;strong&gt;曾经&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;刚开始自己主动制定计划还是因为在那段时间，事情多到用脑子经常发生冲突,只能简单用笔和纸记录一下接下来要做的
      
    
    </summary>
    
      <category term="2018-02" scheme="http://yoursite.com/categories/2018-02/"/>
    
    
      <category term="JianRan" scheme="http://yoursite.com/tags/JianRan/"/>
    
  </entry>
  
  <entry>
    <title>感谢我前进路上所有帮助过我的人以及我自己</title>
    <link href="http://yoursite.com/2017/12/14/%E6%84%9F%E8%B0%A2%E6%88%91%E5%89%8D%E8%BF%9B%E8%B7%AF%E4%B8%8A%E6%89%80%E6%9C%89%E5%B8%AE%E5%8A%A9%E8%BF%87%E6%88%91%E7%9A%84%E4%BA%BA%E4%BB%A5%E5%8F%8A%E6%88%91%E8%87%AA%E5%B7%B1/"/>
    <id>http://yoursite.com/2017/12/14/感谢我前进路上所有帮助过我的人以及我自己/</id>
    <published>2017-12-14T09:24:28.000Z</published>
    <updated>2017-12-14T09:26:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017年后半年我升大三以后，紧接是三门专业课，都算是重量级的——操作系统、计算机网络、数据库。因为自从大二开始以来，到现在，基本所有的专业课已经适应了自学，感觉在课堂上效率确实有那么一点低。好吧，不仅仅是有点低～。之后，就一门课一门课的去和代课老师谈，好让老师们同意，我想自学的这个想法。在自己的圈子中，我建议很多人都这样做，无奈不知道是什么原因，所有拥有我这样想法的人都碰了一鼻子灰，但自己去做的时候，反而一帆风顺，无论是班主任还是代课老师，经过几次沟通之后，都得到了许可。</p><p>说实话，当时的心情是真的开心。好像世界总是在眷顾我一样，从最初的班干部，到后来尝试着接一些项目来做，再到之后的已经历时一年的不上课计划，每一次当我想要什么样的资源的时候，总是十分自然的就得到了。而在大学开始之前，凡是个坎我都能摔的，前仰后翻的。</p><p>这么巧合的事情，刚开始时，落到谁身上，谁能不乱想。相信只要你认知以内的可能性，保证都去想过了，妖魔鬼怪, 风水，运势，星座等肯定都在脑子里面浮想联翩。</p><hr><blockquote><p>时间是任何人的老师，他会教会你，在人生路上所有的事情。</p></blockquote><p>渐渐我意识到，所有的这些都是在我努力提升自己之后的发生的，这里并不单单想说，努力可以改变人生之类的话，对努力而言，我抱着和知识基本一致的看法，「 纯粹的知识是没有任何意义的，同样的，努力同样也基本如此 」 。而更想表达，这个世界真的会让正确的人出现在正确的地点，彼此相同的人会相互吸引。这些某种特质相同的人，会更好的理解你的想法，进而认同并且给予我资源，我想感谢的恰恰是这是这些人，当然还有我的亲人，尽管我的很多做法，都是在做异类，已经超出一般人的限度，但他们还是一如既往的支持我。</p><p>在我前进路上，帮助过我的人，真的太多，虽然仅仅是发生在大学两年半的时间里面，但恰恰就是因为在如此短的时间内，有这么多人帮助过我，我能做的也仅仅是以我当时的能力来最大限度的感谢你们了。未来的路还很长，我也必然被很多人帮助，但是凡是帮助过我的，无论大小，我都会牢牢记在心里。</p><hr><p>大三上半学期即将结束，这个学期唯一的遗憾就是，自己太过于忙碌，忙的甚至没有片刻时间，让自己回头来看看和驻足思考。</p><p>除了技术外，这学期收货的更多的感恩。</p><p>最后希望自己在下一个半年，自己可以找到一个平衡点。</p><p>#That’s All</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017年后半年我升大三以后，紧接是三门专业课，都算是重量级的——操作系统、计算机网络、数据库。因为自从大二开始以来，到现在，基本所有的专业课已经适应了自学，感觉在课堂上效率确实有那么一点低。好吧，不仅仅是有点低～。之后，就一门课一门课的去和代课老师谈，好让老师们同意，我想
      
    
    </summary>
    
      <category term="2017-12" scheme="http://yoursite.com/categories/2017-12/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>心态前言</title>
    <link href="http://yoursite.com/2017/10/13/%E5%BF%83%E6%80%81%E5%89%8D%E8%A8%80/"/>
    <id>http://yoursite.com/2017/10/13/心态前言/</id>
    <published>2017-10-12T17:44:56.000Z</published>
    <updated>2017-10-12T17:46:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>唯有冷静去接收一切，才会真正的持久。激情背后的浮躁往往是使一件事情变的糟糕的源头。学会在激情中冷静是恰当的进步之道</p></blockquote><p>深入呼吸 3min …</p><hr><p>哪怕是跟着前人的脚印，写懂一个操作系统都绝非易事。无论你的平台是什么，你的每一个脚印务必踏的坚实。你的前进才是真正的前进。</p><p>在写操作系统的时候，必须处在一个冷静的状态下去完成。何为冷静？遇事不慌不乱，有条不紊。不在乎时间成本，只求写一点懂一点（这是针对当前计划来说的）。</p><p>在接下来的工作中，将会接触到很多工具，而且这些工具很多将会是没有接触过得，同时也包括很多新的知识点。当我们遇到的时候应该兴平气和的看懂之后才可以前进，遇到不会的地方及时停止去解决掉，在必要的时候要写文档总结记录。每一篇文章力求 <strong>只字不差</strong> 的冷静阅读。</p><hr><p>当然这里的「不在乎时间成本」实际是节约时间，不过实际怎么样无所谓，它的结果会导致计划周期变长，为了不让他变得不可控，我们来简单计算一下，首先这个目标计划在12月底完成，距离现在还有77天时间，这本书的总页数469，还有大概450页，平均每天大概要看6页，我们每天花费的时间大概是 90min，平均下来每页15分钟看完。</p><p>这么算下来时间是很充足的，更不用说，这本书讲的会很明白很好懂，另外书中有很大一部分实在聊天。</p><p>时间很充足，请耐心的学习</p><h1 id="That’s-All"><a href="#That’s-All" class="headerlink" title="That’s All"></a>That’s All</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;唯有冷静去接收一切，才会真正的持久。激情背后的浮躁往往是使一件事情变的糟糕的源头。学会在激情中冷静是恰当的进步之道&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;深入呼吸 3min …&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;哪怕是跟着前人的脚印，写懂一个操作系统都绝
      
    
    </summary>
    
      <category term="2017-10" scheme="http://yoursite.com/categories/2017-10/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Adapter设计模式与 ListView 和 RecylerView</title>
    <link href="http://yoursite.com/2017/09/05/Adapter%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E-ListView-%E5%92%8C-RecylerView/"/>
    <id>http://yoursite.com/2017/09/05/Adapter设计模式与-ListView-和-RecylerView/</id>
    <published>2017-09-05T12:09:08.000Z</published>
    <updated>2017-09-05T12:11:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>永远不做超出当前认知的事情</p></blockquote><p>简单谈谈 Adapter设计模式，及其在 Android 中的简单应用，尝试着去理解这些设计。</p><p> Adapter模式的<strong>定义：</strong>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配的问题而无法一起工作的两个类能够一起工作。</p><p> Adapter模式 换句话说，就像条想要给手机充电的USB线，光有USB插头是无法插到插座上给手机充电的，需要连接个充电头才可以实现。那么这个充电头就是 Adapter。提供了一个转换接头，让USB接口与插座完全解耦，两者之间没有任何联系。在代码中实现其实就是在这二者中间加入了一个类获取其他可以实现这种功能的代码。</p><p> 比较经典的是 ListView 和 RecylerView 的 Adapter 类，两者的结构完全相同。</p><p> 首先，ListView 和 RecylerView 直接需要View的引用，及其View的数量等信息，但是我们能提供的只能是什么信息都没有的View 和 独立的一堆信息，这个工作如果直接传给 ListView 和 RecylerView 他们来做，就会直接耦合在一起，ListView 和 RecylerView 将会过于臃肿，结构混乱。</p><p> 我们做的事情是把对于他们而言，他们所需要的信息由Adapter直接提供。而 Adapter的具体细节他们不需要知道了。我们把 信息全部传递给 Adapter，让它进行内部的组合，组合处合理的信息即可。</p><blockquote><p>说白了就是USB接口和充电头之间的关系</p></blockquote><h2 id="两种不同的实现方式"><a href="#两种不同的实现方式" class="headerlink" title="两种不同的实现方式"></a>两种不同的实现方式</h2><p><strong>类适配器模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//USB</div><div class="line">public class USB&#123;</div><div class="line"></div><div class="line">    //使用USB传输电能</div><div class="line">    public void usbEnergy()&#123;&#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">//转换头</div><div class="line">public  interface TransHead&#123;</div><div class="line"></div><div class="line">    //使用插头传输电能</div><div class="line">    public void usbEnergy;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class EnergyAdapter extends USB implements TransHead&#123;</div><div class="line"></div><div class="line">    public void usbEnergy()&#123;</div><div class="line">        usbEnergy()&#123;&#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>对象适配器模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class EnergyAdapter implements TransHead&#123;</div><div class="line">    USB usb;</div><div class="line">    </div><div class="line">    EnergyAdapter(USB usb)&#123;</div><div class="line">        this.usb = usb;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void usbEnergy()&#123;</div><div class="line">        usb.usbEnergy();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="That’s-All"><a href="#That’s-All" class="headerlink" title="That’s All"></a>That’s All</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;永远不做超出当前认知的事情&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单谈谈 Adapter设计模式，及其在 Android 中的简单应用，尝试着去理解这些设计。&lt;/p&gt;
&lt;p&gt; Adapter模式的&lt;strong&gt;定义：&lt;/strong&gt;适配器
      
    
    </summary>
    
      <category term="2017-9" scheme="http://yoursite.com/categories/2017-9/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Fragment详解——管理Fragment</title>
    <link href="http://yoursite.com/2017/09/04/Fragment%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E7%AE%A1%E7%90%86Fragment/"/>
    <id>http://yoursite.com/2017/09/04/Fragment详解——管理Fragment/</id>
    <published>2017-09-04T12:09:14.000Z</published>
    <updated>2017-09-04T12:13:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章当中，我们总览性的了解到 Fragment 的基本使用和用途。一些最为基础的知识已经学习完毕。接下来我们就要深入到更加具体的内容来进行学习。</p><p>##FragmentManager</p><p>它的作用是对Fragment的状态进行保存与恢复。对 Fragment 的一些管理操作都被封装到这个类当中，最让我们熟知的用法，想必是获取一个 FragmentManager 实例，进而开启一个事务对 Fragment 进行相关操作。获取 FragmentManager 是 Activity 本身的一个方法的结果（getFragmentManager）。仔细思考其中的道理，不难想清楚，对于 Activity 而言它本身是可以依赖多个 Fragment，如果对于每个Fragment单独操作，不免费事费力，不如提供一个统一的一个接口来进行使用。</p><p>常用的方法如下：</p><ol><li>findFragmentById()<br>根据 ID 来获取对应的 Fragment 实例，主要使用在静态绑定中</li><li>findFragmentByTag()<br>意思基本和上面相同</li><li>beginTransaction()<br>开启一个事务</li></ol><p>##FragmentTransaction</p><p>常用方法如下：</p><ol><li><p>add(int containerViewId, Fragment fragment, String tag)<br>将一个fragment实例添加到Activity的最上层 </p></li><li><p>remove(Fragment fragment)<br>将一个fragment实例从Activity的fragment队列中删除  </p></li><li><p>replace(int containerViewId, Fragment fragment)<br>替换 containerViewId 中的 fragment 实例，注意，它首先把 containerViewId 中所有 fragment 删除，然后再 add 进去当前的 fragment  </p></li></ol><p>##有关回滚——FragmentTransaction</p><p>上面简单记录了一个相关的主要方法，现在我们来简单说一个回滚功能。要实现回滚只需要 commit() 和 addToBackStack(String tag)这个两个方法，每次在commit()之前，使用<strong>addToBackStack()</strong>将其添加到回退栈中。需要回退的时候只需要使用 popBackStack() 方法即可，回退的单位是以一次 commit() 为主。</p><blockquote><p>另外补充说明一下，FragmentManager 还提供了监听回退栈的方法<br>FragmentManager::addOnBackStackChangedListener(listener);//添加监听器<br>FragmentManager::removeOnBackStackChangedListener(listener);//移除监听器 </p><p>不过,这里你们要注意理解为什么 FragmentManager 提供监听回退栈的方法。</p></blockquote><p>##That’s All</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在之前的文章当中，我们总览性的了解到 Fragment 的基本使用和用途。一些最为基础的知识已经学习完毕。接下来我们就要深入到更加具体的内容来进行学习。&lt;/p&gt;
&lt;p&gt;##FragmentManager&lt;/p&gt;
&lt;p&gt;它的作用是对Fragment的状态进行保存与恢复。对 F
      
    
    </summary>
    
      <category term="2017-9" scheme="http://yoursite.com/categories/2017-9/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Fragment详解——基本使用</title>
    <link href="http://yoursite.com/2017/07/21/Fragment%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/07/21/Fragment详解——基本使用/</id>
    <published>2017-07-21T10:38:04.000Z</published>
    <updated>2017-07-21T10:38:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们先从一个总览的角度去理解什么是「 静态 」添加 Fragment 和「 动态 」添加 Fragment？</p><p>先让我们来看一个图片，关系显然易见，对于 Fragment 来说他是 Activity 与 View 中间用来衔接的。 Activity 使用 Fragment 的形式是通过控件的形式来进行使用的，对于静和动态两种不同的形式，是对于 Activity 与 Fragment 之间这一层关系来说。写死了，那就说明是「 静态 」，运行时添加的，那就说明是「 动态 」。关系理清楚了，对于 Fragment 的使用方式也容易记忆并且使用了，具体的一些其他细节会在下面写出并且说明。<br><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fhrlstqlzkj30ks0bq74c.jpg" alt=""></p><p>##公共资源的准备</p><p>上面说了，对于静态和动态两种方式使用 Fragment，主要差别在于 Activity 与 Fragment的关系是否是可以活动的。而 Fragment 与 View 的关系自然是一一对应的。一个 Fragment 操作一个 View 的业务逻辑。</p><p>在这里我们可以简单思考一下，因为 Fragment 的存在 Activity 与 View 彻底解耦，任何 View 可以随意结合任何一个 Activty，使用更加灵活。并且一个好消息是  创建一个 Fragment 的消耗很小，虽然 Fragment 本身也有很多的 Bug 存在，但是与之也有对应的解决方案，同时 Google 也在慢慢修改中。</p><p><strong>让我们开始:</strong><br>1、创建第一个 fragmeng_1.xml, 代码如下:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"</div><div class="line">    android:layout_width="match_parent"</div><div class="line">    android:layout_height="match_parent"</div><div class="line">    android:background="#00ff00" &gt;</div><div class="line"></div><div class="line">    &lt;TextView</div><div class="line">        android:layout_width="wrap_content"</div><div class="line">        android:layout_height="wrap_content"</div><div class="line">        android:text="This is fragment 1"</div><div class="line">        android:textColor="#000000"</div><div class="line">        android:textSize="25sp" /&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>2、创建第二个 fragment_2.xml，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  </div><div class="line">    android:layout_width=&quot;match_parent&quot;  </div><div class="line">    android:layout_height=&quot;match_parent&quot;  </div><div class="line">    android:background=&quot;#ffff00&quot; &gt;  </div><div class="line">  </div><div class="line">    &lt;TextView  </div><div class="line">        android:layout_width=&quot;wrap_content&quot;  </div><div class="line">        android:layout_height=&quot;wrap_content&quot;  </div><div class="line">        android:text=&quot;This is fragment 2&quot;  </div><div class="line">        android:textColor=&quot;#000000&quot;  </div><div class="line">        android:textSize=&quot;25sp&quot; /&gt;  </div><div class="line">  </div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure><p>3、连续创建两个 Fragment 类，并且将 fragment_1.xml 和 fragment_2.xml与之进行绑定。<br>代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Fragment1 extends Fragment &#123;  </div><div class="line">    @Override  </div><div class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;  </div><div class="line">        return inflater.inflate(R.layout.fragment_1, container, false);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Fragment2 extends Fragment &#123;  </div><div class="line">    @Override  </div><div class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;  </div><div class="line">        return inflater.inflate(R.layout.fragment2_, container, false);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>到此我们已经将xml 与 Fragment 一一对应。</p><p>##静态绑定</p><p>这个是直接把 Activity 与 Fragment 固定，通过 fragment 控件写死的，在之下的代码中需要注意的是，name 属性代表的是与这个控件进行绑定的 Fragment 的全类名。同时必须要有唯一标识符，这个用属性 id 或者 tag 来进行表示即可。<br>代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;--!activity_main.xml--&gt;</div><div class="line"></div><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;</div><div class="line">    tools:context=&quot;jinfangzhang.github.fragmentdemo.MainActivity&quot;&gt;</div><div class="line"></div><div class="line">    &lt;fragment</div><div class="line">        android:tag=&quot;@+id/fragment1&quot;</div><div class="line">        android:name=&quot;jinfangzhang.github.fragmentdemo.Fragment_1&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_weight=&quot;1&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        /&gt;</div><div class="line">    &lt;fragment</div><div class="line">        android:id=&quot;@+id/fragment2&quot;</div><div class="line">        android:name=&quot;jinfangzhang.github.fragmentdemo.Fragment_2&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_weight=&quot;1&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;</div><div class="line">        /&gt;</div><div class="line"></div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure><p>Activity中onCreate函数什么都没有写。</p><p>##动态绑定</p><p>activity_main.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/button_1&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;Button</div><div class="line">        android:id=&quot;@+id/button_2&quot;</div><div class="line">        android:layout_width=&quot;wrap_content&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;FrameLayout</div><div class="line">        android:id=&quot;@+id/fragment_container&quot;</div><div class="line">        android:layout_width=&quot;match_parent&quot;</div><div class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</div><div class="line">&lt;/LinearLayout&gt;</div></pre></td></tr></table></figure></p><p>对于 Activity 中的方法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main_2);</div><div class="line">    Log.e(&quot;Activity&quot;,&quot;Activity---onCreate()&quot;);</div><div class="line">    Button btnLoadFrag1 = (Button)findViewById(R.id.button_1);</div><div class="line">    btnLoadFrag1.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onClick(View v) &#123;</div><div class="line">            FragmentManager manager = getFragmentManager();</div><div class="line">            FragmentTransaction transaction = manager.beginTransaction();</div><div class="line">            Fragment_1 fragment1 = new Fragment_1();</div><div class="line"></div><div class="line">            transaction.replace(R.id.fragment_container,fragment1);</div><div class="line">            transaction.commit();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    Button btnLoagFrag2 = (Button)findViewById(R.id.button_2);</div><div class="line">    btnLoagFrag2.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onClick(View v) &#123;</div><div class="line">            FragmentManager manager = getFragmentManager();</div><div class="line">            FragmentTransaction transaction = manager.beginTransaction();</div><div class="line">            Fragment_2 fragment2 = new Fragment_2();</div><div class="line">            transaction.replace(R.id.fragment_container, fragment2);</div><div class="line">            transaction.commit();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里主要分为四步：<br>1、获取 FragmentManager 对象，在 v4 包里面使用的是 getSupportFragmentManager() 获得，原生使用 getFragmentManager().</p><blockquote><p>对于原生和 v4 的使用，其实差别就在 Activity 继承是什么，如果你的 Fragment 继承来自 v4，那么 Activity 应该继承 FragmentActivity，而如果是原生，就什么都不要动了</p></blockquote><p>2、通过 Manager 对象获取并且开启一个事务。<br>3、向容器内加入Fragment，一般使用add或者replace方法实现，需要传入容器的id和Fragment的实例。<br>4、提交事务，调用commit方法提交。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们先从一个总览的角度去理解什么是「 静态 」添加 Fragment 和「 动态 」添加 Fragment？&lt;/p&gt;
&lt;p&gt;先让我们来看一个图片，关系显然易见，对于 Fragment 来说他是 Activity 与 View 中间用来衔接的。 Activity 使用 Fra
      
    
    </summary>
    
      <category term="2017-7" scheme="http://yoursite.com/categories/2017-7/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Fragment详解——生命周期</title>
    <link href="http://yoursite.com/2017/07/21/Fragment%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/07/21/Fragment详解（一）/</id>
    <published>2017-07-21T03:38:23.000Z</published>
    <updated>2017-07-21T08:12:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是关于Fragment的生命周期图，简单理解下，同时下面是Fragment与Activity生命周期对比</p><p><img src="http://ww1.sinaimg.cn/large/006o5OgAly1fhrbuh1lqfj30k10npq52.jpg" alt=""></p><hr><p>接下来我们逐个对方法解释：<br><strong>onAttach:</strong> onAttach()方法与Activity关联之后调用，也就是在执行了 「setContentView（）」这个方法之后，就和 fragment 建立了联系。</p><p><strong>onCreate:</strong> fragment 初次创建时调用，尽管他看起来非常像 Activty 的 onCreate 。此时 Activity 还没有建立完成，因为我们的 Fragment 也是 Activity 的一部分，所以在这里你想获取一些关于 Activity 中的一些资源，将会获取不到。</p><p><strong>onCreateView:</strong> 在这个 fragment构造它的布局时进行调用。在这里返回此Fragment的一个视图层次结构。同时使用 LayoutInflater 的 inflater() 方法来构造实图，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public View onCreateView(LayoutInflater inflater, ViewGroup container,  </div><div class="line">                         Bundle savedInstanceState) &#123;  </div><div class="line">    return inflater.inflate(R.layout.fragment3, container, false);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>onActivityCreated:</strong>在 Activity 的 onCreate 完成之后会调用这个函数，所以这个时候 Activity 已经创建完毕，在这个方法当中可以获取 Activity 的所有资源的。 </p><p><strong>onStart:</strong>当到 onStart() 时, Fragment 对用户就是可见的了，但是这个时候用户还没有和 Fragment 交互。在生命周期中也可以看到，Fragment 的 onStart 与 Activity 的 onStart 是绑定着的。</p><p><strong>onResume:</strong>这是 Fragment 与用户交互之前进行的最后一个回调。这个方法执行结束之后，就可以与 Fragment 进行交互了</p><p>onPause：此回调与 Activity 的 onPause() 相绑定，与 Activity 的 onPause() 意义一样。</p><p><strong>onStop:</strong>这个也和 onPause 相同就不解释了。</p><p><strong>onDestroyView:</strong> 如果 Fragment 即将被结束或者保存，那么撤销方向上面的下一个回调将会是该方法。这个方法会将在 onCreateView 中创建的视图与这个 Fragment 分离。下次这个 Fragment 若要显示，那么将会重新创建视图。</p><p><strong>onDestroy:</strong>当这个fragment不再使用时调用。需要注意的是，它即使经过了onDestroy()阶段，但仍然能从Activity中找到，因为它还没有Detach。</p><p><strong>onDetach:</strong>Fragment生命周期中最后一个回调是onDetach()。调用它以后，Fragment就不再与Activity相绑定，它也不再拥有视图层次结构，它的所有资源都将被释放。</p><hr><p>总结:<br>在这里简单总结以下 Fragment 过程。<br>大概可以分为两类: 第一类是 Fragment 与 Activity 建立联系，第二类是 Fragment 与 View 建立联系。<br>过程总结如下:<br>1、与 Activyt 建立联系<br>2、与 View 建立联系<br>3、与 用户 进行交互<br>4、与 View 失去联系<br>5、与 Activity 失去联系</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是关于Fragment的生命周期图，简单理解下，同时下面是Fragment与Activity生命周期对比&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006o5OgAly1fhrbuh1lqfj30k10npq52.jpg&quot; 
      
    
    </summary>
    
      <category term="2017-7" scheme="http://yoursite.com/categories/2017-7/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>共享库</title>
    <link href="http://yoursite.com/2017/06/08/%E5%85%B1%E4%BA%AB%E5%BA%93/"/>
    <id>http://yoursite.com/2017/06/08/共享库/</id>
    <published>2017-06-08T11:36:48.000Z</published>
    <updated>2017-06-08T11:38:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>前一篇我们讲了静态库，我们来到了 链接阶段的最后一部分，事不宜迟继续我们今天的战斗。</p><hr><p>组成共享库的目标文件和一般的目标文件是有所不同的，在编译时要加 -fPIC 选项</p><p>例如</p><pre><code>gcc -c -fPIC stack/stack.c stack/push.c stack/pop.c stack/is_empty.c</code></pre><p>由于接下来要用 objdump -dS 把反汇编指令和源代码穿插起来分析，所以用 -g 选项来加调试信息。注意，必须在编译每个文件时都要加 -g 选项，而不能只在最后链接时加 -g 选项，如果目标文件中没有调试信息，链接生成的可执行文件也不会有的。我们反汇编查看下 push.o </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ objdump -dS push.o</div><div class="line"></div><div class="line">push.o：     文件格式 elf64-x86-64</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">0000000000000000 &lt;push&gt;:</div><div class="line">extern char stack[512];</div><div class="line">extern int top;</div><div class="line"></div><div class="line">void push(char c)&#123;</div><div class="line">   0:   55                      push   %rbp</div><div class="line">   1:   48 89 e5                mov    %rsp,%rbp</div><div class="line">   4:   89 f8                   mov    %edi,%eax</div><div class="line">   6:   88 45 fc                mov    %al,-0x4(%rbp)</div><div class="line">    stack[++top] = c;</div><div class="line">   9:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # f &lt;push+0xf&gt;</div><div class="line">   f:   83 c0 01                add    $0x1,%eax</div><div class="line">  12:   89 05 00 00 00 00       mov    %eax,0x0(%rip)        # 18 &lt;push+0x18&gt;</div><div class="line">  18:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 1e &lt;push+0x1e&gt;</div><div class="line">  1e:   48 63 d0                movslq %eax,%rdx</div><div class="line">  21:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 28 &lt;push+0x28&gt;</div><div class="line">  28:   0f b6 4d fc             movzbl -0x4(%rbp),%ecx</div><div class="line">  2c:   88 0c 02                mov    %cl,(%rdx,%rax,1)</div><div class="line">  2f:   90                      nop</div><div class="line">  30:   5d                      pop    %rbp</div><div class="line">  31:   c3                      retq</div></pre></td></tr></table></figure><p>指令中方式用到 stack 和 top 的地址都用 0x0 表示，以备在重定向时修改。再看 readelf 的 .rel.text 段的信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">重定位节 &apos;.rela.text&apos; 位于偏移量 0x488 含有 4 个条目：</div><div class="line">  偏移量          信息           类型           符号值        符号名称 + 加数</div><div class="line">00000000000b  000e00000002 R_X86_64_PC32     0000000000000000 top - 4</div><div class="line">000000000014  000e00000002 R_X86_64_PC32     0000000000000000 top - 4</div><div class="line">00000000001a  000e00000002 R_X86_64_PC32     0000000000000000 top - 4</div><div class="line">000000000024  000f00000002 R_X86_64_PC32     0000000000000000 stack - 4</div></pre></td></tr></table></figure><p>上述信息指出了指令中有四处需要在重定位时修改。编译连接成可执行文件之后，再做反编译分析:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">0000000000000675 &lt;push&gt;:</div><div class="line">extern char stack[512];</div><div class="line">extern int top;</div><div class="line"></div><div class="line">void push(char c)&#123;</div><div class="line"> 675:   55                      push   %rbp</div><div class="line"> 676:   48 89 e5                mov    %rsp,%rbp</div><div class="line"> 679:   89 f8                   mov    %edi,%eax</div><div class="line"> 67b:   88 45 fc                mov    %al,-0x4(%rbp)</div><div class="line">    stack[++top] = c;</div><div class="line"> 67e:   8b 05 8c 09 20 00       mov    0x20098c(%rip),%eax        # 201010 &lt;top&gt;</div><div class="line"> 684:   83 c0 01                add    $0x1,%eax</div><div class="line"> 687:   89 05 83 09 20 00       mov    %eax,0x200983(%rip)        # 201010 &lt;top&gt;</div><div class="line"> 68d:   8b 05 7d 09 20 00       mov    0x20097d(%rip),%eax        # 201010 &lt;top&gt;</div><div class="line"> 693:   48 63 d0                movslq %eax,%rdx</div><div class="line"> 696:   48 8d 05 a3 09 20 00    lea    0x2009a3(%rip),%rax        # 201040 &lt;stack&gt;</div><div class="line"> 69d:   0f b6 4d fc             movzbl -0x4(%rbp),%ecx</div><div class="line"> 6a1:   88 0c 02                mov    %cl,(%rdx,%rax,1)</div><div class="line"> 6a4:   90                      nop</div><div class="line"> 6a5:   5d                      pop    %rbp</div><div class="line"> 6a6:   c3                      retq</div></pre></td></tr></table></figure><p>原来指令中 0x0 被改成了正经的地址，这样做了重定位之后，各段的加载就定死了，因为在指令使用了绝对地址。</p><p>我们来看看用了 -fPIC 选项编译生成的目标文件有什么不同:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ objdump -dS push.o</div><div class="line"></div><div class="line">push.o：     文件格式 elf64-x86-64</div><div class="line"></div><div class="line"></div><div class="line">Disassembly of section .text:</div><div class="line"></div><div class="line">0000000000000000 &lt;push&gt;:</div><div class="line">extern char stack[512];</div><div class="line">extern int top;</div><div class="line"></div><div class="line">void push(char c)&#123;</div><div class="line">   0:   55                      push   %rbp</div><div class="line">   1:   48 89 e5                mov    %rsp,%rbp</div><div class="line">   4:   89 f8                   mov    %edi,%eax</div><div class="line">   6:   88 45 fc                mov    %al,-0x4(%rbp)</div><div class="line">    stack[++top] = c;</div><div class="line">   9:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # 10 &lt;push+0x10&gt;</div><div class="line">  10:   8b 00                   mov    (%rax),%eax</div><div class="line">  12:   8d 50 01                lea    0x1(%rax),%edx</div><div class="line">  15:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # 1c &lt;push+0x1c&gt;</div><div class="line">  1c:   89 10                   mov    %edx,(%rax)</div><div class="line">  1e:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax        # 25 &lt;push+0x25&gt;</div><div class="line">  25:   8b 00                   mov    (%rax),%eax</div><div class="line">  27:   48 8b 15 00 00 00 00    mov    0x0(%rip),%rdx        # 2e &lt;push+0x2e&gt;</div><div class="line">  2e:   48 98                   cltq</div><div class="line">  30:   0f b6 4d fc             movzbl -0x4(%rbp),%ecx</div><div class="line">  34:   88 0c 02                mov    %cl,(%rdx,%rax,1)</div><div class="line">  37:   90                      nop</div><div class="line">  38:   5d                      pop    %rbp</div><div class="line">  39:   c3                      retq</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> 重定位节 &apos;.rela.text&apos; 位于偏移量 0x4c8 含有 4 个条目：</div><div class="line">  偏移量          信息           类型           符号值        符号名称 + 加数</div><div class="line">00000000000c  000f0000002a R_X86_64_REX_GOTP 0000000000000000 top - 4</div><div class="line">000000000018  000f0000002a R_X86_64_REX_GOTP 0000000000000000 top - 4</div><div class="line">000000000021  000f0000002a R_X86_64_REX_GOTP 0000000000000000 top - 4</div><div class="line">00000000002a  00100000002a R_X86_64_REX_GOTP 0000000000000000 stack - 4</div></pre></td></tr></table></figure><p>push.o 的代码几乎完全和 之前的不相同，.rela.text 表中的类型也不相同。</p><p>下来我们编译生成共享库再反汇编分析:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">00000000000006f0 &lt;push&gt;:</div><div class="line">extern char stack[512];</div><div class="line">extern int top;</div><div class="line"></div><div class="line">void push(char c)&#123;</div><div class="line"> 6f0:   55                      push   %rbp</div><div class="line"> 6f1:   48 89 e5                mov    %rsp,%rbp</div><div class="line"> 6f4:   89 f8                   mov    %edi,%eax</div><div class="line"> 6f6:   88 45 fc                mov    %al,-0x4(%rbp)</div><div class="line">    stack[++top] = c;</div><div class="line"> 6f9:   48 8b 05 d8 08 20 00    mov    0x2008d8(%rip),%rax        # 200fd8 &lt;top@@Base-0x48&gt;</div><div class="line"> 700:   8b 00                   mov    (%rax),%eax</div><div class="line"> 702:   8d 50 01                lea    0x1(%rax),%edx</div><div class="line"> 705:   48 8b 05 cc 08 20 00    mov    0x2008cc(%rip),%rax        # 200fd8 &lt;top@@Base-0x48&gt;</div><div class="line"> 70c:   89 10                   mov    %edx,(%rax)</div><div class="line"> 70e:   48 8b 05 c3 08 20 00    mov    0x2008c3(%rip),%rax        # 200fd8 &lt;top@@Base-0x48&gt;</div><div class="line"> 715:   8b 00                   mov    (%rax),%eax</div><div class="line"> 717:   48 8b 15 ca 08 20 00    mov    0x2008ca(%rip),%rdx        # 200fe8 &lt;stack@@Base-0x78&gt;</div><div class="line"> 71e:   48 98                   cltq</div><div class="line"> 720:   0f b6 4d fc             movzbl -0x4(%rbp),%ecx</div><div class="line"> 724:   88 0c 02                mov    %cl,(%rdx,%rax,1)</div><div class="line"> 727:   90                      nop</div><div class="line"> 728:   5d                      pop    %rbp</div><div class="line"> 729:   c3                      retq</div></pre></td></tr></table></figure><p>在这台机器里面看的不是那么明显，主要还是看背后注释的差距。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">201010 &lt;top&gt; 变成了 # 200fd8 &lt;top@@Base-0x48&gt;</div></pre></td></tr></table></figure><p>通过注释我们意识到，我们这个不是一个绝对地址。所以共享库各段的加载地址并没有被定死，可以加载到任意的位置，因为指令中的地址都是相对于 top@@Base 的，这就是位置无关代码的特点。</p><p>接下来我们把 main.c 与共享库编译链接在一起，然后运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ gcc main.c -g -L. lstack -Istack -o main</div><div class="line">jianran@jianran:~/桌面/x86HB$ ./main</div><div class="line">./main: error while loading shared libraries: libstack.so: cannot open shared object file: No such file or directory</div></pre></td></tr></table></figure><p>结果十分的令人神奇，编译的时候没有问题，然后在执行的时候，报错说找不到 libstack.so。 那么运行时在那些路径下来找共享库呢？</p><p>我们先用 ldd 命令查看可执行文件依赖于那些共享库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ ldd main</div><div class="line">        linux-vdso.so.1 =&gt;  (0x00007ffcd41ab000)</div><div class="line">        libstack.so =&gt; not found</div><div class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd788704000)</div><div class="line">        /lib64/ld-linux-x86-64.so.2 (0x00005569c3f91000)</div></pre></td></tr></table></figure></p><p>ldd 模拟运行一遍 main程序 ，在运行过程中做动态链接，从而得知这个程序依赖于哪些共享库以及这些共享库都在声明路径下。我们在之前说到过 gcc 调用 ld 做链接时用 -dynamic-linker … 选项指定动态链接器的路径，动态链接器也像其他共享库一样加载到进程的地址空间中。而另一个 -lc 只说明需要链接 libc 却没有指出 libc 库的完整路径，-lstack 也是如此，共享库的路径需要在运行时由动态链接器进行查找。在上面的代码当中，动态链接器找到libc.so.6，而 libstack 的路径没有找到，无法完成链接。</p><p>那么动态链接库会到哪些目录下搜索共享库呢？<br>路径搜索顺序如下:</p><ol><li><p>首先在环境变量 LD_LIBRARY_PATH 保存的路径中查找</p></li><li><p>然后从缓存文件 /etc/ld.so.cache 中查找。这个缓存文件是由 ldconfig 命令读取配置文件 /etc/ld.so.conf 生成的</p></li></ol><p>3.如果上述步骤没有找到，则到默认的系统库文件目录查找。</p><p>知道了搜索顺序，也就算知道了解决方案了:</p><p><strong>第一种解决方案</strong>，在运行程序时设置环境变量 LD_LIBRARY_PATH 把共享库所在的目录添加到搜索路径,这种方式，只适合开发调试中临时使用一下，但是不建议使用</p><pre><code>export LD_LIBRARY_PATH=~/桌面/x86HB./main</code></pre><p>第一条命令在当前 Shell 进程中设置一个环境变量 LD_LIBRARY_PATH，一旦在 Shell 进程当中设置了环境变量，以后每次执行命令时 Shell 进程都会把自己的环境变量传给新创建的进程，所以第二条指令就得以运行成功了。</p><p><strong>第二种解决方案</strong>，这是最常用的方法。把 libstack.so 所在的目录的绝对路径添加到配置文件 /etc/ld.so.conf（该文件当中每个路径占一行），然后运行 ldconfig 命令。</p><p>ldconfig 命令除了处理 /etc/ld.so.conf 中配置的目录之外，还处理一些默认目录，处理的过程主要是建立索引以便快速查找，处理之后生成 /etc/ld.so.cache 缓存文件，动态链接库就从这个缓存文件中搜索共享库，配置之后通过 ldd 就可以找到了</p><p><strong>第三种方法</strong>，就是把 libstack.so 复制到 /usr/lib或者/lib 目录之下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前一篇我们讲了静态库，我们来到了 链接阶段的最后一部分，事不宜迟继续我们今天的战斗。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;组成共享库的目标文件和一般的目标文件是有所不同的，在编译时要加 -fPIC 选项&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc -c -fPIC sta
      
    
    </summary>
    
      <category term="2017-6" scheme="http://yoursite.com/categories/2017-6/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言剖析————静态库</title>
    <link href="http://yoursite.com/2017/06/08/C%E8%AF%AD%E8%A8%80%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <id>http://yoursite.com/2017/06/08/C语言剖析————静态库/</id>
    <published>2017-06-08T11:34:40.000Z</published>
    <updated>2017-06-08T11:36:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候需要把一组代码编译成一个库，这个库在很多项目都要用到，例如 libc 就是这样一个库，我们在不同的程序中都会用到 libc 中定义的库函数（例如 printf（3）和全局变量 （例如 environ（3））。接下来的两篇的重点介绍如何创建这样的库，同时通过这样的方式，让我们来理解进一步理解</p><p>我们继续用 stack.c 的例子。为了便于理解，我们把 stack.c 拆分为是个 .c  文件（虽然实际情况下，这么做没有太大的必要），我们接下来用到的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/* stack.c */</div><div class="line">char stack[512];</div><div class="line">int top = -1;</div><div class="line"></div><div class="line">/* push.c */</div><div class="line">extern char stack[512];</div><div class="line">extern int top;</div><div class="line"></div><div class="line">void push(char c)&#123;</div><div class="line">    stack[++top] = c;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* pop.c */</div><div class="line">extern char stack[512];</div><div class="line">extern int top;</div><div class="line"></div><div class="line">char pop(void)&#123;</div><div class="line">    return stack[top--];</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* is_empty.c */</div><div class="line">extern int top;</div><div class="line">int is_empty(void)&#123;</div><div class="line">    return top == -1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* stack.h*/</div><div class="line"></div><div class="line">#ifndef STACK_H</div><div class="line">#define STACK_H</div><div class="line">extern void push(char);</div><div class="line">extern char pop(void);</div><div class="line">extern int is_empty(void);</div><div class="line">#endif</div><div class="line"></div><div class="line">/* main.c */</div><div class="line"></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &quot;stack.h&quot;</div><div class="line"></div><div class="line">int main(void)&#123;</div><div class="line">    push(&apos;a&apos;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>目录结构如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ tree</div><div class="line">.</div><div class="line">├── main.c</div><div class="line">└── stack</div><div class="line">    ├── is_empty.c</div><div class="line">    ├── pop.c</div><div class="line">    ├── push.c</div><div class="line">    ├── stack.c</div><div class="line">    └── stack.h</div><div class="line"></div><div class="line">1 directory, 6 files</div></pre></td></tr></table></figure></p><p>我们把 stack.c、push.c、pop.c、is_empty.c 编译成目标文件:</p><blockquote><p>$ gcc -c stack/stack.c stack/push.c stack/pop.c stack/is_empty.c</p></blockquote><p>然后打包成一个静态库 「 libstack.a 」</p><blockquote><p>$ ar rs libstack.a stack.o push.o pop.o is_empty.o<br>ar: 正在创建 libstack.a</p></blockquote><p>库文件都是以 lib 开头的，静态库以 .a 作为后缀，表示 Archive。ar命令类似于 tar 命令，也是用来打包的，但是把目标文件打成静态库的格式只能用 ar 命令而不能用 tar 命令。<br><strong>r 选项表示将后面的目标文件列表添加到文件包 libstack.a 中，如果 libstack.a 不存在就创建它，如果 libstack.a 中已有同名的目标文件就替换成新的。</strong><br><strong>s 选项表示为静态库创建索引。这个索引被链接器使用</strong></p><p>然后我们把 libstack.a 和 main.c 编译链接在一起</p><blockquote><p>$ gcc main.c -L. -lstack -Istack -o main</p></blockquote><p>-L 选项告诉编译器去哪里找需要的库文件，「 -L. 」表示在当前目录找。<br>-lstack 选项告诉编译器要链接 libstack 库， -I 选项告诉编译器去哪里找头文件。</p><p>注意，即使库文件就在当前目录，编译器默认也不会去找的，所以 「 -L. 」选项是不能少的。编译器默认去哪里找呢？可以使用 -print-search-dirs 选项查看一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ gcc -print-search-dirs</div><div class="line">install: /usr/lib/gcc/x86_64-linux-gnu/6/</div><div class="line">programs: =/usr/lib/gcc/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc</div><div class="line">/x86_64-linux-gnu/6/../../../../x86_64-linux-gnu/bin/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../../x86_64-linux-gnu/bin/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gn</div><div class="line">u/6/../../../../x86_64-linux-gnu/bin/</div><div class="line">libraries: =/usr/lib/gcc/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../../x86_64-linux-gnu/lib/x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../../x86_64-lin</div><div class="line">ux-gnu/lib/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../../x86_64-linux-gnu/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../x86_64-linux-gnu/6/:/usr/lib/gcc/x86_64-l</div><div class="line">inux-gnu/6/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../../lib/:/lib/x86_64-linux-gnu/6/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/6/:/usr/li</div><div class="line">b/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../../x86_64-linux-gnu/lib/:/usr/lib/gcc/x86_64-linux-gnu/6/../../../:/lib/:/usr/lib/</div></pre></td></tr></table></figure><p>其中的 <strong>libraries</strong> 就是库文件的搜索路径列表，各路径之间用冒号隔开。在处理 -lstack 选项时， gcc 首先到 -L 选项指定的目录下查找，看有没有<strong>共享库</strong> libstack.so, 如果有就链接它，否则再找有没有<strong>静态库</strong> libstack.a 如果有链接它，如果还是没有，就到默认搜索路径下按同样的步骤查找。gcc 在链接时优先考虑共享库，其次才是静态库，如果希望 gcc 只考虑静态库，可以指定 -static 选项</p><h2 id="那么链接共享库和静态库有什么区别？"><a href="#那么链接共享库和静态库有什么区别？" class="headerlink" title="那么链接共享库和静态库有什么区别？"></a>那么链接共享库和静态库有什么区别？</h2><p>在之前我们说过，链接 libc 共享库时，链接器只是确认可执行 main 引用的某些符号在 libc 中有定义，并没有最终确定这些符号的地址，这些符号在可执行文件 main 中仍然是未定义符号，要在运行时做动态链接。而链接静态库时，链接器会把静态库中的目标文件取出来和可执行文件真正链接到一起。我们反汇编查看上一步生成的可执行文件 main</p><pre><code> 0000000000000660 &lt;main&gt;: 660:   55                      push   %rbp 661:   48 89 e5                mov    %rsp,%rbp 664:   bf 61 00 00 00          mov    $0x61,%edi 669:   e8 07 00 00 00          callq  675 &lt;push&gt; 66e:   b8 00 00 00 00          mov    $0x0,%eax 673:   5d                      pop    %rbp 674:   c3                      retq0000000000000675 &lt;push&gt;: 675:   55                      push   %rbp 676:   48 89 e5                mov    %rsp,%rbp 679:   89 f8                   mov    %edi,%eax 67b:   88 45 fc                mov    %al,-0x4(%rbp) 67e:   8b 05 8c 09 20 00       mov    0x20098c(%rip),%eax        # 201010 &lt;top&gt; 684:   83 c0 01                add    $0x1,%eax 687:   89 05 83 09 20 00       mov    %eax,0x200983(%rip)        # 201010 &lt;top&gt; 68d:   8b 05 7d 09 20 00       mov    0x20097d(%rip),%eax        # 201010 &lt;top&gt; 693:   48 63 d0                movslq %eax,%rdx 696:   48 8d 05 a3 09 20 00    lea    0x2009a3(%rip),%rax        # 201040 &lt;stack&gt; 69d:   0f b6 4d fc             movzbl -0x4(%rbp),%ecx 6a1:   88 0c 02                mov    %cl,(%rdx,%rax,1) 6a4:   90                      nop 6a5:   5d                      pop    %rbp 6a6:   c3                      retq 6a7:   66 0f 1f 84 00 00 00    nopw   0x0(%rax,%rax,1) 6ae:   00 0000000000000006b0 &lt;__libc_csu_init&gt;: 6b0:   41 57                   push   %r15 6b2:   41 56                   push   %r14 6b4:   41 89 ff                mov    %edi,%r15d ...</code></pre><p>有趣的是，main.c 只调用了 push 这个函数，所以链接生成的可执行文件中也只有 push 而没有 pop 和 is_empty。<strong>这是使用静态库的一个好处</strong>，链接器从静态库中只取出需要的目标文件来做链接，不需要的目标文件可不链接，如果直接把目标文件和 main.c 编译链接在一起，则没有用到的也会链接进来。另一个静态库的好处是只需要写一个库文件，而不需要写一长串目标文件名。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候需要把一组代码编译成一个库，这个库在很多项目都要用到，例如 libc 就是这样一个库，我们在不同的程序中都会用到 libc 中定义的库函数（例如 printf（3）和全局变量 （例如 environ（3））。接下来的两篇的重点介绍如何创建这样的库，同时通过这样的方式，
      
    
    </summary>
    
      <category term="2017-6" scheme="http://yoursite.com/categories/2017-6/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言剖析————头文件</title>
    <link href="http://yoursite.com/2017/06/08/C%E8%AF%AD%E8%A8%80%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/06/08/C语言剖析————头文件/</id>
    <published>2017-06-08T11:32:47.000Z</published>
    <updated>2017-06-08T11:33:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们这一篇继续讨论，前面关于 stack.c 和 main.c 的讨论。stack.c 这个模块封装了 top 和 stack 两个变量，导出了 push、pop、pop、is_empty 三个函数接口，已经设计的比较完善。但是使用这个模块的每一个 .c 文件都要写三个函数声明，如果要用的文件中方法再多一点的话 或者 要有多个文件使用这个的话，我们应该尽量避免重复代码的出现。在这里我们可以使用「 头文件 」来进行解决。</p><p>我们来自己写一个头文件 stack.h:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* stack.h */</div><div class="line">#ifndef STACK_H</div><div class="line">#define STACK_H</div><div class="line"></div><div class="line">extern void push(char);</div><div class="line">extern char pop(void);</div><div class="line">extern int is_empty(void);</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure></p><p>然后我们在 main.c 函数当中包含我们的 stack.h ，我们就可以不用写那三个声明了，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/* main.c */</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &quot;stack.h&quot;</div><div class="line"></div><div class="line">extern void push(char);</div><div class="line">extern char pop(void);</div><div class="line">extern int is_empty(void);</div><div class="line"></div><div class="line">int main(void)&#123;</div><div class="line">    push(&apos;a&apos;);</div><div class="line">    push(&apos;b&apos;);</div><div class="line">    push(&apos;c&apos;);</div><div class="line"></div><div class="line">    while(!is_empty())</div><div class="line">    putchar(pop());</div><div class="line">    putchar(&apos;\n&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>无形当中，我们又抛出了几个问题，不过下面我会一一进行解答。</p><p>首先说为什么 #include <stdio.h> 是用角括号，而 #include “stack.h” 用引号？</stdio.h></p><p>对于用角括号包含的头文件来说，gcc 首先查找 -I 选项指定的目录，然后查找系统的头文件目录，而对于 引号 包含的头文件，gcc 首先<strong>查找这个头文件的当前文件所在的目录</strong>，然后<strong>查找 -I 选项指定的目录，然后查找系统的头文件目录</strong></p><p>比如说，我们三个文件都放在同一个目录下面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> jianran@jianran:~/桌面/x86HB$ tree</div><div class="line">.</div><div class="line">├── main.c</div><div class="line">├── stack.c</div><div class="line">└── stack.h</div><div class="line">0 directories, 3 files</div></pre></td></tr></table></figure></p><p>则可以用 gcc -c main.c 编译，gcc 会自动在 main.c 所在的目录中找到 stack.h。加入我们把 stack.h 和 stack.h 移动到一个子目录下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">jianran@jianran:~/桌面/x86HB$ tree</div><div class="line">.</div><div class="line">├── main.c</div><div class="line">└── stack</div><div class="line">    ├── stack.c</div><div class="line">    └── stack.h</div><div class="line">1 directory, 3 files</div></pre></td></tr></table></figure></p><p>如果像这样一样，我们就必须给 -I 指定参数 gcc -c main.c -Istack, 让我们去告诉 gcc 头文件要到子目录 stack 中找。</p><p>在 #include 预处理指示中可以使用相对路径，比如 #include “stack/stack.h”，那么就不需要加 -Istack 选项了，同时我们应该注意的是，相对路径是相对与当前工作目录的路径，而不是当前文件所在路径</p><p>接着我们继续来回到 stack.h 中我们又看到两个新的预处理命令 #ifndef STACK_H 和 #endif，意思是说，如果 STACK_H  这个宏没有定义过，那么从 #ifndef 到 #endif 之间的代码就包含在预处理的输出结果中，否则这段代码就不会出现在预处理的结果当中。如果在包含这个头文件时 STACK_H 这个宏已经定义了，则相当于这个头文件里面什么都没有，只是包含了一个空文件。这个有什么用呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#include &quot;stack.h&quot;</div><div class="line">#include &quot;stack.h&quot;</div><div class="line"> </div><div class="line">int main(void)&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第一次包含 stack.h 时并没有定义 STACK_H 这个宏，因此头文件的内容包含在预处理的输出结果中，处理完的结果就像如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#define STACK_H</div><div class="line"></div><div class="line">extern void push(char);</div><div class="line">extern char pop(void);</div><div class="line">extern int is_empty(void);</div><div class="line">#include &quot;stack.h&quot;</div><div class="line"></div><div class="line"></div><div class="line">int main(void)&#123;</div><div class="line">    push(&apos;a&apos;);</div><div class="line">    push(&apos;b&apos;);</div><div class="line">    push(&apos;c&apos;);</div><div class="line"></div><div class="line">    while(!is_empty())</div><div class="line">    putchar(pop());</div><div class="line">    putchar(&apos;\n&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当我们继续处理 第二个 #include “stack.h” 的时候，因为我们已经定义过了 STACK_H, stack.h 在这一次就被看成了一个空文件。这种保护头文件的写法称为 Header Guard 以后我们写的每个头文件都要加上 Header Guard</p><hr><p>接下来我们总结一下包含头文件主要有的问题：</p><ol><li>预处理编译的速度变慢，要处理很多本来不需要处理的代码。</li><li>如果不小心出现 foo.h 包含 bar.h 、 bar.h 又包含 foo.h 的情况，就陷入死循环。一般编译器都会规定一个包含层次的上限，超过这个上限就会报错</li><li>头文件里面有些代码是不允许被重复出现的，虽然变量和函数允许被多次声明，但是头文件中一些代码是不允许多次出现的，比如用 teypef 定义一个类型名，在一个编译单元只允许定义一次。</li></ol><p>还有一个问题，既然要 #include 头文件，那我不如直接在 main.c 中 #include “stack.h” 得了。这样 stack.c 和 main.c 合并成一个编译单元了，就算我们用 gcc main.c -o main 命令也是可以编译通过了，这样岂不是更加简单吗？</p><p>假如又有一个 foo.c（main.c 要用到 foo.c) 也要用 stack.c 这个模块怎么办？如果再让 foo.c 也 #include “stack.c” 就相当与 push、pop、is_empty 这三个函数 在 main.c 和 foo.c 都有了定义，那么mian.c 和 foo.c 在一起 就不能编译通过, 如果采用头文件的方法，只需要定义一次就全部搞定了。</p><hr><p>写 .c 文件和 头文件时应该遵循以下原则:</p><ul><li><p>.c 文件中可以有变量或函数定义，而 .h 文件中应该只有函数或变量声明而没有定义</p></li><li><p>不要把一个 .c 文件包含到另外一个 .c 文件中</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们这一篇继续讨论，前面关于 stack.c 和 main.c 的讨论。stack.c 这个模块封装了 top 和 stack 两个变量，导出了 push、pop、pop、is_empty 三个函数接口，已经设计的比较完善。但是使用这个模块的每一个 .c 文件都要写三个函数
      
    
    </summary>
    
      <category term="2017-6" scheme="http://yoursite.com/categories/2017-6/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言剖析————标识符的链接属性</title>
    <link href="http://yoursite.com/2017/06/08/C%E8%AF%AD%E8%A8%80%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2017/06/08/C语言剖析————标识符的链接属性/</id>
    <published>2017-06-08T09:35:13.000Z</published>
    <updated>2017-06-08T09:35:49.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>外部链接（External Linkage），一个标识符在不同的编译单元中可能被声明多次，当这些编译单元链接到可执行时，如果这些声明都代表同一个变量或函数（即代表同一个内存地址），则这个标识符具有 External Linkage。具有 External Linkage 的标识符编译后在目标文件中是全局符号。</p></li><li><p>内部链接（Internal Linkage），一个标识符在某个编译单元中可能被声明多次，这些声明都代表同一个内存地址，但如果这个标识符在不同的编译单元中被声明多次，在链接时这些声明就不代表同一个内存地址，这样的标示具有 Internal Linkage。也就是说在链接时不做符号解析</p></li><li><p>无链接属性（No Linkage）。除以上情况之外的标识符都属于 No Linkage， 例如函数的局部变量，以及不表示变量和函数的其他标示符。除了函数、全局变量、静态变量之外的标识符在编译时不会变成符号，所以没有链接属性</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;外部链接（External Linkage），一个标识符在不同的编译单元中可能被声明多次，当这些编译单元链接到可执行时，如果这些声明都代表同一个变量或函数（即代表同一个内存地址），则这个标识符具有 External Linkage。具有 External 
      
    
    </summary>
    
      <category term="2017-6" scheme="http://yoursite.com/categories/2017-6/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
