<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JianRan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-21T04:03:41.989Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JianRan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浮点数</title>
    <link href="http://yoursite.com/2018/02/21/float/"/>
    <id>http://yoursite.com/2018/02/21/float/</id>
    <published>2018-02-21T04:02:21.000Z</published>
    <updated>2018-02-21T04:03:41.989Z</updated>
    
    <content type="html"><![CDATA[<p>浮点数总是给我一种朦朦胧胧的感觉，知道它描述的数字有偏差，知道它在C语言中不能和整数型直接转换，却始终不敢拍着胸膛说“我懂了”。float的种种疑惑和仅停留在可以表达小数的认识上。</p><hr><p>我们需要先了解一下计算机的浮点数表示法。在 C 语言中计算机的浮点数用的是 IEEE 754 标准</p><p>IEEE 754标准中规定float单精度浮点数在机器中表示用 </p><ul><li>用 1 位表示数字的符号 S (Sign)</li><li>用 8 位来表示指数 E (Exponent)</li><li>用23 位来表示尾数 M (Mantissa)</li></ul><p>对于double双精度浮点数</p><ul><li>用 1 位表示符号 S (Sign)</li><li>用 11 位表示指数 E (Exponent)</li><li>用 52 位表示尾数 M (Mantissa)</li></ul><p>IEEE 浮点值的格式如下图所示:<br><img src="http://p3o1bechg.bkt.clouddn.com/FhyIhmiWMhg9CXzHfIvwVzmKEzXI" alt="IEEE 754"></p><p>这里我们以32位为例，来展示计算公式<br>$$(-1)^S <em> (1 + \frac{M}{2^{\textrm{23}}}) </em> 2^{\textrm{(E - 127)}}$$</p><p>让我们更进步的解释一下浮点数的三段各部分的意思</p><ul><li><p>第一段是符号位。</p></li><li><p>第二段是指数位，对于任何数ｘ，其都可以找到一个ｎ，使得$2^n&lt;=x&lt;=2^{n+1} $，比如，拿３来说，因为$2^1&lt;3&lt;2^2$,所以 $n=1$，同时，为了表示 0.00x 这样的数，所以需要有负数。8个比特位，总共能表示 255 个数字，为了表示负数,也就是在[-127,128]这个区间中，才有$2^{\textrm{(E - 127)}}$</p></li><li>第三段叫做偏移量会更准确一些，如果没有所谓的偏移量，我们展示的将是一个$2^{\textrm{(E - 127)}}$,精简一点也就是$2^x$，不如说这个数字就是一个基值，我们将会在这个基值上面再进行偏移，偏移的总量同样是$2^x$。偏移量为23位，就是说把这段数字分为了$2^{23}$份，展开公式会更好的展示出来</li></ul><p>$$(-1)^S<em>(1 </em> 2^{E - 127} + \frac{M}{2^{23}} * 2^{E - 127})$$</p><p>正因为我们是在$2^x$的基础上偏移$\frac{M}{2^{23}}$,难免会有些数字无法完全吻合，只能依靠近似数来模拟。偏差由此而来。</p><p>为了更好的理解我们来拿3.14来看看</p><ol><li>3.14是正数，S的值为1</li><li>$2^1 &lt; 3.14 &lt; 2^2$ 所以$E - 127 = 1$,E 等于128</li><li>$(3.14 - 2^1)/2^1 = 0.57$, $\frac{M}{2^{23}} = 0.57$ ，求出来的M不是一个整数，到这里就出现了精度问题</li></ol><p>这里可以看出，计算浮点数的计算量还是很大的，如果没有硬件的直接支持对于计算机的消耗可想而知。同样依照这样的一条思路，也可以事先算好这么一个对应规格的浮点数，去和其他数字进行运算。曾经的<strong>魔数</strong>就是一个典型的例子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;浮点数总是给我一种朦朦胧胧的感觉，知道它描述的数字有偏差，知道它在C语言中不能和整数型直接转换，却始终不敢拍着胸膛说“我懂了”。float的种种疑惑和仅停留在可以表达小数的认识上。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们需要先了解一下计算机的浮点数表示法。在 C 语言中计算机的浮点数
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="程序" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>log014</title>
    <link href="http://yoursite.com/2018/02/21/log014/"/>
    <id>http://yoursite.com/2018/02/21/log014/</id>
    <published>2018-02-20T16:08:09.000Z</published>
    <updated>2018-02-21T02:08:42.460Z</updated>
    
    <content type="html"><![CDATA[<p>假期余量尽管不多，收货还是不错的</p><p>以15分钟为英语学习单位的方式，感觉不错</p><p>不带今天，还有十天假期</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假期余量尽管不多，收货还是不错的&lt;/p&gt;
&lt;p&gt;以15分钟为英语学习单位的方式，感觉不错&lt;/p&gt;
&lt;p&gt;不带今天，还有十天假期&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>log013</title>
    <link href="http://yoursite.com/2018/02/20/log013/"/>
    <id>http://yoursite.com/2018/02/20/log013/</id>
    <published>2018-02-20T02:17:43.000Z</published>
    <updated>2018-02-20T02:18:22.689Z</updated>
    
    <content type="html"><![CDATA[<p>这几天大部分时间都花在陪家人身上，对于一些项目时间难免有些不够，但依然会做，</p><p>log 已经中断了几天，还包括英语。</p><p>只能说自己的时间安排不恰当，有很大的调整空间</p><p>计划到开学之前，基本学完20小时的go语言</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天大部分时间都花在陪家人身上，对于一些项目时间难免有些不够，但依然会做，&lt;/p&gt;
&lt;p&gt;log 已经中断了几天，还包括英语。&lt;/p&gt;
&lt;p&gt;只能说自己的时间安排不恰当，有很大的调整空间&lt;/p&gt;
&lt;p&gt;计划到开学之前，基本学完20小时的go语言&lt;/p&gt;

      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>SharedPreferences</title>
    <link href="http://yoursite.com/2018/02/17/SharedPreferences/"/>
    <id>http://yoursite.com/2018/02/17/SharedPreferences/</id>
    <published>2018-02-17T02:47:31.000Z</published>
    <updated>2018-02-17T02:50:01.376Z</updated>
    
    <content type="html"><![CDATA[<p>如果想保存相对较小键值对集合，应该使用SharedPerference</p><h2 id="获取共享首选项句柄"><a href="#获取共享首选项句柄" class="headerlink" title="获取共享首选项句柄"></a><strong>获取共享首选项句柄</strong></h2><ul><li><p>getSharedPerferences() –如果需要指定文件名称，应该使用这个方法,第一个参数指定文件名称，第二个阐述文件权限。MODE_PRIVATE(Defalut)，仅能被创建者访问。还有MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Context context = getActivity(); </div><div class="line">SharedPreferences sharedPreference =    context.getSharedPreferences(</div><div class="line">       getString(R.string.preference_file_key), Context.MODE_PRIVATE);</div></pre></td></tr></table></figure></li><li><p>getPreferences() – 如果您只需使用 Activity 的一个共享首选项，请从 Activity 中使用此方法。 因为此方法会检索属于该 Activity 的默认共享首选项文件，您无需提供名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);</div></pre></td></tr></table></figure></li></ul><h2 id="写入共享首选项"><a href="#写入共享首选项" class="headerlink" title="写入共享首选项"></a><strong>写入共享首选项</strong></h2><p>通过SharedPreferences引用调用edit() 来创建一个 SharedPreferences.Editor。使用putXXX() 来写入键和值，然后，调用 commit() 以保存所做的更改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);</div><div class="line">SharedPreferences.Editor editor = sharedPref.edit();</div><div class="line">editor.putInt(getString(R.string.saved_high_score), newHighScore);</div><div class="line">editor.commit();</div></pre></td></tr></table></figure></p><h2 id="读取信息"><a href="#读取信息" class="headerlink" title="读取信息"></a><strong>读取信息</strong></h2><p>通过SharedPreferences引用的getXXX() 方法，去获取你想要减的值，并且根据需要提空，在键不存在的情况下返回默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);</div><div class="line">int defaultValue = getResources().getInteger(R.string.saved_high_score_default);</div><div class="line">long highScore = sharedPref.getInt(getString(R.string.saved_high_score), defaultValue);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果想保存相对较小键值对集合，应该使用SharedPerference&lt;/p&gt;
&lt;h2 id=&quot;获取共享首选项句柄&quot;&gt;&lt;a href=&quot;#获取共享首选项句柄&quot; class=&quot;headerlink&quot; title=&quot;获取共享首选项句柄&quot;&gt;&lt;/a&gt;&lt;strong&gt;获取共享首选项句
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>log012</title>
    <link href="http://yoursite.com/2018/02/15/log012/"/>
    <id>http://yoursite.com/2018/02/15/log012/</id>
    <published>2018-02-14T16:05:15.000Z</published>
    <updated>2018-02-14T16:11:30.674Z</updated>
    
    <content type="html"><![CDATA[<p>对于英语的学习，将会专注于英语流利说</p><p>意识到自己欠缺一些金融知识</p><p>从自己很久不看的一个专栏中又学会一些东西</p><p>技术应该继续下去，但是重要性在持续走低</p><p>重新定义技术的意义：技术将会成为我的谋生工具</p><p>但真正要成为精英还需很多其他的东西</p><p>非常需要再次重新去规划自己</p><p>此刻应该立刻睡觉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于英语的学习，将会专注于英语流利说&lt;/p&gt;
&lt;p&gt;意识到自己欠缺一些金融知识&lt;/p&gt;
&lt;p&gt;从自己很久不看的一个专栏中又学会一些东西&lt;/p&gt;
&lt;p&gt;技术应该继续下去，但是重要性在持续走低&lt;/p&gt;
&lt;p&gt;重新定义技术的意义：技术将会成为我的谋生工具&lt;/p&gt;
&lt;p&gt;但真正要成
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log011</title>
    <link href="http://yoursite.com/2018/02/13/log011/"/>
    <id>http://yoursite.com/2018/02/13/log011/</id>
    <published>2018-02-13T00:43:34.000Z</published>
    <updated>2018-02-13T00:44:06.430Z</updated>
    
    <content type="html"><![CDATA[<p>重新确定英语的学习方式，应该渗透到每天的生活中。学习计划将要重新安排，一切以两个小时为单位， 每过两小时就学半个小时英语。其实就是以2.5小时为一个单位。</p><p>确定未来一定会考人类的最高学历</p><p>10点过后，不再学习<strong>英语流利说</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重新确定英语的学习方式，应该渗透到每天的生活中。学习计划将要重新安排，一切以两个小时为单位， 每过两小时就学半个小时英语。其实就是以2.5小时为一个单位。&lt;/p&gt;
&lt;p&gt;确定未来一定会考人类的最高学历&lt;/p&gt;
&lt;p&gt;10点过后，不再学习&lt;strong&gt;英语流利说&lt;/stro
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>小程序结构</title>
    <link href="http://yoursite.com/2018/02/12/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/02/12/小程序结构/</id>
    <published>2018-02-12T09:02:42.000Z</published>
    <updated>2018-02-12T09:21:37.971Z</updated>
    
    <content type="html"><![CDATA[<p>在创建了一个小程序项目之后，可能在这个项目里会看见不同类型的文件。这些文件分别是</p><ol><li><p>.json 后缀的 JSON 配置文件</p></li><li><p>.wxml 后缀的 WXML 模板文件</p></li><li><p>.wxss 后缀的 WXSS 样式文件</p></li><li><p>.js 后缀的 JS 脚本逻辑文件</p></li></ol><p>初看结构十分类似 HTML + CSS + JS 三剑客，进一步了解后他们的作用也大抵相同。在小程序总体结构上，分成两部分。一部分是全局文件，都是以<code>app</code>开头，承载整个小程序的全局信息,例如 <code>app.json</code>, <code>app.wxss</code>, <code>app.js</code>。另一部分是局部文件，具体到每个一个页面都拥有自己的一套配置信息，局部文件的优先级会大于全局文件。例如 <code>index.wxml</code>, <code>index.wxss</code>, <code>index.js</code>, <code>index.json</code></p><p>下面我们以这样一个目录结构来依次介绍</p><p><img src="http://p3o1bechg.bkt.clouddn.com/Fj5LUc4w_wTHXa7QCyMSGwcbivc1" alt="tree"></p><p>先忽略掉 typinggs 目录。</p><h2 id="JSON配置"><a href="#JSON配置" class="headerlink" title="JSON配置"></a><strong>JSON配置</strong></h2><p>从项目根目录，我们依次看到 app.json, project.config.json 和 index.json。我们依次来说明用途。</p><p><strong>app.json</strong> 是对当前小程序的全局配置，包括了<strong>小程序的所有页面路径</strong>，<strong>界面表现</strong>， <strong>网络超时时间</strong>， <strong>底部tab</strong> 等信息。结构如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  "pages":[</div><div class="line">    ...</div><div class="line">  ],</div><div class="line">  "window":&#123;</div><div class="line">    ...</div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>project.config.json</strong> 是对于微信开发者工具一些个性化配置。当你换了一台电脑或者重新安装工具时，你只要载入同一个项目的代码。开发者工具就会根据这些配置进行恢复。</p><p><strong>index.json</strong> 去设置一个页面的配置，当 app.json 配置了属性，而 index.json 没有配置就默认使用 app.json 的。当两者都配置了，则使用 index.json 的 </p><h2 id="WXML-WXSS-JS"><a href="#WXML-WXSS-JS" class="headerlink" title="WXML WXSS JS"></a><strong>WXML WXSS JS</strong></h2><p>它其实类似 HTML + CSS + JS 这个，只不过他们都有一些细微的差距。</p><p>WXML 于 HTML 的差别，我们直接用微信文档中的一段话。</p><ol><li><p>标签名字有点不一样 往往写 HTML 的时候，经常会用到的标签是 div, p, span，开发者在写一个页面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。换个思路，既然大家都需要这些组件，为什么我们不能把这些常用的组件包装起来，大大提高我们的开发效率。 从上边的例子可以看到，小程序的 WXML 用的标签是 view, button, text 等等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频等等组件能力 更多详细的组件讲述参考下个章节 小程序的能力</p></li><li><p>多了一些 wx:if 这样的属性以及 { { } } 这样的表达式 在网页的一般开发流程中，我们通常会通过 JS 操作 DOM (对应 HTML 的描述产生的树)，以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，JS 会记录一些状态到 JS 变量里边，同时通过 DOM API 操控 DOM 的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了 MVVM 的开发模式(例如 React, Vue)，提倡把渲染和逻辑分离。简单来说就是不要再让 JS 直接操控 DOM，JS只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。 小程序的框架也是用到了这个思路，如果你需要把一个 Hello World 的字符串显示在界面上。 WXML 是这么写 :</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;text&gt;&lt;/text&gt;</div></pre></td></tr></table></figure><p>JS 只需要管理状态即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.setData(&#123; msg: &quot;Hello World&quot; &#125;)</div></pre></td></tr></table></figure></p><p>通过 { { } } 的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 if/else, for等控制能力，在小程序里边，这些控制能力都用 wx: 开头的属性来表达。 更详细的文档可以参考 WXML</p><p>WXSS 具有CSS大部分特性，除此也做了一些扩充和修改。增加了尺寸单位 rpx，提供了全局样式和局部样式，此外仅支持 css 部分选择器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在创建了一个小程序项目之后，可能在这个项目里会看见不同类型的文件。这些文件分别是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;.json 后缀的 JSON 配置文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;.wxml 后缀的 WXML 模板文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;.wxss 
      
    
    </summary>
    
      <category term="2018-02" scheme="http://yoursite.com/categories/2018-02/"/>
    
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>log010</title>
    <link href="http://yoursite.com/2018/02/12/log010/"/>
    <id>http://yoursite.com/2018/02/12/log010/</id>
    <published>2018-02-11T16:50:39.000Z</published>
    <updated>2018-02-12T09:00:14.846Z</updated>
    
    <content type="html"><![CDATA[<p>找不到顺手的图床插件，干脆自动动手写了一个。尽管用的他们的sdk，但好歹是自己给自己写的第一个东西,值得纪念。</p><p>帮同学解决了技术上面的小问题，还是挺开心的。</p><p>对于英语的执行力依然很差，需要提高！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;找不到顺手的图床插件，干脆自动动手写了一个。尽管用的他们的sdk，但好歹是自己给自己写的第一个东西,值得纪念。&lt;/p&gt;
&lt;p&gt;帮同学解决了技术上面的小问题，还是挺开心的。&lt;/p&gt;
&lt;p&gt;对于英语的执行力依然很差，需要提高！&lt;/p&gt;

      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log009</title>
    <link href="http://yoursite.com/2018/02/11/log009/"/>
    <id>http://yoursite.com/2018/02/11/log009/</id>
    <published>2018-02-10T16:59:26.000Z</published>
    <updated>2018-02-11T07:00:07.739Z</updated>
    
    <content type="html"><![CDATA[<p>对于自己的未来规划，有了一个方向。重新定义了，我目前处于的阶段，大学沉淀期。</p><p>总体计划按目标完成。</p><p>作息再次修改成，24点准时睡觉，7点起床.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于自己的未来规划，有了一个方向。重新定义了，我目前处于的阶段，大学沉淀期。&lt;/p&gt;
&lt;p&gt;总体计划按目标完成。&lt;/p&gt;
&lt;p&gt;作息再次修改成，24点准时睡觉，7点起床.&lt;/p&gt;

      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log008</title>
    <link href="http://yoursite.com/2018/02/10/log008/"/>
    <id>http://yoursite.com/2018/02/10/log008/</id>
    <published>2018-02-09T16:32:02.000Z</published>
    <updated>2018-02-10T02:32:44.284Z</updated>
    
    <content type="html"><![CDATA[<p>重心持续的转移，并不意味比之前懒散。但要去做什么最近一直在思考。希望短时间内可以想出。</p><p>每次的任务不要给自己太过于紧张。</p><p>英语应该保持警惕。一不注意它，就有点松动的迹象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重心持续的转移，并不意味比之前懒散。但要去做什么最近一直在思考。希望短时间内可以想出。&lt;/p&gt;
&lt;p&gt;每次的任务不要给自己太过于紧张。&lt;/p&gt;
&lt;p&gt;英语应该保持警惕。一不注意它，就有点松动的迹象。&lt;/p&gt;

      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log007</title>
    <link href="http://yoursite.com/2018/02/09/log007/"/>
    <id>http://yoursite.com/2018/02/09/log007/</id>
    <published>2018-02-08T17:50:08.000Z</published>
    <updated>2018-02-09T00:58:46.007Z</updated>
    
    <content type="html"><![CDATA[<p>技术方面并没有提升多少，但自己意识到了通识教育的重要性。随着自身的发展，技术已经不再成为短板。</p><p>现阶段的主要目标还是技术。不过看一些小说的时间，可以变成另外一些特定的书籍。</p><p>再次下定义，纯粹的知识没有任何意义，纯粹的思想同样也是。需要更多的文化点缀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;技术方面并没有提升多少，但自己意识到了通识教育的重要性。随着自身的发展，技术已经不再成为短板。&lt;/p&gt;
&lt;p&gt;现阶段的主要目标还是技术。不过看一些小说的时间，可以变成另外一些特定的书籍。&lt;/p&gt;
&lt;p&gt;再次下定义，纯粹的知识没有任何意义，纯粹的思想同样也是。需要更多的文化点
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>mergesSortAdvance</title>
    <link href="http://yoursite.com/2018/02/08/mergesSortAdvance/"/>
    <id>http://yoursite.com/2018/02/08/mergesSortAdvance/</id>
    <published>2018-02-08T03:12:18.000Z</published>
    <updated>2018-02-08T03:13:26.164Z</updated>
    
    <content type="html"><![CDATA[<p>对于<a href="https://jinfangzhang.github.io/2018/02/07/mergeSort/" target="_blank" rel="external">之前的归并排序</a>的文章，刻意的留了一部分，单独拿出来说下。这部分还是很有趣和重要的一块。不记得算法的同志得自己去回顾一下。</p><h2 id="第一个优化"><a href="#第一个优化" class="headerlink" title="第一个优化"></a><strong>第一个优化</strong></h2><p>在几乎所有采用分而治之思想的算法中，当问题规模被分解到某种程度时，可以采用插入排序，将这些近乎有序的数组进行排序。</p><p>我们对应优化的点在于不在让问题规模分解成1为止，而是当问题规模减小到<strong>X</strong>(某个未知数）的时候，采用插入排序。为此我们重载了一个insertionSort，如下。这里不妨分析下这个重载后的算法定义是什么</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++)&#123;</div><div class="line">        T e = arr[i];</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>; j&gt;=l; j--)&#123;</div><div class="line">            <span class="keyword">if</span>(e &lt; arr[j])</div><div class="line">                arr[j+<span class="number">1</span>] = arr[j];</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        arr[j+<span class="number">1</span>] = e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>归并排序的优化。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> __mergeSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</div><div class="line">    <span class="keyword">if</span>(r-l &lt;= <span class="number">15</span>)&#123;</div><div class="line">        insertionSort(arr,l,r);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    </div><div class="line">    <span class="keyword">int</span> mi = (l+r)/<span class="number">2</span>;</div><div class="line">    __mergeSort(arr, l, mi);</div><div class="line">    __mergeSort(arr, mi + <span class="number">1</span>, r);</div><div class="line"></div><div class="line">    __merge(arr, l, mi, r);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果<br><img src="http://p3o1bechg.bkt.clouddn.com/mergeSort_advance&amp;&amp;mergeSort.png" alt="比较结果"></p><h2 id="第二个优化"><a href="#第二个优化" class="headerlink" title="第二个优化"></a>第二个优化</h2><p>除了要测试无序数组外，还要测试几乎有序的数组。其实不需要测试就已经很明白，对于几乎有序的数组插入排序是$O(n)$的时间复杂度，而即便是优化过的归并排序，也不过是$O(nlog^n)$。</p><p>我在这里的修改很简单。</p><p>就是对于$merge$算法而言，如果第二部分的第一个元素大于或等于第一部分的第最后一个元素，就说明这个数组是有序的，直接返回即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">void __mergeSort(T arr[], int l, int r)&#123;</div><div class="line">    if(r-l &lt;= 15)&#123;</div><div class="line">        insertionSort(arr,l,r);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    </div><div class="line">    int mi = (l+r)/2;</div><div class="line">    __mergeSort(arr, l, mi);</div><div class="line">    __mergeSort(arr, mi + 1, r);</div><div class="line"></div><div class="line">    //加了一个if判断</div><div class="line">    if(arr[mi] &gt; arr[mi + 1])</div><div class="line">        __merge(arr, l, mi, r);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>尽管最终依然无法优于在几乎有序数组中的插入排序，但是已经是在同一个数量级上面了。<br><img src="http://p3o1bechg.bkt.clouddn.com/mergeSort%E4%BC%98%E5%8C%96%E4%BA%8C.png" alt="比较结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于&lt;a href=&quot;https://jinfangzhang.github.io/2018/02/07/mergeSort/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;之前的归并排序&lt;/a&gt;的文章，刻意的留了一部分，单独拿出来说下。这部分还是很有趣和
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>log006</title>
    <link href="http://yoursite.com/2018/02/08/log006/"/>
    <id>http://yoursite.com/2018/02/08/log006/</id>
    <published>2018-02-07T17:23:49.000Z</published>
    <updated>2018-02-07T17:27:34.399Z</updated>
    
    <content type="html"><![CDATA[<p>总的来说，今天的效率好了很多。几乎在战斗的时候，都属于认真状态。但是错过了本可以完成所有今天任务的机会。</p><p>对于娱乐，应该先把主要任务完成。</p><p>休息的话，现在改成以15分钟为一个单位进行休息。</p><p>自己的身体终究还是适应了晚睡，所以作息，往后顺延一个小时，说不出呢还是7点起床呢～。哈哈哈</p><p>新的一天加油。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总的来说，今天的效率好了很多。几乎在战斗的时候，都属于认真状态。但是错过了本可以完成所有今天任务的机会。&lt;/p&gt;
&lt;p&gt;对于娱乐，应该先把主要任务完成。&lt;/p&gt;
&lt;p&gt;休息的话，现在改成以15分钟为一个单位进行休息。&lt;/p&gt;
&lt;p&gt;自己的身体终究还是适应了晚睡，所以作息，往
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>mergeSort</title>
    <link href="http://yoursite.com/2018/02/07/mergeSort/"/>
    <id>http://yoursite.com/2018/02/07/mergeSort/</id>
    <published>2018-02-07T04:01:32.000Z</published>
    <updated>2018-02-08T01:47:11.518Z</updated>
    
    <content type="html"><![CDATA[<p>2018.2.7 初稿<br>2018.2.8 修改</p><hr><p>归并排序算是比较高级的排序，采用分而治之的算法思想，相较插入排序和选择排序这类采用减而治之思想的算法。分而治之的思想可以更快使问题规模下降，进而求解。当问题规模开始下降，那么也意味着该问题的有序性正在变得越来越强。在对于几乎有序的数组，插入排序拥有 $O(n)$ 级别的算法复杂度。 换言之，当问题规模下降到某一程度时，我们可以采用插入排序作为分而治之算法的子过程。</p><p>分治算法的基本思想是将一个规模为$N$的问题分解为$K$个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。</p><p>分治算法的一般步骤：</p><ol><li><p>分解，将要解决的问题划分成若干规模较小的同类问题</p></li><li><p>求解，当子问题划分足够小时，用较简单的方法解决</p></li><li><p>合并，按原问题的要求，将子问题的解逐层合并构成原问题的解</p></li></ol><p>归并排序是分之思想的一个典型体现，主要思想是：把问题分解成对两部分已经排好序的序列进行排序。</p><p>这里我们采用递归的方式逐步实现该算法。</p><p>还记得我们创建的工具中的排序模板吗？$void(*sort)(T[\ ],\ int)$,因为要将问题划分成两部分，为此我们有必要规定一个明确的范围，就像下面这个样子一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    __mergeSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>$mergeSort$要对一个规模为 n 的 数组arr 进行排序，实质上是通过$\_\_mergeSort$ 在<strong>[ 0, n - 1 ]</strong> 范围内对 arr 进行排序，当然，也可以理解成在<strong>[ 0, n ）</strong> 这个范围内。但我们应该去保证这个定义的正确性与不变性，从这点出发，很多问题将被简化。</p><p>终止条件是递归算法整体退出的唯一出口，即便是终止条件，也应该去维护 $\_\_mergeSort$ 要返回一个指定区间的有序数组的基本条件。同时基于<em>当数组只含一个元素是有序的</em> 的认识。对于终止条件就可以是<strong>当区间只含有一个元素时，应该终止算法</strong>。</p><p>那么我的算法就是下面<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> __mergeSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</div><div class="line">    <span class="keyword">if</span>(l &gt;= r)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> mi = (l+r)/<span class="number">2</span>;</div><div class="line">    __mergeSort(arr, l, mi);</div><div class="line">    __mergeSort(arr, mi + <span class="number">1</span>, r);</div><div class="line"></div><div class="line">    __merge(arr, l, mi, r);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这个方法中，我们将 <strong>[l, r]</strong> 划分成两个范围 <strong>[l, (l+r)/2]</strong> 和 <strong>[l, (l+r)/2 + 1]</strong> 并对他们排序，之后再将这两部分进行合并得出结果。同时当数组只含有一个元素时，直接返回，不需要任何处理，因为当数组只含一个元素，他怎么都是有序的。</p><p>所以$\_\_merge$ 只需要将这两个有序区间合并即可,在阅读下面算法的时候，要时刻注意定义的保持性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">void __merge(T arr[],int l, int mi, int r)&#123;</div><div class="line">    </div><div class="line">    //1</div><div class="line">    T aux[r-l + 1]; </div><div class="line">    for(int i = l; i &lt;= r;i++)&#123;</div><div class="line">        aux[i - l] = arr[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //2</div><div class="line">    int j = mi - l + 1;</div><div class="line">    int i = l -l;</div><div class="line">    </div><div class="line">    //3</div><div class="line">    for(int k = l; k &lt;= r;k++)&#123;</div><div class="line">        if(i+l &gt; mi )&#123;</div><div class="line">            arr[k] = aux[j];</div><div class="line">            j++;</div><div class="line">        &#125;else if(j+l &gt; r)&#123;</div><div class="line">            arr[k] = aux[i];</div><div class="line">            i++;</div><div class="line">        &#125;else if(aux[i] &lt; aux[j])&#123;</div><div class="line">            arr[k] = aux[i];</div><div class="line">            i++;</div><div class="line">        &#125;else&#123;</div><div class="line">            arr[k] = aux[j];</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 $1$ 这个标记处，我们对arr 满足<strong>[l, r]</strong>这个区间的数进行复制，在这部分数当中，里面包含了两部分<strong>[l, mi]</strong> 和 <strong>[mi+1, r]</strong>。紧接着，我们在 $2$ 这个标记处，将 j 指向 <strong>aux</strong> 第二部分的首元素，将 i 指向 <strong>aux</strong> 第一部分的首元素。之后，我们通过<strong>K</strong> 依次遍历，最终得到有序数组。</p><p>最后用实际的例子来感受一下$O(log^n)$和$O(n^2)$算法的差距。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">    int n = 100000;</div><div class="line">    </div><div class="line">    cout&lt;&lt;&quot;Test for random array, size = &quot;&lt;&lt;n&lt;&lt;&quot;, random range [0, &quot;&lt;&lt;n&lt;&lt;&quot;]&quot;&lt;&lt;endl;</div><div class="line">    int* arr1 = SortTestHelper::generateRandomArray(n,0,n);</div><div class="line">    int* arr2 = SortTestHelper::copyIntArray(arr1, n);</div><div class="line"></div><div class="line">    SortTestHelper::testSort(&quot;Insertion Sort&quot;, insertionSort, arr1, n);</div><div class="line">    SortTestHelper::testSort(&quot;Merge Sort&quot;,     mergeSort,arr2, n);</div><div class="line"></div><div class="line">    cout&lt;&lt;endl;</div><div class="line">    delete[] arr1;</div><div class="line">    delete[] arr2;</div><div class="line"></div><div class="line">    cout&lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://p3o1bechg.bkt.clouddn.com/mergeSort%E5%92%8CInsertionSort.png" alt="MergeSort和InsertionSort的比较"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018.2.7 初稿&lt;br&gt;2018.2.8 修改&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;归并排序算是比较高级的排序，采用分而治之的算法思想，相较插入排序和选择排序这类采用减而治之思想的算法。分而治之的思想可以更快使问题规模下降，进而求解。当问题规模开始下降，那么也意味着该问题的有序性
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>log005</title>
    <link href="http://yoursite.com/2018/02/06/log005/"/>
    <id>http://yoursite.com/2018/02/06/log005/</id>
    <published>2018-02-06T15:56:48.000Z</published>
    <updated>2018-02-06T15:57:36.336Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚的关于优化ss的问题，让我熬到凌晨3点，严重影响了今天的计划。坏事情总是接连发生，我在本该做这个事情的时间段，做了其他。对于一个难题的解决，对问题的坚持固然重要，但这并不是延误其他事情的一个好理由。</p><p>每天的任务是定量的，所有的行为，应该把每天的任务放在首位。在明知，无法全部完成时，应该尽可能多的完成。</p><p>我想要的不仅仅是进步，而是高效的进步。你应该集中注意力的去做每一件事情。</p><p>我无法做到十全十美，但是应该将自己可以做到完成。</p><p>我要竭尽全力，而不是尽力。不要让自己变成自己所拒绝的人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨晚的关于优化ss的问题，让我熬到凌晨3点，严重影响了今天的计划。坏事情总是接连发生，我在本该做这个事情的时间段，做了其他。对于一个难题的解决，对问题的坚持固然重要，但这并不是延误其他事情的一个好理由。&lt;/p&gt;
&lt;p&gt;每天的任务是定量的，所有的行为，应该把每天的任务放在首位
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log004</title>
    <link href="http://yoursite.com/2018/02/06/log004/"/>
    <id>http://yoursite.com/2018/02/06/log004/</id>
    <published>2018-02-05T16:48:37.000Z</published>
    <updated>2018-02-05T16:49:20.082Z</updated>
    
    <content type="html"><![CDATA[<p>别的我倒不认为有什么优势，但唯独可以坚持下来。</p><p>和最近任务有关系，没有很明确的一个目标，现在每天过得可以说自我感觉十分糟糕，虽然每天都有在提</p><p>高，但我想要更高的效率。</p><p>也谈不上匆忙，总而言之，这件事情必须睡觉之前做完。</p><hr><p>明天任务：</p><ul><li>英语学习两小时，完成英语流利说的任务，其余时间看英文视频</li><li>完成归并和快速排序的算法，并且写一篇文章</li><li>看完Android网络框架，记录并且解决部分问题</li><li>学习一种新的设计模式</li></ul><hr><p>起床： 7:00</p><p>算法的战斗： 8:00 – 12:00</p><p>Android的战斗： 14:00 – 17:00</p><p>英语的战斗：    17:00 – 18:00</p><p>设计模式的战斗：20:00 – 22:00 </p><p>其余时间自由安排。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;别的我倒不认为有什么优势，但唯独可以坚持下来。&lt;/p&gt;
&lt;p&gt;和最近任务有关系，没有很明确的一个目标，现在每天过得可以说自我感觉十分糟糕，虽然每天都有在提&lt;/p&gt;
&lt;p&gt;高，但我想要更高的效率。&lt;/p&gt;
&lt;p&gt;也谈不上匆忙，总而言之，这件事情必须睡觉之前做完。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log003</title>
    <link href="http://yoursite.com/2018/02/04/log003/"/>
    <id>http://yoursite.com/2018/02/04/log003/</id>
    <published>2018-02-04T15:47:37.000Z</published>
    <updated>2018-02-04T15:48:20.080Z</updated>
    
    <content type="html"><![CDATA[<p>节奏渐入佳境，无论是博客还是技术 。尽管所有的时间安排都在按照计划执行，但是在安排任务上面，从任务量来说并没有完成。过分纠结于一个问题，导致解决时间过长。</p><p>在资源已经充分利用的前提下，下来比拼的就是效率了。</p><p>在思考之后，决定继续学习太极拳。</p><p>假期本来是打算去静下来看会书，结果最终也成了战场。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;节奏渐入佳境，无论是博客还是技术 。尽管所有的时间安排都在按照计划执行，但是在安排任务上面，从任务量来说并没有完成。过分纠结于一个问题，导致解决时间过长。&lt;/p&gt;
&lt;p&gt;在资源已经充分利用的前提下，下来比拼的就是效率了。&lt;/p&gt;
&lt;p&gt;在思考之后，决定继续学习太极拳。&lt;/p
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>编写算法时一些思想与实践</title>
    <link href="http://yoursite.com/2018/02/04/%E7%BC%96%E5%86%99%E7%AE%97%E6%B3%95%E6%97%B6%E4%B8%80%E4%BA%9B%E6%80%9D%E6%83%B3%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/02/04/编写算法时一些思想与实践/</id>
    <published>2018-02-04T04:07:49.000Z</published>
    <updated>2018-02-09T03:45:47.489Z</updated>
    
    <content type="html"><![CDATA[<p>初稿    2018.2.4<br>修改    2018.2.9</p><hr><h2 id="明确定义"><a href="#明确定义" class="headerlink" title="明确定义"></a>明确定义</h2><p>在普通的排序问题上面，经常会因为在边界条件的角标越界而出错。或直接因为代码逻辑问题而崩溃，究其原因是对于<strong>数据定义不明确</strong>或 <strong>不能始终维护定义的正确性</strong>。</p><p>大多数问题，相信都出自其手。反过来，应该时刻的注意并保持定义的正确性。对于我们理解别人的代码，还是看自己的代码都会顺畅很多。在这个系列中，我们同样会时刻注意这一点。</p><p>不要看文字简短，但是上面的这两句话是很重的。</p><h2 id="理解选择排序"><a href="#理解选择排序" class="headerlink" title="理解选择排序"></a><strong>理解选择排序</strong></h2><p>对于算法来说，最重要的是理解其思想。这不是说实现不重要，理解其思想是始终正确实现的重要前提。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a><strong>基本思想</strong></h3><blockquote><p>在一个未排序的序列中，选择最大或者最小的那个数据，去与未排序序列中的首个元素交换位置</p></blockquote><p>在排序问题上会分为已排序和未排序序列，我们选择用 <strong>i</strong> 来定义未排序序列的首个元素的位置，所以说在 <strong>[0, i-1]</strong> 区间内它是有序的，而在 <strong>[i, n -1]</strong> 的区间内是无序的，我们应该不断的在未排序的区间中选择最大或最小的一个放到未排序队列的首部，然后收缩未排序序列直到没有元素为止。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a><strong>算法实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> minIndex = i;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</div><div class="line">            <span class="keyword">if</span>(arr[minIndex] &gt; arr[j])</div><div class="line">                minIndex = j;</div><div class="line"></div><div class="line">        swap(arr[i], arr[minIndex]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 <strong>[i, n-1]</strong> 这个未排序序列中，我们通过for循环来不断的缩减范围，直至未排序序列没有元素。每次缩减范围之前，我们都要筛选出在未排序序列中的最小的元素，去放到未排序序列的首部，也可以说是有序序列尾部。筛选出最小元素的想法是，先假定未排序序列的第一个元素是最小的，然后依次去和其他未排序的元素比较，j 指向的是未排序序列中正与最小元素比较的元素。最终会选出最小的那一个。</p><h2 id="理解插入排序"><a href="#理解插入排序" class="headerlink" title="理解插入排序"></a><strong>理解插入排序</strong></h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a><strong>基本思想</strong></h3><blockquote><p>每次从未排序序列中拿一个元素，去放到已经有序序列的正确位置</p></blockquote><p>这回我们依然定义一个变量 <strong>i</strong> 去指向 <em>未排序序列中拿出来的那个元素</em>。所以在<strong>[0, i-1]</strong> 这个区间代表着已经排序的序列，而在 <strong>[i, n -1]</strong> 的区间内是无序的序列，</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a><strong>算法实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</div><div class="line"></div><div class="line">        T e = arr[i];</div><div class="line">        <span class="keyword">int</span> j ;</div><div class="line">        <span class="keyword">for</span>(j = i <span class="number">-1</span>; j&gt;=<span class="number">0</span> ;j--)</div><div class="line">            <span class="keyword">if</span>(e &lt; arr[j])</div><div class="line">                arr[j+<span class="number">1</span>] = arr[j];</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        arr[j+<span class="number">1</span>] = e;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当序列为一个元素时是有序的，所以初始无序序列的区间为<strong>[ 1, n-1 ]</strong>，我们不断的去缩小无序序列的范围，直至它一无所有～。每次缩减之前，需要在有序序列中找到对于 <strong>arr[ i ]</strong> 来讲的恰当位置。并且把他放置到该放的位置。</p><p>我们定义 <strong>j</strong> 在for循环内是指，从未排序序列中拿的那一个元素想去放置的位置，当确定 可以放置到j指向的位置时 退出for循环，但是因为最后for循环一定会执行 <strong>j–</strong>，因此在for循环外，<strong>j</strong> 是指该放置位置的前一个， 所以在最后放置元素时候，应该进行 <strong>+1</strong> 操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>虽然二者属于$O(n^2)$的算法，但是插入排序，相比较选择排序来说，可以提前终止。插入排序还有一个优点，对于几乎有序的数组来说，他的速度是$O(n)$的时间复杂度，正是因为这个特点，插入排序会成为很多高级算法的子过程。</p><p>那下面通过之前实现的<a href="https://jinfangzhang.github.io/2018/02/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/" target="_blank" rel="external">工具</a>，去进一步感受的他们特点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> n = <span class="number">20000</span>;</div><div class="line">    </div><div class="line"><span class="comment">// 测试1 一般测试</span></div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Test for random array, size = "</span>&lt;&lt;n&lt;&lt;<span class="string">", random range [0, "</span>&lt;&lt;n&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"><span class="keyword">int</span> *arr1 = SortTestHelper::generateRandomArray(n,<span class="number">0</span>,n);</div><div class="line"><span class="keyword">int</span> *arr2 = SortTestHelper::copyIntArray(arr1, n);</div><div class="line">    </div><div class="line">SortTestHelper::testSort(<span class="string">"Insertion Sort"</span>, insertionSort,arr1,n);</div><div class="line">SortTestHelper::testSort(<span class="string">"Selection Sort"</span>, selectionSort,arr2,n);</div><div class="line">    </div><div class="line"><span class="keyword">delete</span>[] arr1;</div><div class="line"><span class="keyword">delete</span>[] arr2;</div><div class="line">    </div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="comment">// 测试3 测试近乎有序的数组</span></div><div class="line"><span class="keyword">int</span> swapTimes = <span class="number">100</span>;</div><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Test for nearly ordered array, size = "</span>&lt;&lt;n&lt;&lt;<span class="string">", swap time = "</span>&lt;&lt;swapTimes&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">arr1 = SortTestHelper::generateNearlyOrderArray(n,swapTimes);</div><div class="line">arr2 = SortTestHelper::copyIntArray(arr1, n);</div><div class="line">    </div><div class="line">SortTestHelper::testSort(<span class="string">"Insertion Sort"</span>, insertionSort,arr1,n);</div><div class="line">SortTestHelper::testSort(<span class="string">"Selection Sort"</span>, selectionSort,arr2,n);</div><div class="line">    </div><div class="line"><span class="keyword">delete</span>[] arr1;</div><div class="line"><span class="keyword">delete</span>[] arr2;</div><div class="line">    </div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Test for random array, size = 20000, random range [0, 20000]</div><div class="line">Insertion Sort : 0.268021 s</div><div class="line">Selection Sort : 0.46862 s</div><div class="line"></div><div class="line">Test for nearly ordered array, size = 20000, swap time = 100</div><div class="line">Insertion Sort : 0.003808 s</div><div class="line">Selection Sort : 0.468284 s</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;初稿    2018.2.4&lt;br&gt;修改    2018.2.9&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;明确定义&quot;&gt;&lt;a href=&quot;#明确定义&quot; class=&quot;headerlink&quot; title=&quot;明确定义&quot;&gt;&lt;/a&gt;明确定义&lt;/h2&gt;&lt;p&gt;在普通的排序问题上面，经常会因为在
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Log002</title>
    <link href="http://yoursite.com/2018/02/03/log002/"/>
    <id>http://yoursite.com/2018/02/03/log002/</id>
    <published>2018-02-03T14:27:47.000Z</published>
    <updated>2018-02-04T00:31:08.718Z</updated>
    
    <content type="html"><![CDATA[<p>今天可以说，最大的收获是听谷歌方法论，对于计算机思维的一些思考。同时也因为着迷漫画而打乱了一天的节奏。</p><p>并且重新发问一个新问题，我每天都在学习新知识，那么太极拳我是否有时间去思考和学习呢？可能这需要我严密的去组织时间。</p><p>中午的时间浪费的出奇的严重，这是需要改正的一点。</p><p>当然今天还有很多没有完成的事情。周遭环境的不适应，应该更加快快速的的调整。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天可以说，最大的收获是听谷歌方法论，对于计算机思维的一些思考。同时也因为着迷漫画而打乱了一天的节奏。&lt;/p&gt;
&lt;p&gt;并且重新发问一个新问题，我每天都在学习新知识，那么太极拳我是否有时间去思考和学习呢？可能这需要我严密的去组织时间。&lt;/p&gt;
&lt;p&gt;中午的时间浪费的出奇的严重
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法的一些准备工作</title>
    <link href="http://yoursite.com/2018/02/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/02/03/数据结构与算法的一些准备工作/</id>
    <published>2018-02-03T03:02:49.000Z</published>
    <updated>2018-02-09T03:22:41.503Z</updated>
    
    <content type="html"><![CDATA[<p>初稿    2018.2.3<br>修改    2018.2.9</p><hr><p>对算法而言，虽然我们可以从理论上面分析该算法时间复杂度是$O(nlog^n)$,还是$O(n^2)$ 再或者是其他，但难免有点抽象，不好理解。为此，我们应该去准备一些必要的工具，从正面直接理解和观察他们，它们也是进一步理解和解决问题的基础。</p><p>毕竟算法是一种思想，语言只是我们使用的一种工具。</p><p>在语言上，我们选择<code>C++</code>，来进行实现。</p><p>下面是一些未来可能会用到的算法。</p><h2 id="生成数据"><a href="#生成数据" class="headerlink" title="生成数据"></a><strong>生成数据</strong></h2><p>涉及的问题主要是一些排序问题，数据源是最应该解决的。在生成数据上，应该至少生成两种数据组，一种是完全随机的，而另一种是几乎有序的数组。</p><p>选择在一个<strong>SortTestHelper</strong> 的命名空间之下（如果不知道的同学，可以简单去了解下，还是比较容易理解的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> SortTestHelper&#123;</div><div class="line">    <span class="comment">//工具代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="生成无序数据源"><a href="#生成无序数据源" class="headerlink" title="生成无序数据源"></a><strong>生成无序数据源</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//生成一个大小为n的随机数组，每个元素的随机范围在[rangeL,rangeR]。</span></div><div class="line"><span class="function"><span class="keyword">int</span>* <span class="title">generateRandomArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> rangeL, <span class="keyword">int</span> rangeR)</span></span>&#123;</div><div class="line">    assert( rangeL &lt;= rangeR);</div><div class="line">    <span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">    srand(time(<span class="literal">NULL</span>));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">        arr[i] = rand() % (rangeR - rangeL + <span class="number">1</span>) + rangeL;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="生成几乎有序的数组"><a href="#生成几乎有序的数组" class="headerlink" title="生成几乎有序的数组"></a><strong>生成几乎有序的数组</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 先 生成 一个从0到n - 1的完全有序的数据，然后在这个的基础之上交换几次。</span></div><div class="line"><span class="function"><span class="keyword">int</span>* <span class="title">generateNearlyOrderArray</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">int</span> swapTimes)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">        arr[i] = i;</div><div class="line">    &#125;</div><div class="line">    srand(time(<span class="literal">NULL</span>));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;swapTimes;i++)&#123;</div><div class="line">        <span class="keyword">int</span> posx = rand()%n;</div><div class="line">        <span class="keyword">int</span> posy = rand()%n;</div><div class="line">        swap(arr[posx],arr[posy]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="打印数据"><a href="#打印数据" class="headerlink" title="打印数据"></a><strong>打印数据</strong></h2><p>能用模板，我们尽量会用到模板。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T arr[],<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="判断是否有序"><a href="#判断是否有序" class="headerlink" title="判断是否有序"></a><strong>判断是否有序</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSorted</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; n<span class="number">-1</span>;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(arr[i] &gt; arr[i + <span class="number">1</span>])</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="真正的测试"><a href="#真正的测试" class="headerlink" title="真正的测试"></a><strong>真正的测试</strong></h2><p>在这里我们会默认，我们之后的测试方法都是同一种声明顺序与结构 $$void(*sort)(T[\ ]\ arr, int\  size)$$</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//我们会测试整个排序完的数据是否有序，在有序的前提下，我们会给出运行所需要的时间。</div><div class="line">template&lt;typename T&gt; </div><div class="line">void testSort( string sortName, void(*sort)(T[], int), T arr[], int n)&#123;</div><div class="line">    clock_t startTime = clock();</div><div class="line">    sort(arr,n);</div><div class="line">    clock_t endTime = clock();</div><div class="line">    </div><div class="line">    assert( isSorted(arr,n));</div><div class="line">    cout &lt;&lt; sortName &lt;&lt; " : " &lt;&lt; double(endTime - startTime) / CLOCKS_PER_SEC &lt;&lt; " s" &lt;&lt; endl;</div><div class="line"></div><div class="line">    return ;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a><strong>复制数组</strong></h2><pre><code class="cpp"><span class="function"><span class="keyword">int</span>* <span class="title">copyIntArray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>{    <span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];    copy(a,a+n,arr);    <span class="keyword">return</span> arr;}</code></pre><p><strong>以上我们的数组是采用new的方式来开辟内存空间的，所以在使用完了之后需要delete，虽然不delete并不会影响什么，但你应该去养成这样的一个好习惯。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;初稿    2018.2.3&lt;br&gt;修改    2018.2.9&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;对算法而言，虽然我们可以从理论上面分析该算法时间复杂度是$O(nlog^n)$,还是$O(n^2)$ 再或者是其他，但难免有点抽象，不好理解。为此，我们应该去准备一些必要的工具，从正面
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
