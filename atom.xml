<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JianRan</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-28T04:24:57.713Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JianRan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内建容器(一)</title>
    <link href="http://yoursite.com/2018/02/28/go-inner-container-1/"/>
    <id>http://yoursite.com/2018/02/28/go-inner-container-1/</id>
    <published>2018-02-28T04:24:10.000Z</published>
    <updated>2018-02-28T04:24:57.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><p>数组是值类型，也就是说传递的时候，是通过拷贝的方式，进行传递</p><h3 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a><strong>定义数组</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr [<span class="number">5</span>]<span class="keyword">int</span>  </div><div class="line">arr2 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;   <span class="comment">//如果使用 : 去定义数组，那么必须赋初值</span></div><div class="line">arr3 := [...]<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;    <span class="comment">//让系统自己识别，有几个数字</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> grid [<span class="number">4</span>][<span class="number">5</span>]<span class="keyword">int</span>      <span class="comment">//定义多维数组</span></div></pre></td></tr></table></figure><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a><strong>遍历数组</strong></h3><p>最基本的形式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</div><div class="line">    fmt.Println(arr[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用 <strong>range</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i , v : = <span class="keyword">range</span> arr &#123;   <span class="comment">//i 是数组的下表， v 是数组的值</span></div><div class="line">    fmt.Println(i, v)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><ul><li><p><strong>[10]int</strong> 和 <strong>[20]int</strong> 是不同的类型</p></li><li><p>[]int 和 [5]int 代表完全不同的含义，前者表示切片，后者才表示数组</p></li><li><p>数组是值类型</p></li><li><p>它不像C，数组头指针并不代表数组的地址</p></li></ul><p><strong>go语言中不直接使用数组</strong></p><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a><strong>Slice</strong></h2><h3 id="Slice-是什么"><a href="#Slice-是什么" class="headerlink" title="Slice 是什么"></a><strong>Slice 是什么</strong></h3><p>Slice 是 数组 的一个 View<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;  <span class="comment">//数组</span></div><div class="line">s := arr[<span class="number">2</span>:<span class="number">6</span>]   <span class="comment">//slice     s =&gt; 2,3,4,5  [2,6)</span></div></pre></td></tr></table></figure></p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;  <span class="comment">//数组</span></div><div class="line">s := arr[<span class="number">2</span>:<span class="number">6</span>]   <span class="comment">//slice     s =&gt; 2,3,4,5  [2,6)</span></div><div class="line">s1 := arr[:<span class="number">6</span>]   <span class="comment">//slice     s =&gt; 0,1,2,3,4,5  [0,6)</span></div><div class="line">s2 := arr[<span class="number">2</span>:]   <span class="comment">//slice     s =&gt; 2,3,4,5,6,7,8  [2, len(arr) )</span></div><div class="line">s3 := arr[:]   <span class="comment">//slice     s =&gt; 0,1,2,3,4,5,6,7,8  [0,len(arr) )</span></div></pre></td></tr></table></figure><p>s[0] 代表当前Slice 的第一个数组</p><p><strong>可以通过修改Slice中的值去修改原来数组当中的值</strong></p><h3 id="进一步操作"><a href="#进一步操作" class="headerlink" title="进一步操作"></a><strong>进一步操作</strong></h3><p>下面的Slice 的都是投影同一个数组的arr<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;  <span class="comment">//数组</span></div><div class="line">s := arr[:]     <span class="comment">//  0,1,2,3,4,5,6,7,8</span></div><div class="line">s = s[:<span class="number">5</span>]     <span class="comment">//    0,1,2,3,4</span></div><div class="line">s = s[<span class="number">2</span>:]     <span class="comment">//    2,3,4</span></div></pre></td></tr></table></figure></p><p>试图理解一下，下面这些代码<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;  <span class="comment">//数组</span></div><div class="line">s1 := arr[<span class="number">2</span>,<span class="number">6</span>]  <span class="comment">//2,3,4,5</span></div><div class="line"><span class="comment">//s1 只有四个数字</span></div><div class="line">s2 := s1[<span class="number">3</span>,<span class="number">5</span>]   <span class="comment">//5,6   s[3]    s[4]</span></div><div class="line">fmt.Println(s1[<span class="number">4</span>]   <span class="comment">//error 直接取是取不出来的</span></div></pre></td></tr></table></figure></p><p>为了正确理解上面代码，我们有必要深入了解一下slice</p><p><img src="http://p3o1bechg.bkt.clouddn.com/FnsLz75IFKrn5b9r1Mc6Ji94k0IP" alt="slice"></p><ul><li><p>slice中一个ptr的指针，指向slice开头的那一个元素</p></li><li><p>len是slice的大小，通过下标的方式，只能访问到len以内的元素</p></li><li><p>cap是从slice第一个元素到投影数组的最后一个元素的大小，在cap范围内的，可以通过再切片来访问到</p></li></ul><p><strong>为此，我们可以通过 len() 和 cap() 方法获取该slice的值</strong></p><h3 id="向Slice添加元素"><a href="#向Slice添加元素" class="headerlink" title="向Slice添加元素"></a><strong>向Slice添加元素</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</div><div class="line">s1 := arr[<span class="number">2</span>:<span class="number">6</span>]</div><div class="line">s2 := s1[<span class="number">3</span>:<span class="number">5</span>]</div><div class="line">s3 := <span class="built_in">append</span>(s2,<span class="number">10</span>)</div><div class="line">s4 := <span class="built_in">append</span>(s3,<span class="number">11</span>)</div><div class="line">s5 := <span class="built_in">append</span>(s4,<span class="number">12</span>)</div></pre></td></tr></table></figure><p>进过上面代码之后，arr最后会是多少</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">s1  <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span></div><div class="line">s2  <span class="number">5</span>,<span class="number">6</span></div><div class="line">s3  <span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span></div><div class="line">s4  <span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">11</span></div><div class="line">s5  <span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span></div><div class="line"></div><div class="line">arr <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span></div></pre></td></tr></table></figure><p>s4,s5 当中的 11 和 12 去哪里了？</p><p>他们的视图已经不是原来的arr，而是一个新数组，因为已经超过了 s2 的 cap，系统重新开一个更大cap的数组</p><h3 id="slice的创建"><a href="#slice的创建" class="headerlink" title="slice的创建"></a><strong>slice的创建</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s []<span class="keyword">int</span> <span class="comment">//len=0 cap=0   s = nil</span></div><div class="line"></div><div class="line"><span class="comment">//先建立了一个arr，他的值为2,4,6,8</span></div><div class="line"><span class="comment">//再创建了一个slice的视图</span></div><div class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;</div><div class="line"></div><div class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>)   <span class="comment">//len(s2) = 16 cap(s2) = 16</span></div><div class="line"></div><div class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>,<span class="number">32</span>) <span class="comment">//len(s3) = 16 cap(s3) = 32</span></div></pre></td></tr></table></figure><p><strong>slice 的复制</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">copy(s2,s1)//把s1的内容拷贝到s2当中</div><div class="line">//s2  [2,4,6,8,0,0,0,0,0,0,0,0,0,0,0,0]</div></pre></td></tr></table></figure><p><strong>slice 的 删除</strong></p><p>系统没有内建函数，但是我们可以通过append来</p><p>如果我们想删除 s2 中的8的话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// s2   [2,4,6,8,0,0,0,0,0,0,0,0,0,0,0,0]</div><div class="line">append(s2[:3], s2[4:])</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;&lt;strong&gt;数组&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;数组是值类型，也就是说传递的时候，是通过拷贝的方式，进行传递&lt;/p&gt;
&lt;h3 id=&quot;定义数组&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>extends和implements的一些思考</title>
    <link href="http://yoursite.com/2018/02/27/extends%E5%92%8Cimplements%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2018/02/27/extends和implements的一些思考/</id>
    <published>2018-02-27T09:33:51.000Z</published>
    <updated>2018-02-27T09:37:01.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="extends-amp-implements"><a href="#extends-amp-implements" class="headerlink" title="extends &amp; implements"></a><strong>extends &amp; implements</strong></h2><p>继承和接口，在 java 中简单来说就是 extend 和 implements。继承从语义上来说，就是会得到父类的一些东西（方法，参数），无论你是否愿意。而接口，它本身就是空的，并不会得到什么东西，我画了个图来更加的感受一下</p><p><img src="http://p3o1bechg.bkt.clouddn.com/FnaG4YHoc8Gei1MR50NsTqI4fCWO" alt="extends"> <img src="http://p3o1bechg.bkt.clouddn.com/FoJK7B-8HZD49aOVrEnIZIQ-tHAr" alt="implements"></p><p>当我们使用 extends 的时候，子类会得到一些具体实现的代码。这样做有好有坏，好的地方上，我们可以提高的代码的复用性，使我们不需要去重复的去写一些代码。坏的地方，就是增加了耦合，强制我们去依赖细节。</p><p>使用 implements 的时候，有点反过来的味道。我们操作的永远会是interface或者 abstract 的子类。也就是在抽象层次上进行操作。这样我们会更少的去依赖细节，增加可拓展性。</p><p>在写代码的过程中，时刻要应对的变化。我们所创造的系统应该更加的容易的扩展，而不是每次都去修改原先的代码，这样对系统无论是安全性还是维护成本来说，都是应该尽量避免的行为。虽然无法预测未来的事情，但我们至少可以掌控当下写的内容。</p><h2 id="尽量遵循一些原则"><a href="#尽量遵循一些原则" class="headerlink" title="尽量遵循一些原则"></a><strong>尽量遵循一些原则</strong></h2><p>在设计写代码时，我们应该尽可能的避免直接依赖细节，尽可能的操作抽象，尤其是在写框架的时候。我们<strong>应该针对接口编程，而不是针对特定的实现</strong>。</p><p>应该去尽量<strong>使用组合</strong>，这里举一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Class Duck&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</div><div class="line">        ....    <span class="comment">// 具体代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果想去修改fly中的方法，除了覆写别无它法，而且覆写的成本会很高，如果换一种方式。我们只需要去改变Flayable的变量值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Class Duck&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> Flyable flyBehavior</span></div><div class="line">    <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span>&#123;</div><div class="line">        flyBehavior.fly();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>除以上以外，我们应该去<strong>隔离变化</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;extends-amp-implements&quot;&gt;&lt;a href=&quot;#extends-amp-implements&quot; class=&quot;headerlink&quot; title=&quot;extends &amp;amp; implements&quot;&gt;&lt;/a&gt;&lt;strong&gt;extends &amp;a
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Java编程思想" scheme="http://yoursite.com/tags/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>go语言的基本语法糖(-)</title>
    <link href="http://yoursite.com/2018/02/27/go_syntactic_sugar1/"/>
    <id>http://yoursite.com/2018/02/27/go_syntactic_sugar1/</id>
    <published>2018-02-27T02:55:24.000Z</published>
    <updated>2018-02-28T04:25:01.285Z</updated>
    
    <content type="html"><![CDATA[<p>go语言中变量的声名和很多语言都是反着来的,而且go语言只有值传递</p><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a><strong>定义变量</strong></h2><p>go语言是强类型<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//go语言会动态的识别类型</span></div><div class="line"><span class="keyword">var</span> aa</div><div class="line"><span class="keyword">var</span> aa = <span class="number">3</span></div><div class="line"><span class="keyword">var</span> a, b, c, s = <span class="number">3</span>, <span class="number">4</span>, <span class="literal">true</span>, <span class="string">"def"</span></div><div class="line"> </div><div class="line"></div><div class="line"><span class="keyword">var</span> ss <span class="keyword">string</span></div><div class="line"><span class="keyword">var</span> cc ww <span class="keyword">string</span></div><div class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span> = <span class="number">3</span>, <span class="number">4</span></div><div class="line"></div><div class="line"><span class="comment">//定义包内部变量，不可以使用 `:` 来定义变量</span></div><div class="line">bb := <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment">//扎堆定义变量</span></div><div class="line"><span class="keyword">var</span> &#123;</div><div class="line">    cc = <span class="number">4</span></div><div class="line">    ee = <span class="number">6</span></div><div class="line">    ff = <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a><strong>枚举</strong></h2><p>go语言没有像java一样的enum，但可以通过 const 关键字来(const 的意思是不可改变的)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//类型一    手动输入</span></div><div class="line"><span class="keyword">const</span>(</div><div class="line">    cpp = <span class="number">0</span></div><div class="line">java = <span class="number">1</span></div><div class="line">python = <span class="number">2</span></div><div class="line">golang = <span class="number">3</span></div><div class="line">)</div><div class="line"><span class="comment">//类型二    不想手动输入，可以使用iota 自增长</span></div><div class="line"><span class="keyword">const</span>(</div><div class="line">    cpp = <span class="literal">iota</span>  <span class="comment">//0</span></div><div class="line">    java        <span class="comment">//1</span></div><div class="line">    python      <span class="comment">//2</span></div><div class="line">    golang      <span class="comment">//3</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">//类型三    对于iota的进一步使用</span></div><div class="line"><span class="comment">//b,kb,mb,gb,tb,pb</span></div><div class="line"><span class="keyword">const</span>(</div><div class="line">b = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)    <span class="comment">//1</span></div><div class="line">kb                      <span class="comment">//1024</span></div><div class="line">mb                      <span class="comment">//1048576</span></div><div class="line">gb                      ...</div><div class="line">tb</div><div class="line">pb</div><div class="line">)</div></pre></td></tr></table></figure><h2 id="Branch"><a href="#Branch" class="headerlink" title="Branch"></a><strong>Branch</strong></h2><p>go语言对于语句像 分支语句和循环语句尽量，省略括号</p><p>go 语言 的 nil 相当于 其他语言的 NULL、null，但 nil 还有其他特别的地方</p><h3 id="If"><a href="#If" class="headerlink" title="If"></a><strong>If</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//普通</span></div><div class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</div><div class="line">    ...</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>语言在条件判断的基础上还加入了向for语言的赋初值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> a:=<span class="number">0</span>; a&lt;<span class="number">10</span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a><strong>Switch</strong></h3><p>依然保留一般性的语法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//普通</span></div><div class="line"><span class="keyword">switch</span> op &#123;</div><div class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</div><div class="line"><span class="keyword">return</span> a + b</div><div class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</div><div class="line"><span class="keyword">return</span> a - b</div><div class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</div><div class="line"><span class="keyword">return</span> a / b</div><div class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</div><div class="line"><span class="keyword">return</span> a * b</div><div class="line"><span class="keyword">default</span>:</div><div class="line"><span class="built_in">panic</span>(<span class="string">"unsupported operation:"</span> + op)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>switch语句相应做了扩展。语句可以在case当中直接写条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">g:= &quot;&quot;</div><div class="line">switch &#123;</div><div class="line">    case score &lt; 0 || score &gt; 100:</div><div class="line">    panic(fmt.Sprintf(</div><div class="line">    &quot;Wrong score: %d&quot;, score))</div><div class="line">    case score &lt; 60:</div><div class="line">    g = &quot;F&quot;</div><div class="line">    case score &lt; 80:</div><div class="line">    g = &quot;C&quot;</div><div class="line">    case score &lt; 90:</div><div class="line">    g = &quot;B&quot;</div><div class="line">    case score &lt;= 100:</div><div class="line">    g = &quot;A&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="Loop"><a href="#Loop" class="headerlink" title="Loop"></a><strong>Loop</strong></h2><p>go没有while语句，但是 for 已足以</p><p>基本形式<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ; ; &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果没有任何条件，就相当一个死循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//死循环</div><div class="line">for&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果只有一个判断条件，可以省略两个冒号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for n &lt; 10 &#123;</div><div class="line">fmt.Print(n)</div><div class="line">n++</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a><strong>Function</strong></h2><p>go语言的函数可以返回多个返回值，同时声明方式也是反着的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回一个值</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">eval</span><span class="params">(a,b <span class="keyword">int</span>, op <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">返回多个值</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="params">(q,r <span class="keyword">int</span>)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> a / b,a % b</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>go语言是支持函数式编程的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">(op <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>,<span class="title">a</span>, <span class="title">b</span> <span class="title">int</span>) <span class="title">int</span></span>&#123;</div><div class="line"><span class="keyword">return</span> op(a, b)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Point"><a href="#Point" class="headerlink" title="Point"></a><strong>Point</strong></h2><p>在go语言中，指针是不允许进行运算的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> a <span class="keyword">int</span>  = <span class="number">2</span></div><div class="line"><span class="keyword">var</span> pa *<span class="keyword">int</span> = &amp;a</div><div class="line">*pa = <span class="number">3</span></div><div class="line">fmt.Println(a)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;go语言中变量的声名和很多语言都是反着来的,而且go语言只有值传递&lt;/p&gt;
&lt;h2 id=&quot;定义变量&quot;&gt;&lt;a href=&quot;#定义变量&quot; class=&quot;headerlink&quot; title=&quot;定义变量&quot;&gt;&lt;/a&gt;&lt;strong&gt;定义变量&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;go语言
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>log015</title>
    <link href="http://yoursite.com/2018/02/27/log015/"/>
    <id>http://yoursite.com/2018/02/27/log015/</id>
    <published>2018-02-26T16:03:18.000Z</published>
    <updated>2018-02-27T03:07:48.545Z</updated>
    
    <content type="html"><![CDATA[<p>假期最后几天，父母要出差。只能转移到奶奶家。</p><p>效率变得会比以往低一点，但每天必须要做的事情，还是要做的。</p><p>在积极做总结中…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假期最后几天，父母要出差。只能转移到奶奶家。&lt;/p&gt;
&lt;p&gt;效率变得会比以往低一点，但每天必须要做的事情，还是要做的。&lt;/p&gt;
&lt;p&gt;在积极做总结中…&lt;/p&gt;

      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>浮点数</title>
    <link href="http://yoursite.com/2018/02/21/float/"/>
    <id>http://yoursite.com/2018/02/21/float/</id>
    <published>2018-02-21T04:02:21.000Z</published>
    <updated>2018-02-22T01:00:26.655Z</updated>
    
    <content type="html"><![CDATA[<p>浮点数总是给我一种朦朦胧胧的感觉，知道它描述的数字有偏差，知道它在C语言中不能和整数型直接转换，却始终不敢拍着胸膛说“我懂了”。float的种种疑惑和仅停留在可以表达小数的认识上。</p><hr><p>我们需要先了解一下计算机的浮点数表示法。在 C 语言中计算机的浮点数用的是 IEEE 754 标准</p><p>IEEE 754标准中规定float单精度浮点数在机器中表示用 </p><ul><li>用 1 位表示数字的符号 S (Sign)</li><li>用 8 位来表示指数 E (Exponent)</li><li>用23 位来表示尾数 M (Mantissa)</li></ul><p>对于double双精度浮点数</p><ul><li>用 1 位表示符号 S (Sign)</li><li>用 11 位表示指数 E (Exponent)</li><li>用 52 位表示尾数 M (Mantissa)</li></ul><p>IEEE 浮点值的格式如下图所示:<br><img src="http://p3o1bechg.bkt.clouddn.com/FhyIhmiWMhg9CXzHfIvwVzmKEzXI" alt="IEEE 754"></p><p>这里我们以32位为例，来展示计算公式</p><p>$$(-1)^S * (1 + \frac{M}{2^{23}}) * 2^{\textrm{(E - 127)}}$$</p><p>让我们更进步的解释一下浮点数的三段各部分的意思</p><ul><li><p>第一段是符号位。</p></li><li><p>第二段是指数位，对于任何数ｘ，其都可以找到一个ｎ，使得$2^n&lt;=x&lt;=2^{n+1} $，比如，拿３来说，因为$2^1&lt;3&lt;2^2$,所以 $n=1$，同时，为了表示 0.00x 这样的数，所以需要有负数。8个比特位，总共能表示 255 个数字，为了表示负数,也就是在[-127,128]这个区间中，才有$2^{\textrm{(E - 127)}}$</p></li><li>第三段叫做偏移量会更准确一些，如果没有所谓的偏移量，我们展示的将是一个$2^{\textrm{(E - 127)}}$,精简一点也就是$2^x$，不如说这个数字就是一个基值，我们将会在这个基值上面再进行偏移，偏移的总量同样是$2^x$。偏移量为23位，就是说把这段数字分为了$2^{23}$份，展开公式会更好的展示出来:<br>$$(-1)^S * (1 * 2^{E - 127} + \frac{M}{2^{23}} * 2^{E - 127})$$</li></ul><p>正因为我们是在$2^x$的基础上偏移$\frac{M}{2^{23}}$,难免会有些数字无法完全吻合，只能依靠近似数来模拟。偏差由此而来。</p><p>为了更好的理解我们来拿3.14来看看</p><ol><li>3.14是正数，S的值为1</li><li>$2^1 &lt; 3.14 &lt; 2^2$ 所以$E - 127 = 1$,E 等于128</li><li>$(3.14 - 2^1)/2^1 = 0.57$, $\frac{M}{2^{23}} = 0.57$ ，求出来的M不是一个整数，到这里就出现了精度问题</li></ol><p>这里可以看出，计算浮点数的计算量还是很大的，如果没有硬件的直接支持对于计算机的消耗可想而知。同样依照这样的一条思路，也可以事先算好这么一个对应规格的浮点数，去和其他数字进行运算。曾经的<strong>魔数</strong>就是一个典型的例子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;浮点数总是给我一种朦朦胧胧的感觉，知道它描述的数字有偏差，知道它在C语言中不能和整数型直接转换，却始终不敢拍着胸膛说“我懂了”。float的种种疑惑和仅停留在可以表达小数的认识上。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们需要先了解一下计算机的浮点数表示法。在 C 语言中计算机的浮点数
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="程序" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>log014</title>
    <link href="http://yoursite.com/2018/02/21/log014/"/>
    <id>http://yoursite.com/2018/02/21/log014/</id>
    <published>2018-02-20T16:08:09.000Z</published>
    <updated>2018-02-27T03:07:03.540Z</updated>
    
    <content type="html"><![CDATA[<p>假期余量尽管不多，收货还是不错的</p><p>以15分钟为英语学习单位的方式，感觉不错</p><p>不带今天，还有十天假期</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假期余量尽管不多，收货还是不错的&lt;/p&gt;
&lt;p&gt;以15分钟为英语学习单位的方式，感觉不错&lt;/p&gt;
&lt;p&gt;不带今天，还有十天假期&lt;/p&gt;

      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log013</title>
    <link href="http://yoursite.com/2018/02/20/log013/"/>
    <id>http://yoursite.com/2018/02/20/log013/</id>
    <published>2018-02-20T02:17:43.000Z</published>
    <updated>2018-02-20T02:18:22.689Z</updated>
    
    <content type="html"><![CDATA[<p>这几天大部分时间都花在陪家人身上，对于一些项目时间难免有些不够，但依然会做，</p><p>log 已经中断了几天，还包括英语。</p><p>只能说自己的时间安排不恰当，有很大的调整空间</p><p>计划到开学之前，基本学完20小时的go语言</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天大部分时间都花在陪家人身上，对于一些项目时间难免有些不够，但依然会做，&lt;/p&gt;
&lt;p&gt;log 已经中断了几天，还包括英语。&lt;/p&gt;
&lt;p&gt;只能说自己的时间安排不恰当，有很大的调整空间&lt;/p&gt;
&lt;p&gt;计划到开学之前，基本学完20小时的go语言&lt;/p&gt;

      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>SharedPreferences</title>
    <link href="http://yoursite.com/2018/02/17/SharedPreferences/"/>
    <id>http://yoursite.com/2018/02/17/SharedPreferences/</id>
    <published>2018-02-17T02:47:31.000Z</published>
    <updated>2018-02-17T02:50:01.376Z</updated>
    
    <content type="html"><![CDATA[<p>如果想保存相对较小键值对集合，应该使用SharedPerference</p><h2 id="获取共享首选项句柄"><a href="#获取共享首选项句柄" class="headerlink" title="获取共享首选项句柄"></a><strong>获取共享首选项句柄</strong></h2><ul><li><p>getSharedPerferences() –如果需要指定文件名称，应该使用这个方法,第一个参数指定文件名称，第二个阐述文件权限。MODE_PRIVATE(Defalut)，仅能被创建者访问。还有MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Context context = getActivity(); </div><div class="line">SharedPreferences sharedPreference =    context.getSharedPreferences(</div><div class="line">       getString(R.string.preference_file_key), Context.MODE_PRIVATE);</div></pre></td></tr></table></figure></li><li><p>getPreferences() – 如果您只需使用 Activity 的一个共享首选项，请从 Activity 中使用此方法。 因为此方法会检索属于该 Activity 的默认共享首选项文件，您无需提供名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);</div></pre></td></tr></table></figure></li></ul><h2 id="写入共享首选项"><a href="#写入共享首选项" class="headerlink" title="写入共享首选项"></a><strong>写入共享首选项</strong></h2><p>通过SharedPreferences引用调用edit() 来创建一个 SharedPreferences.Editor。使用putXXX() 来写入键和值，然后，调用 commit() 以保存所做的更改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);</div><div class="line">SharedPreferences.Editor editor = sharedPref.edit();</div><div class="line">editor.putInt(getString(R.string.saved_high_score), newHighScore);</div><div class="line">editor.commit();</div></pre></td></tr></table></figure></p><h2 id="读取信息"><a href="#读取信息" class="headerlink" title="读取信息"></a><strong>读取信息</strong></h2><p>通过SharedPreferences引用的getXXX() 方法，去获取你想要减的值，并且根据需要提空，在键不存在的情况下返回默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);</div><div class="line">int defaultValue = getResources().getInteger(R.string.saved_high_score_default);</div><div class="line">long highScore = sharedPref.getInt(getString(R.string.saved_high_score), defaultValue);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果想保存相对较小键值对集合，应该使用SharedPerference&lt;/p&gt;
&lt;h2 id=&quot;获取共享首选项句柄&quot;&gt;&lt;a href=&quot;#获取共享首选项句柄&quot; class=&quot;headerlink&quot; title=&quot;获取共享首选项句柄&quot;&gt;&lt;/a&gt;&lt;strong&gt;获取共享首选项句
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>log012</title>
    <link href="http://yoursite.com/2018/02/15/log012/"/>
    <id>http://yoursite.com/2018/02/15/log012/</id>
    <published>2018-02-14T16:05:15.000Z</published>
    <updated>2018-02-14T16:11:30.674Z</updated>
    
    <content type="html"><![CDATA[<p>对于英语的学习，将会专注于英语流利说</p><p>意识到自己欠缺一些金融知识</p><p>从自己很久不看的一个专栏中又学会一些东西</p><p>技术应该继续下去，但是重要性在持续走低</p><p>重新定义技术的意义：技术将会成为我的谋生工具</p><p>但真正要成为精英还需很多其他的东西</p><p>非常需要再次重新去规划自己</p><p>此刻应该立刻睡觉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于英语的学习，将会专注于英语流利说&lt;/p&gt;
&lt;p&gt;意识到自己欠缺一些金融知识&lt;/p&gt;
&lt;p&gt;从自己很久不看的一个专栏中又学会一些东西&lt;/p&gt;
&lt;p&gt;技术应该继续下去，但是重要性在持续走低&lt;/p&gt;
&lt;p&gt;重新定义技术的意义：技术将会成为我的谋生工具&lt;/p&gt;
&lt;p&gt;但真正要成
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log011</title>
    <link href="http://yoursite.com/2018/02/13/log011/"/>
    <id>http://yoursite.com/2018/02/13/log011/</id>
    <published>2018-02-13T00:43:34.000Z</published>
    <updated>2018-02-13T00:44:06.430Z</updated>
    
    <content type="html"><![CDATA[<p>重新确定英语的学习方式，应该渗透到每天的生活中。学习计划将要重新安排，一切以两个小时为单位， 每过两小时就学半个小时英语。其实就是以2.5小时为一个单位。</p><p>确定未来一定会考人类的最高学历</p><p>10点过后，不再学习<strong>英语流利说</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重新确定英语的学习方式，应该渗透到每天的生活中。学习计划将要重新安排，一切以两个小时为单位， 每过两小时就学半个小时英语。其实就是以2.5小时为一个单位。&lt;/p&gt;
&lt;p&gt;确定未来一定会考人类的最高学历&lt;/p&gt;
&lt;p&gt;10点过后，不再学习&lt;strong&gt;英语流利说&lt;/stro
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>小程序结构</title>
    <link href="http://yoursite.com/2018/02/12/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/02/12/小程序结构/</id>
    <published>2018-02-12T09:02:42.000Z</published>
    <updated>2018-02-12T09:21:37.971Z</updated>
    
    <content type="html"><![CDATA[<p>在创建了一个小程序项目之后，可能在这个项目里会看见不同类型的文件。这些文件分别是</p><ol><li><p>.json 后缀的 JSON 配置文件</p></li><li><p>.wxml 后缀的 WXML 模板文件</p></li><li><p>.wxss 后缀的 WXSS 样式文件</p></li><li><p>.js 后缀的 JS 脚本逻辑文件</p></li></ol><p>初看结构十分类似 HTML + CSS + JS 三剑客，进一步了解后他们的作用也大抵相同。在小程序总体结构上，分成两部分。一部分是全局文件，都是以<code>app</code>开头，承载整个小程序的全局信息,例如 <code>app.json</code>, <code>app.wxss</code>, <code>app.js</code>。另一部分是局部文件，具体到每个一个页面都拥有自己的一套配置信息，局部文件的优先级会大于全局文件。例如 <code>index.wxml</code>, <code>index.wxss</code>, <code>index.js</code>, <code>index.json</code></p><p>下面我们以这样一个目录结构来依次介绍</p><p><img src="http://p3o1bechg.bkt.clouddn.com/Fj5LUc4w_wTHXa7QCyMSGwcbivc1" alt="tree"></p><p>先忽略掉 typinggs 目录。</p><h2 id="JSON配置"><a href="#JSON配置" class="headerlink" title="JSON配置"></a><strong>JSON配置</strong></h2><p>从项目根目录，我们依次看到 app.json, project.config.json 和 index.json。我们依次来说明用途。</p><p><strong>app.json</strong> 是对当前小程序的全局配置，包括了<strong>小程序的所有页面路径</strong>，<strong>界面表现</strong>， <strong>网络超时时间</strong>， <strong>底部tab</strong> 等信息。结构如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  "pages":[</div><div class="line">    ...</div><div class="line">  ],</div><div class="line">  "window":&#123;</div><div class="line">    ...</div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>project.config.json</strong> 是对于微信开发者工具一些个性化配置。当你换了一台电脑或者重新安装工具时，你只要载入同一个项目的代码。开发者工具就会根据这些配置进行恢复。</p><p><strong>index.json</strong> 去设置一个页面的配置，当 app.json 配置了属性，而 index.json 没有配置就默认使用 app.json 的。当两者都配置了，则使用 index.json 的 </p><h2 id="WXML-WXSS-JS"><a href="#WXML-WXSS-JS" class="headerlink" title="WXML WXSS JS"></a><strong>WXML WXSS JS</strong></h2><p>它其实类似 HTML + CSS + JS 这个，只不过他们都有一些细微的差距。</p><p>WXML 于 HTML 的差别，我们直接用微信文档中的一段话。</p><ol><li><p>标签名字有点不一样 往往写 HTML 的时候，经常会用到的标签是 div, p, span，开发者在写一个页面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。换个思路，既然大家都需要这些组件，为什么我们不能把这些常用的组件包装起来，大大提高我们的开发效率。 从上边的例子可以看到，小程序的 WXML 用的标签是 view, button, text 等等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频等等组件能力 更多详细的组件讲述参考下个章节 小程序的能力</p></li><li><p>多了一些 wx:if 这样的属性以及 { { } } 这样的表达式 在网页的一般开发流程中，我们通常会通过 JS 操作 DOM (对应 HTML 的描述产生的树)，以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，JS 会记录一些状态到 JS 变量里边，同时通过 DOM API 操控 DOM 的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了 MVVM 的开发模式(例如 React, Vue)，提倡把渲染和逻辑分离。简单来说就是不要再让 JS 直接操控 DOM，JS只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。 小程序的框架也是用到了这个思路，如果你需要把一个 Hello World 的字符串显示在界面上。 WXML 是这么写 :</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;text&gt;&lt;/text&gt;</div></pre></td></tr></table></figure><p>JS 只需要管理状态即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.setData(&#123; msg: &quot;Hello World&quot; &#125;)</div></pre></td></tr></table></figure></p><p>通过 { { } } 的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 if/else, for等控制能力，在小程序里边，这些控制能力都用 wx: 开头的属性来表达。 更详细的文档可以参考 WXML</p><p>WXSS 具有CSS大部分特性，除此也做了一些扩充和修改。增加了尺寸单位 rpx，提供了全局样式和局部样式，此外仅支持 css 部分选择器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在创建了一个小程序项目之后，可能在这个项目里会看见不同类型的文件。这些文件分别是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;.json 后缀的 JSON 配置文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;.wxml 后缀的 WXML 模板文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;.wxss 
      
    
    </summary>
    
      <category term="2018-02" scheme="http://yoursite.com/categories/2018-02/"/>
    
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>log010</title>
    <link href="http://yoursite.com/2018/02/12/log010/"/>
    <id>http://yoursite.com/2018/02/12/log010/</id>
    <published>2018-02-11T16:50:39.000Z</published>
    <updated>2018-02-12T09:00:14.846Z</updated>
    
    <content type="html"><![CDATA[<p>找不到顺手的图床插件，干脆自动动手写了一个。尽管用的他们的sdk，但好歹是自己给自己写的第一个东西,值得纪念。</p><p>帮同学解决了技术上面的小问题，还是挺开心的。</p><p>对于英语的执行力依然很差，需要提高！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;找不到顺手的图床插件，干脆自动动手写了一个。尽管用的他们的sdk，但好歹是自己给自己写的第一个东西,值得纪念。&lt;/p&gt;
&lt;p&gt;帮同学解决了技术上面的小问题，还是挺开心的。&lt;/p&gt;
&lt;p&gt;对于英语的执行力依然很差，需要提高！&lt;/p&gt;

      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log009</title>
    <link href="http://yoursite.com/2018/02/11/log009/"/>
    <id>http://yoursite.com/2018/02/11/log009/</id>
    <published>2018-02-10T16:59:26.000Z</published>
    <updated>2018-02-11T07:00:07.739Z</updated>
    
    <content type="html"><![CDATA[<p>对于自己的未来规划，有了一个方向。重新定义了，我目前处于的阶段，大学沉淀期。</p><p>总体计划按目标完成。</p><p>作息再次修改成，24点准时睡觉，7点起床.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于自己的未来规划，有了一个方向。重新定义了，我目前处于的阶段，大学沉淀期。&lt;/p&gt;
&lt;p&gt;总体计划按目标完成。&lt;/p&gt;
&lt;p&gt;作息再次修改成，24点准时睡觉，7点起床.&lt;/p&gt;

      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log008</title>
    <link href="http://yoursite.com/2018/02/10/log008/"/>
    <id>http://yoursite.com/2018/02/10/log008/</id>
    <published>2018-02-09T16:32:02.000Z</published>
    <updated>2018-02-10T02:32:44.284Z</updated>
    
    <content type="html"><![CDATA[<p>重心持续的转移，并不意味比之前懒散。但要去做什么最近一直在思考。希望短时间内可以想出。</p><p>每次的任务不要给自己太过于紧张。</p><p>英语应该保持警惕。一不注意它，就有点松动的迹象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重心持续的转移，并不意味比之前懒散。但要去做什么最近一直在思考。希望短时间内可以想出。&lt;/p&gt;
&lt;p&gt;每次的任务不要给自己太过于紧张。&lt;/p&gt;
&lt;p&gt;英语应该保持警惕。一不注意它，就有点松动的迹象。&lt;/p&gt;

      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log007</title>
    <link href="http://yoursite.com/2018/02/09/log007/"/>
    <id>http://yoursite.com/2018/02/09/log007/</id>
    <published>2018-02-08T17:50:08.000Z</published>
    <updated>2018-02-09T00:58:46.007Z</updated>
    
    <content type="html"><![CDATA[<p>技术方面并没有提升多少，但自己意识到了通识教育的重要性。随着自身的发展，技术已经不再成为短板。</p><p>现阶段的主要目标还是技术。不过看一些小说的时间，可以变成另外一些特定的书籍。</p><p>再次下定义，纯粹的知识没有任何意义，纯粹的思想同样也是。需要更多的文化点缀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;技术方面并没有提升多少，但自己意识到了通识教育的重要性。随着自身的发展，技术已经不再成为短板。&lt;/p&gt;
&lt;p&gt;现阶段的主要目标还是技术。不过看一些小说的时间，可以变成另外一些特定的书籍。&lt;/p&gt;
&lt;p&gt;再次下定义，纯粹的知识没有任何意义，纯粹的思想同样也是。需要更多的文化点
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>mergesSortAdvance</title>
    <link href="http://yoursite.com/2018/02/08/mergesSortAdvance/"/>
    <id>http://yoursite.com/2018/02/08/mergesSortAdvance/</id>
    <published>2018-02-08T03:12:18.000Z</published>
    <updated>2018-02-08T03:13:26.164Z</updated>
    
    <content type="html"><![CDATA[<p>对于<a href="https://jinfangzhang.github.io/2018/02/07/mergeSort/" target="_blank" rel="external">之前的归并排序</a>的文章，刻意的留了一部分，单独拿出来说下。这部分还是很有趣和重要的一块。不记得算法的同志得自己去回顾一下。</p><h2 id="第一个优化"><a href="#第一个优化" class="headerlink" title="第一个优化"></a><strong>第一个优化</strong></h2><p>在几乎所有采用分而治之思想的算法中，当问题规模被分解到某种程度时，可以采用插入排序，将这些近乎有序的数组进行排序。</p><p>我们对应优化的点在于不在让问题规模分解成1为止，而是当问题规模减小到<strong>X</strong>(某个未知数）的时候，采用插入排序。为此我们重载了一个insertionSort，如下。这里不妨分析下这个重载后的算法定义是什么</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++)&#123;</div><div class="line">        T e = arr[i];</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>; j&gt;=l; j--)&#123;</div><div class="line">            <span class="keyword">if</span>(e &lt; arr[j])</div><div class="line">                arr[j+<span class="number">1</span>] = arr[j];</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        arr[j+<span class="number">1</span>] = e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>归并排序的优化。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> __mergeSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</div><div class="line">    <span class="keyword">if</span>(r-l &lt;= <span class="number">15</span>)&#123;</div><div class="line">        insertionSort(arr,l,r);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    </div><div class="line">    <span class="keyword">int</span> mi = (l+r)/<span class="number">2</span>;</div><div class="line">    __mergeSort(arr, l, mi);</div><div class="line">    __mergeSort(arr, mi + <span class="number">1</span>, r);</div><div class="line"></div><div class="line">    __merge(arr, l, mi, r);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果<br><img src="http://p3o1bechg.bkt.clouddn.com/mergeSort_advance&amp;&amp;mergeSort.png" alt="比较结果"></p><h2 id="第二个优化"><a href="#第二个优化" class="headerlink" title="第二个优化"></a>第二个优化</h2><p>除了要测试无序数组外，还要测试几乎有序的数组。其实不需要测试就已经很明白，对于几乎有序的数组插入排序是$O(n)$的时间复杂度，而即便是优化过的归并排序，也不过是$O(nlog^n)$。</p><p>我在这里的修改很简单。</p><p>就是对于$merge$算法而言，如果第二部分的第一个元素大于或等于第一部分的第最后一个元素，就说明这个数组是有序的，直接返回即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">void __mergeSort(T arr[], int l, int r)&#123;</div><div class="line">    if(r-l &lt;= 15)&#123;</div><div class="line">        insertionSort(arr,l,r);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    </div><div class="line">    int mi = (l+r)/2;</div><div class="line">    __mergeSort(arr, l, mi);</div><div class="line">    __mergeSort(arr, mi + 1, r);</div><div class="line"></div><div class="line">    //加了一个if判断</div><div class="line">    if(arr[mi] &gt; arr[mi + 1])</div><div class="line">        __merge(arr, l, mi, r);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>尽管最终依然无法优于在几乎有序数组中的插入排序，但是已经是在同一个数量级上面了。<br><img src="http://p3o1bechg.bkt.clouddn.com/mergeSort%E4%BC%98%E5%8C%96%E4%BA%8C.png" alt="比较结果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于&lt;a href=&quot;https://jinfangzhang.github.io/2018/02/07/mergeSort/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;之前的归并排序&lt;/a&gt;的文章，刻意的留了一部分，单独拿出来说下。这部分还是很有趣和
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>log006</title>
    <link href="http://yoursite.com/2018/02/08/log006/"/>
    <id>http://yoursite.com/2018/02/08/log006/</id>
    <published>2018-02-07T17:23:49.000Z</published>
    <updated>2018-02-07T17:27:34.399Z</updated>
    
    <content type="html"><![CDATA[<p>总的来说，今天的效率好了很多。几乎在战斗的时候，都属于认真状态。但是错过了本可以完成所有今天任务的机会。</p><p>对于娱乐，应该先把主要任务完成。</p><p>休息的话，现在改成以15分钟为一个单位进行休息。</p><p>自己的身体终究还是适应了晚睡，所以作息，往后顺延一个小时，说不出呢还是7点起床呢～。哈哈哈</p><p>新的一天加油。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总的来说，今天的效率好了很多。几乎在战斗的时候，都属于认真状态。但是错过了本可以完成所有今天任务的机会。&lt;/p&gt;
&lt;p&gt;对于娱乐，应该先把主要任务完成。&lt;/p&gt;
&lt;p&gt;休息的话，现在改成以15分钟为一个单位进行休息。&lt;/p&gt;
&lt;p&gt;自己的身体终究还是适应了晚睡，所以作息，往
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>mergeSort</title>
    <link href="http://yoursite.com/2018/02/07/mergeSort/"/>
    <id>http://yoursite.com/2018/02/07/mergeSort/</id>
    <published>2018-02-07T04:01:32.000Z</published>
    <updated>2018-02-08T01:47:11.518Z</updated>
    
    <content type="html"><![CDATA[<p>2018.2.7 初稿<br>2018.2.8 修改</p><hr><p>归并排序算是比较高级的排序，采用分而治之的算法思想，相较插入排序和选择排序这类采用减而治之思想的算法。分而治之的思想可以更快使问题规模下降，进而求解。当问题规模开始下降，那么也意味着该问题的有序性正在变得越来越强。在对于几乎有序的数组，插入排序拥有 $O(n)$ 级别的算法复杂度。 换言之，当问题规模下降到某一程度时，我们可以采用插入排序作为分而治之算法的子过程。</p><p>分治算法的基本思想是将一个规模为$N$的问题分解为$K$个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。</p><p>分治算法的一般步骤：</p><ol><li><p>分解，将要解决的问题划分成若干规模较小的同类问题</p></li><li><p>求解，当子问题划分足够小时，用较简单的方法解决</p></li><li><p>合并，按原问题的要求，将子问题的解逐层合并构成原问题的解</p></li></ol><p>归并排序是分之思想的一个典型体现，主要思想是：把问题分解成对两部分已经排好序的序列进行排序。</p><p>这里我们采用递归的方式逐步实现该算法。</p><p>还记得我们创建的工具中的排序模板吗？$void(*sort)(T[\ ],\ int)$,因为要将问题划分成两部分，为此我们有必要规定一个明确的范围，就像下面这个样子一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    __mergeSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>$mergeSort$要对一个规模为 n 的 数组arr 进行排序，实质上是通过$\_\_mergeSort$ 在<strong>[ 0, n - 1 ]</strong> 范围内对 arr 进行排序，当然，也可以理解成在<strong>[ 0, n ）</strong> 这个范围内。但我们应该去保证这个定义的正确性与不变性，从这点出发，很多问题将被简化。</p><p>终止条件是递归算法整体退出的唯一出口，即便是终止条件，也应该去维护 $\_\_mergeSort$ 要返回一个指定区间的有序数组的基本条件。同时基于<em>当数组只含一个元素是有序的</em> 的认识。对于终止条件就可以是<strong>当区间只含有一个元素时，应该终止算法</strong>。</p><p>那么我的算法就是下面<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> __mergeSort(T arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</div><div class="line">    <span class="keyword">if</span>(l &gt;= r)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> mi = (l+r)/<span class="number">2</span>;</div><div class="line">    __mergeSort(arr, l, mi);</div><div class="line">    __mergeSort(arr, mi + <span class="number">1</span>, r);</div><div class="line"></div><div class="line">    __merge(arr, l, mi, r);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这个方法中，我们将 <strong>[l, r]</strong> 划分成两个范围 <strong>[l, (l+r)/2]</strong> 和 <strong>[l, (l+r)/2 + 1]</strong> 并对他们排序，之后再将这两部分进行合并得出结果。同时当数组只含有一个元素时，直接返回，不需要任何处理，因为当数组只含一个元素，他怎么都是有序的。</p><p>所以$\_\_merge$ 只需要将这两个有序区间合并即可,在阅读下面算法的时候，要时刻注意定义的保持性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">void __merge(T arr[],int l, int mi, int r)&#123;</div><div class="line">    </div><div class="line">    //1</div><div class="line">    T aux[r-l + 1]; </div><div class="line">    for(int i = l; i &lt;= r;i++)&#123;</div><div class="line">        aux[i - l] = arr[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //2</div><div class="line">    int j = mi - l + 1;</div><div class="line">    int i = l -l;</div><div class="line">    </div><div class="line">    //3</div><div class="line">    for(int k = l; k &lt;= r;k++)&#123;</div><div class="line">        if(i+l &gt; mi )&#123;</div><div class="line">            arr[k] = aux[j];</div><div class="line">            j++;</div><div class="line">        &#125;else if(j+l &gt; r)&#123;</div><div class="line">            arr[k] = aux[i];</div><div class="line">            i++;</div><div class="line">        &#125;else if(aux[i] &lt; aux[j])&#123;</div><div class="line">            arr[k] = aux[i];</div><div class="line">            i++;</div><div class="line">        &#125;else&#123;</div><div class="line">            arr[k] = aux[j];</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 $1$ 这个标记处，我们对arr 满足<strong>[l, r]</strong>这个区间的数进行复制，在这部分数当中，里面包含了两部分<strong>[l, mi]</strong> 和 <strong>[mi+1, r]</strong>。紧接着，我们在 $2$ 这个标记处，将 j 指向 <strong>aux</strong> 第二部分的首元素，将 i 指向 <strong>aux</strong> 第一部分的首元素。之后，我们通过<strong>K</strong> 依次遍历，最终得到有序数组。</p><p>最后用实际的例子来感受一下$O(log^n)$和$O(n^2)$算法的差距。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">    int n = 100000;</div><div class="line">    </div><div class="line">    cout&lt;&lt;&quot;Test for random array, size = &quot;&lt;&lt;n&lt;&lt;&quot;, random range [0, &quot;&lt;&lt;n&lt;&lt;&quot;]&quot;&lt;&lt;endl;</div><div class="line">    int* arr1 = SortTestHelper::generateRandomArray(n,0,n);</div><div class="line">    int* arr2 = SortTestHelper::copyIntArray(arr1, n);</div><div class="line"></div><div class="line">    SortTestHelper::testSort(&quot;Insertion Sort&quot;, insertionSort, arr1, n);</div><div class="line">    SortTestHelper::testSort(&quot;Merge Sort&quot;,     mergeSort,arr2, n);</div><div class="line"></div><div class="line">    cout&lt;&lt;endl;</div><div class="line">    delete[] arr1;</div><div class="line">    delete[] arr2;</div><div class="line"></div><div class="line">    cout&lt;&lt;endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://p3o1bechg.bkt.clouddn.com/mergeSort%E5%92%8CInsertionSort.png" alt="MergeSort和InsertionSort的比较"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018.2.7 初稿&lt;br&gt;2018.2.8 修改&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;归并排序算是比较高级的排序，采用分而治之的算法思想，相较插入排序和选择排序这类采用减而治之思想的算法。分而治之的思想可以更快使问题规模下降，进而求解。当问题规模开始下降，那么也意味着该问题的有序性
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>log005</title>
    <link href="http://yoursite.com/2018/02/06/log005/"/>
    <id>http://yoursite.com/2018/02/06/log005/</id>
    <published>2018-02-06T15:56:48.000Z</published>
    <updated>2018-02-06T15:57:36.336Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚的关于优化ss的问题，让我熬到凌晨3点，严重影响了今天的计划。坏事情总是接连发生，我在本该做这个事情的时间段，做了其他。对于一个难题的解决，对问题的坚持固然重要，但这并不是延误其他事情的一个好理由。</p><p>每天的任务是定量的，所有的行为，应该把每天的任务放在首位。在明知，无法全部完成时，应该尽可能多的完成。</p><p>我想要的不仅仅是进步，而是高效的进步。你应该集中注意力的去做每一件事情。</p><p>我无法做到十全十美，但是应该将自己可以做到完成。</p><p>我要竭尽全力，而不是尽力。不要让自己变成自己所拒绝的人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨晚的关于优化ss的问题，让我熬到凌晨3点，严重影响了今天的计划。坏事情总是接连发生，我在本该做这个事情的时间段，做了其他。对于一个难题的解决，对问题的坚持固然重要，但这并不是延误其他事情的一个好理由。&lt;/p&gt;
&lt;p&gt;每天的任务是定量的，所有的行为，应该把每天的任务放在首位
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>log004</title>
    <link href="http://yoursite.com/2018/02/06/log004/"/>
    <id>http://yoursite.com/2018/02/06/log004/</id>
    <published>2018-02-05T16:48:37.000Z</published>
    <updated>2018-02-05T16:49:20.082Z</updated>
    
    <content type="html"><![CDATA[<p>别的我倒不认为有什么优势，但唯独可以坚持下来。</p><p>和最近任务有关系，没有很明确的一个目标，现在每天过得可以说自我感觉十分糟糕，虽然每天都有在提</p><p>高，但我想要更高的效率。</p><p>也谈不上匆忙，总而言之，这件事情必须睡觉之前做完。</p><hr><p>明天任务：</p><ul><li>英语学习两小时，完成英语流利说的任务，其余时间看英文视频</li><li>完成归并和快速排序的算法，并且写一篇文章</li><li>看完Android网络框架，记录并且解决部分问题</li><li>学习一种新的设计模式</li></ul><hr><p>起床： 7:00</p><p>算法的战斗： 8:00 – 12:00</p><p>Android的战斗： 14:00 – 17:00</p><p>英语的战斗：    17:00 – 18:00</p><p>设计模式的战斗：20:00 – 22:00 </p><p>其余时间自由安排。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;别的我倒不认为有什么优势，但唯独可以坚持下来。&lt;/p&gt;
&lt;p&gt;和最近任务有关系，没有很明确的一个目标，现在每天过得可以说自我感觉十分糟糕，虽然每天都有在提&lt;/p&gt;
&lt;p&gt;高，但我想要更高的效率。&lt;/p&gt;
&lt;p&gt;也谈不上匆忙，总而言之，这件事情必须睡觉之前做完。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="2018-2" scheme="http://yoursite.com/categories/2018-2/"/>
    
    
      <category term="Log" scheme="http://yoursite.com/tags/Log/"/>
    
  </entry>
  
</feed>
